// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: worker.v1.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Empty } from "./google/protobuf/empty";
import { Struct } from "./google/protobuf/struct";

export const protobufPackage = "io.highstate.worker.v1";

export interface ConnectRequest {
  /** The ID of the worker version connecting to the service. */
  workerVersionId: string;
}

export interface UpdateWorkerVersionMetaRequest {
  /** The ID of the worker version to update. */
  workerVersionId: string;
  /** The new metadata of the worker version. */
  meta?: { [key: string]: any } | undefined;
}

/**
 * The event sent by the unit requests the worker and registers itself.
 * When the worker establishes a connection to the service, it will
 * receive all existing unit registrations and then continue to receive
 * new registrations as they occur.
 */
export interface UnitRegistration {
  /** The ID of the unit state being registered. */
  stateId: string;
  /** The parameters provided by the unit. */
  params?: { [key: string]: any } | undefined;
}

export interface UnitDeregistration {
  /** The ID of the unit state being unregistered. */
  stateId: string;
}

export interface WorkerEvent {
  event?: { $case: "unitRegistration"; value: UnitRegistration } | {
    $case: "unitDeregistration";
    value: UnitDeregistration;
  } | undefined;
}

function createBaseConnectRequest(): ConnectRequest {
  return { workerVersionId: "" };
}

export const ConnectRequest: MessageFns<ConnectRequest> = {
  encode(message: ConnectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerVersionId !== "") {
      writer.uint32(10).string(message.workerVersionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerVersionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectRequest {
    return { workerVersionId: isSet(object.workerVersionId) ? globalThis.String(object.workerVersionId) : "" };
  },

  toJSON(message: ConnectRequest): unknown {
    const obj: any = {};
    if (message.workerVersionId !== "") {
      obj.workerVersionId = message.workerVersionId;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectRequest>): ConnectRequest {
    return ConnectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectRequest>): ConnectRequest {
    const message = createBaseConnectRequest();
    message.workerVersionId = object.workerVersionId ?? "";
    return message;
  },
};

function createBaseUpdateWorkerVersionMetaRequest(): UpdateWorkerVersionMetaRequest {
  return { workerVersionId: "", meta: undefined };
}

export const UpdateWorkerVersionMetaRequest: MessageFns<UpdateWorkerVersionMetaRequest> = {
  encode(message: UpdateWorkerVersionMetaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerVersionId !== "") {
      writer.uint32(10).string(message.workerVersionId);
    }
    if (message.meta !== undefined) {
      Struct.encode(Struct.wrap(message.meta), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWorkerVersionMetaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWorkerVersionMetaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerVersionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWorkerVersionMetaRequest {
    return {
      workerVersionId: isSet(object.workerVersionId) ? globalThis.String(object.workerVersionId) : "",
      meta: isObject(object.meta) ? object.meta : undefined,
    };
  },

  toJSON(message: UpdateWorkerVersionMetaRequest): unknown {
    const obj: any = {};
    if (message.workerVersionId !== "") {
      obj.workerVersionId = message.workerVersionId;
    }
    if (message.meta !== undefined) {
      obj.meta = message.meta;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWorkerVersionMetaRequest>): UpdateWorkerVersionMetaRequest {
    return UpdateWorkerVersionMetaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWorkerVersionMetaRequest>): UpdateWorkerVersionMetaRequest {
    const message = createBaseUpdateWorkerVersionMetaRequest();
    message.workerVersionId = object.workerVersionId ?? "";
    message.meta = object.meta ?? undefined;
    return message;
  },
};

function createBaseUnitRegistration(): UnitRegistration {
  return { stateId: "", params: undefined };
}

export const UnitRegistration: MessageFns<UnitRegistration> = {
  encode(message: UnitRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stateId !== "") {
      writer.uint32(10).string(message.stateId);
    }
    if (message.params !== undefined) {
      Struct.encode(Struct.wrap(message.params), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnitRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnitRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnitRegistration {
    return {
      stateId: isSet(object.stateId) ? globalThis.String(object.stateId) : "",
      params: isObject(object.params) ? object.params : undefined,
    };
  },

  toJSON(message: UnitRegistration): unknown {
    const obj: any = {};
    if (message.stateId !== "") {
      obj.stateId = message.stateId;
    }
    if (message.params !== undefined) {
      obj.params = message.params;
    }
    return obj;
  },

  create(base?: DeepPartial<UnitRegistration>): UnitRegistration {
    return UnitRegistration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnitRegistration>): UnitRegistration {
    const message = createBaseUnitRegistration();
    message.stateId = object.stateId ?? "";
    message.params = object.params ?? undefined;
    return message;
  },
};

function createBaseUnitDeregistration(): UnitDeregistration {
  return { stateId: "" };
}

export const UnitDeregistration: MessageFns<UnitDeregistration> = {
  encode(message: UnitDeregistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stateId !== "") {
      writer.uint32(10).string(message.stateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnitDeregistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnitDeregistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stateId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnitDeregistration {
    return { stateId: isSet(object.stateId) ? globalThis.String(object.stateId) : "" };
  },

  toJSON(message: UnitDeregistration): unknown {
    const obj: any = {};
    if (message.stateId !== "") {
      obj.stateId = message.stateId;
    }
    return obj;
  },

  create(base?: DeepPartial<UnitDeregistration>): UnitDeregistration {
    return UnitDeregistration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnitDeregistration>): UnitDeregistration {
    const message = createBaseUnitDeregistration();
    message.stateId = object.stateId ?? "";
    return message;
  },
};

function createBaseWorkerEvent(): WorkerEvent {
  return { event: undefined };
}

export const WorkerEvent: MessageFns<WorkerEvent> = {
  encode(message: WorkerEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.event?.$case) {
      case "unitRegistration":
        UnitRegistration.encode(message.event.value, writer.uint32(10).fork()).join();
        break;
      case "unitDeregistration":
        UnitDeregistration.encode(message.event.value, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = { $case: "unitRegistration", value: UnitRegistration.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.event = { $case: "unitDeregistration", value: UnitDeregistration.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerEvent {
    return {
      event: isSet(object.unitRegistration)
        ? { $case: "unitRegistration", value: UnitRegistration.fromJSON(object.unitRegistration) }
        : isSet(object.unitDeregistration)
        ? { $case: "unitDeregistration", value: UnitDeregistration.fromJSON(object.unitDeregistration) }
        : undefined,
    };
  },

  toJSON(message: WorkerEvent): unknown {
    const obj: any = {};
    if (message.event?.$case === "unitRegistration") {
      obj.unitRegistration = UnitRegistration.toJSON(message.event.value);
    } else if (message.event?.$case === "unitDeregistration") {
      obj.unitDeregistration = UnitDeregistration.toJSON(message.event.value);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerEvent>): WorkerEvent {
    return WorkerEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerEvent>): WorkerEvent {
    const message = createBaseWorkerEvent();
    switch (object.event?.$case) {
      case "unitRegistration": {
        if (object.event?.value !== undefined && object.event?.value !== null) {
          message.event = { $case: "unitRegistration", value: UnitRegistration.fromPartial(object.event.value) };
        }
        break;
      }
      case "unitDeregistration": {
        if (object.event?.value !== undefined && object.event?.value !== null) {
          message.event = { $case: "unitDeregistration", value: UnitDeregistration.fromPartial(object.event.value) };
        }
        break;
      }
    }
    return message;
  },
};

export type WorkerServiceDefinition = typeof WorkerServiceDefinition;
export const WorkerServiceDefinition = {
  name: "WorkerService",
  fullName: "io.highstate.worker.v1.WorkerService",
  methods: {
    /** Connects to the worker service and streams events. */
    connect: {
      name: "connect",
      requestType: ConnectRequest,
      requestStream: false,
      responseType: WorkerEvent,
      responseStream: true,
      options: {},
    },
    /** Update the metadata of the worker version. */
    updateWorkerVersionMeta: {
      name: "updateWorkerVersionMeta",
      requestType: UpdateWorkerVersionMetaRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface WorkerServiceImplementation<CallContextExt = {}> {
  /** Connects to the worker service and streams events. */
  connect(
    request: ConnectRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<WorkerEvent>>;
  /** Update the metadata of the worker version. */
  updateWorkerVersionMeta(
    request: UpdateWorkerVersionMetaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface WorkerServiceClient<CallOptionsExt = {}> {
  /** Connects to the worker service and streams events. */
  connect(request: DeepPartial<ConnectRequest>, options?: CallOptions & CallOptionsExt): AsyncIterable<WorkerEvent>;
  /** Update the metadata of the worker version. */
  updateWorkerVersionMeta(
    request: DeepPartial<UpdateWorkerVersionMetaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
