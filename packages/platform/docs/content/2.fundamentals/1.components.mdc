---
title: Components
description: The basic building blocks of Highstate infrastructure.
navigation:
  icon: i-lucide-component
---

## Quick Reference

If you haven't read the [concepts page](/concepts) yet, go there first! Here's a quick refresher:

- **Component**: A reusable, self-contained unit of infrastructure (like a server, database, or entire application stack)
- **Instance**: A specific usage of a component with its own configuration
- **Entity**: Structured data that flows between components (like server info or cluster credentials)
- **Unit**: A component backed by actual Pulumi code that creates infrastructure
- **Composite**: A component that combines other components into higher-level patterns

Now let's learn how to build your own components!

## Prerequisites

To understand this chapter, you should be familiar with the basic concepts of cloud infrastructure.

You should also have basic knowledge of [TypeScript](https://www.typescriptlang.org/docs/) and [Node.js](https://nodejs.org/en/docs/) development.

## Project Setup

Before we start, we need to say a few words about the project setup.
We assume you already created a basic project using the [Installation Guide](/getting-started/installation).
But this project can only be used to create instances of existing components.
Lets make it suitable for component development as well.

First, we need to transform our project into a monorepo that can contain multiple packages.
We will create single package for our component definitions and place their implementation into a separate package.
The standard library follows the same structure: `@highstate/library` contains component definitions, while packages like `@highstate/common`, `@highstate/k8s` and so on contain implementations.

You can use any monorepo tool you like. In this guide, we will use Yarn Workspaces without any additional tooling.

Here the folder structure we will create:

```
.
├── packages
│   ├── library          # component definitions
│   │   ├── src
│   │   │   └── index.ts
│   │   ├── tsconfig.json
│   │   └── package.json
│   └── units            # component implementations (not covered in this guide)
└── package.json
```

Here the minimal `package.json` for root folder:

```json
{
  "name": "acme",
  "private": true,
  "workspaces": ["packages/*"],
  "devDependencies": {
    "@highstate/cli": "^0",
    "typescript": "^5",
  }
}
```

Here the `package.json` for the `library` package:

```json
{
  "name": "@acme/library",
  "type": "module",
  "scripts": {
    "build": "highstate build"
  },
  "dependencies": {
    "@highstate/contract": "^0",
    "@highstate/library": "^0",
  },
  "devDependencies": {
    "@highstate/cli": "^0",
  }
}
```

Note that we depend on `@highstate/library` to reference existing entities and components from the standard library.
We also depend on `@highstate/contract`. This is the core package to define shared contracts for components and entities.
We also define a `build` script that compiles our components using the Highstate CLI.

Here the `tsconfig.json` for the `library` package:

```json
{
  "extends": "../../../node_modules/@highstate/cli/assets/tsconfig.base.json",
  "include": [
    "./src/**/*.ts",
  ]
}
```

In this case we reuse the base `tsconfig.json` provided by the Highstate CLI.
Assuming that all packages are located in `packages` and all their dependencies are flat (no nested `node_modules` folders), this configuration should work fine.

Now we can define our components.
You can use any file structure you like.
The only requirement is that all component definitions must be exported from `src/index.ts` file.

At this point, you can launch `highstate designer` from the root folder. It will automatically locate and build the `library` package and all other packages in the monorepo.
It will also watch for changes and rebuild the packages as needed. The designer will also automatically reload components in real-time.

## Your First Component

Alright, let's build your first component!
We'll start simple and add features as we go.

Here's the absolute minimum you need:

```typescript
import { defineUnit } from "@highstate/contract"

export const blogApp = defineUnit({
  // 1. unique component type identifier
  type: "acme.blog-app.v1",

  // 2. implementation reference
  source: {
    package: "@acme/units",
    path: "blog-app",
  },
})
```

Each component must have a unique `type` in the following format: `{name}.v{major}`.
The `name` must be lowercase and can include dots and dashes.
You can use namespacing strategy that works best for you,
but we recommend using your organization name or nickname as a prefix to avoid collisions.

How unique the `type` must be?
Well, it is not really enforced anywhere, but you cannot load two components with the same `type` in a single project.

The type must also include a major version number, like `v1`, `v2`, etc.
The components with different major versions are considered completely separate components and can be used side by side in the same project.

The `source` field tells Highstate where to find the implementation of this component.
We will cover implementations later in [Units](/fundamentals/units) guide.

That's it!
You've got a valid component.
Pretty basic though:

::snippet-preview{snippet="fundamentals/components/minimal-component"}
::

Let's make it look good in the designer by adding some visual metadata:

```typescript
import { defineUnit } from "@highstate/contract"

export const blogApp = defineUnit({
  type: "acme.blog-app.v1",

  // visual metadata for the designer
  meta: {
    title: "Blog Application",
    description: "A simple blog with posts and comments",
    icon: "mdi:post",
    category: "Applications",
  },

  source: {
    package: "@acme/units",
    path: "blog-app",
  },
})
```

Here's how it looks now:

::snippet-preview{snippet="fundamentals/components/component-with-meta"}
::

## Making Components Configurable

A static component isn't very useful.
Let's add some arguments so users can customize it for different situations.

**Important**: Arguments are for configuration, not secrets! Never put passwords or API keys here - we'll cover secrets later.

We use [`zod`](https://zod.dev/) for argument schemas - it gives us validation and TypeScript types in one go.

Let's make our blog configurable by adding arguments:

```typescript
import { defineUnit, z } from "@highstate/contract"

export const blogApp = defineUnit({
  type: "acme.blog-app.v1",

  // NEW: configurable arguments
  args: {
    domain: z.string(),
    replicas: z.number(),
    enableComments: z.boolean(),
  },

  meta: {
    title: "Blog Application",
    description: "A simple blog with posts and comments",
    icon: "mdi:post",
    category: "Applications",
  },

  source: {
    package: "@acme/units",
    path: "blog-app",
  },
})
```

### What Types Can You Use?

Highstate automatically creates the right UI for each argument type.
Here's what you get:

| Type | UI Element |
| ---- | ---------- |
| `z.string()` | Text input |
| `z.string().array()` | [Combobox](https://vuetifyjs.com/en/components/combobox/) |
| `z.number()` | Number input |
| `z.number().array()` | Combobox with numbers |
| `z.boolean()` | Checkbox |
| `z.enum([...])` | Dropdown select |
| `z.enum([...]).array()` | Multi-select dropdown |
| `z.object({...})` _(1 level deep)_ | The group of inputs |
| `other` | YAML editor with schema validation | 

Want to see all these types in action?
Here's our blog with every argument type:

```typescript
import { defineUnit, z } from "@highstate/contract"

export const blogApp = defineUnit({
  type: "acme.blog-app.v1",

  // configurable arguments
  args: {
    // text input
    domain: z.string(),

    // number input
    replicas: z.number(),

    // checkbox
    enableComments: z.boolean(),

    // dropdown select
    theme: z.enum(["light", "dark", "auto"]),

    // multi-select dropdown
    features: z.enum(["analytics", "seo", "cache"]).array(),

    // group of inputs
    limits: z.object({
      cpu: z.string(),
      memory: z.string(),
    }),
  },

  meta: {
    title: "Blog Application",
    description: "A simple blog with posts and comments",
    icon: "mdi:post",
    category: "Applications",
  },

  source: {
    package: "@acme/units",
    path: "blog-app",
  },
})
```

Go ahead, click that "edit" button and explore the different UI elements:

::snippet-preview{snippet="fundamentals/components/component-with-args"}
::

### Default and Optional Values

You can define optional and default values for arguments using `.optional()` and `.default(...)` methods.
In most cases, you should prefer default values over optional arguments, as they make components easier to implement and use.

To prevent confusion, certain "empty" values are always considered as `not set`:
- `""` (empty string)
- `[]` (empty array)
- `{}` (empty object)
- `null`
- `undefined` (obviously)

The only exception is `z.boolean()`, which can be set to `false` and still be considered a valid value.

If you explicitly set an argument to one of these values __OR__ to the default value, it will be removed from the component configuration.
This behavior allows users to easily reset arguments to their defaults.

Here are some examples to illustrate this behavior:

1. You define an argument as `z.string().default("default value")`.
   If you set it to `""` (erase the field) or `"default value"`, the value will be removed from the component configuration.
   Your component implementation will receive `"default value"` in both cases.

2. You define an argument as `z.object({ name: z.string() }).partial().default({})`.
   If you set it to `{}` or don't set it at all, the value will be removed from the component configuration.
   Your component implementation will receive an empty object `{}` in both cases.

3. __But__ if you define an argument as `z.boolean().default(true)`, and you set it to `false`, the value will be kept in the component configuration.
   However, if you define it as `z.boolean().default(false)`, and you set it to `false`, the value will be removed from the component configuration not because it's empty, but because it matches the default value.

This behavior allows user to easily reset the argument to its defaults.

::warning
Avoid using `z.enum([...]).optional()` since there is no nice way for the user to reset the value to its default.
Instead, use `z.enum([...]).default(...)` and set the default value to one of the enum values.
You can introduce a special value like `"none"` or `"default"` to indicate that the argument is not set.
::

## Connecting Components Together

Arguments are great for configuration, but the real magic happens when components talk to each other.

Remember [entities from the concepts page](/concepts#entities)?
They're the data that flows between components.
Our blog needs a Kubernetes cluster to run on and should expose a web service for other components.

Let's add some inputs and outputs:

```typescript
import { defineUnit, z } from "@highstate/contract"
import { k8s, databases } from "@highstate/library"  // NEW: import entities from the standard library

export const blogApp = defineUnit({
  type: "acme.blog-app.v1",

  args: {
    domain: z.string(),
    replicas: z.number(),
  },

  // NEW: components can connect to each other via inputs and outputs
  inputs: {
    // this blog needs a Kubernetes cluster to deploy to
    cluster: k8s.clusterEntity,
    // and a database to store posts
    database: databases.mariadbEntity,
  },

  outputs: {
    // lets expose the "service" so other components in the cluster can connect to our app
    webService: k8s.serviceEntity,
  },

  meta: {
    title: "Blog Application",
    description: "A simple blog with posts and comments",
    icon: "mdi:post",
    category: "Applications",
  },

  source: {
    package: "@acme/units",
    path: "blog-app",
  },
})
```

Look at that! Our blog can now connect to other components:

::snippet-preview{snippet="fundamentals/components/component-with-connections"}
::

Here's what a simplified `k8s.cluster` entity looks like (the real one is much more complex):

```typescript
import { defineEntity, z } from "@highstate/contract"

export const clusterEntity = defineEntity({
  // 1. each entity also must have a unique type across the project
  type: "k8s.cluster.v1",

  // 2. schema defines what data this entity contains
  schema: z.object({
    id: z.string(),
    kubeconfig: z.string(),
  }),

  // 3. visual metadata for the designer
  meta: {
    color: "#2196F3",
  },
})
```

See the `id` and `kubeconfig`?
That's what other components need to talk to this cluster.

## Connection Rules

Components can have multiple inputs and outputs.
Each of them can be `multiple` and `optional`.
This affects how they can connect.

The designer won't let you make invalid connections, but it's good to understand the rules.
Here's what works and what doesn't:

- `S` = single
- `M` = multiple
- `O` = optional

| From    | To      | Allowed | Description                                                                                                         |
| ------- | ------- | ------- | ------------------------------------------------------------------------------------------------------------------- |
| `S`     | `S/SO`  | ✅      | One entity from the output is passed to the input.                                                                  |
| `S`     | `M/MO`  | ✅      | One entity from the output is passed to an input that accepts multiple entities.                                    |
| `M`     | `M/MO`  | ✅      | Multiple entities from the output are passed to the input.<br>All entities from all outputs are merged into one array. |
| `M/MO`  | `S/SO`  | ❌      | Not allowed since it's ambiguous which entity should be passed to the input.                                       |
| `SO`    | `S/M`   | ⚠️      | Allowed only when there are other non-optional inputs connected.                                                         |
| `SO`    | `SO/MO` | ✅      | One optional entity from the output is passed to an optional input.                                                 |
| `SO/MO` | `M`     | ⚠️      | Allowed only when there are other non-optional inputs connected.                                                         |
| `MO`    | `MO`    | ✅      | Multiple optional entities from the output are passed to an optional input that accepts multiple entities.          |

Only one rule is strictly forbidden: you can't connect multiple outputs to single inputs (because which one would it pick?).
The ⚠️ cases work but might fail at runtime if optional dependencies aren't met.

Here are some real examples of using different connection types from the standard library:

1. A [k3s](https://docs.k3s.io/) cluster deployed on top of multiple servers:

::snippet-preview{snippet="fundamentals/components/k3s-cluster-io" height="800px"}
::

2. A wireguard server with multiple clients:

::snippet-preview{snippet="fundamentals/components/wireguard-server" height="800px"}
::

## Making Components Look Good

You can customize how components, arguments, and inputs/outputs appear in the designer:

### Component Metadata

::fieldgroup
  ::field{name="title" type="string"}
  The title of the component, which is displayed in the designer.
  If not explicitly set, the title is derived from the component name.
  ::
  ::field{name="description" type="string"}
  A short description of the component, which is displayed in the component list.
  ::
  ::field{name="icon" type="string"}
  The primary icon of the component, which is displayed in the component card.
  ::
  ::field{name="iconColor" type="string"}
  The color of the primary icon.
  ::
  ::field{name="secondaryIcon" type="string"}
  The secondary icon of the component, which is displayed near the main icon in the component card.
  ::
  ::field{name="secondaryIconColor" type="string"}
  The color of the secondary icon.
  ::
  ::field{name="category" type="string"}
  The category of the component, which groups components in the component list.
  The default category is `Other`.
  Categories are case-insensitive and uppercased in the designer,
  but it's recommended to use title-cased words and phrases in plural form.
  For example, `Databases`, `Servers`, `Applications`, `Monitoring`, etc.
  ::
::

### Argument Metadata

::fieldgroup
  ::field{name="title" type="string"}
  The title of the argument, which is displayed in the designer.
  If not explicitly set, the title is derived from the argument name.
  ::
  ::field{name="description" type="string"}
  A short description of the argument, which is displayed in the designer.
  ::
  ::field{name="icon" type="string"}
  The icon of the argument, which is displayed in the designer.
  If not explicitly set, the icon is derived from the argument type.
  ::
  ::field{name="iconColor" type="string"}
  The color of the icon.
  ::
::

### Input/Output Metadata

::fieldgroup
  ::field{name="title" type="string"}
  The title of the input/output, which is displayed in the designer.
  If not explicitly set, the title is derived from the input/output name.
  ::
::

## What's Next?

Remember [units and composites from the concepts page](/concepts#units)? Now let's see how to actually build them:

### Units

Units do the actual work - they're backed by Pulumi code that creates real infrastructure.
A unit can be anything from a single DNS record to an entire application stack.

Start big if you want! Create one massive unit for your whole infrastructure, then break it down into smaller pieces later.

::card
---
title: Units
icon: i-mdi-cube
to: /fundamentals/units
---
Learn how to create atomic building blocks that manage infrastructure resources.
::

### Composites

Composites don't create infrastructure - they just wire existing components together into reusable patterns.

Think "web application stack" that combines a cluster, database, load balancer, and monitoring.
Your team can use the composite without knowing all the gory details inside.

::card
---
title: Composites
icon: i-mdi-cube-outline
to: /fundamentals/composite-components
---
Discover how to combine components into higher-level abstractions.
::

## What's Next?

Ready to build your own components? Here's where to go:

- **Units** - Create new infrastructure patterns or integrate services not in the standard library
- **Composites** - Package existing components into higher-level, reusable patterns  
- **Standard Library** - See real examples of both units and composites in action
