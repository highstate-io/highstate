
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.
 *
 * ðŸŸ¢ You can import this file directly.
 */

import * as process from 'node:process'
import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
const __dirname = path.dirname(fileURLToPath(import.meta.url))

import * as runtime from "@prisma/client/runtime/client"
import * as $Enums from "./enums.ts"
import * as $Class from "./internal/class.ts"
import * as Prisma from "./internal/prismaNamespace.ts"

export * as $Enums from './enums.ts'
/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ApiKeys
 * const apiKeys = await prisma.apiKey.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export const PrismaClient = $Class.getPrismaClientClass(__dirname)
export type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions["omit"] = Prisma.PrismaClientOptions["omit"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>
export { Prisma }



/**
 * Model ApiKey
 * The API key provides authentication tokens for accessing the platform API.
 * 
 * Each API key impersonates a service account, inheriting its permissions and access scope.
 * Keys are automatically created for worker versions and can be manually created for
 * external integrations. The token is a 32-byte random hex string that can be regenerated.
 */
export type ApiKey = Prisma.ApiKeyModel
/**
 * Model Artifact
 * The artifact represents a file or folder stored in the system.
 * 
 * It can be produced by units or manually uploaded via API by service accounts.
 * 
 * Since different actors can produce the same artifact with the same content and hash,
 * there is the ownership/usage concept to track which entities produce or use the artifact.
 * The "ownership" and "usage" are synonymous in this context and often referred to as "usage".
 * 
 * When no usages are present, the artifact will be automatically garbage collected after a certain period.
 */
export type Artifact = Prisma.ArtifactModel
/**
 * Model InstanceCustomStatus
 * 
 */
export type InstanceCustomStatus = Prisma.InstanceCustomStatusModel
/**
 * Model InstanceEvaluationState
 * The evaluation state tracks the result of evaluating composite instances to produce virtual instances.
 * 
 * Composite instances are template components that generate other instances (virtual instances) when evaluated.
 * The evaluation process executes the composite's create function with resolved inputs to produce a tree
 * of child instances. These virtual instances exist in the source "virtual" state and can be units
 * (mapping to Pulumi resources) or other composites (producing more virtual instances recursively).
 * 
 * Evaluation happens automatically after project unlock and library reloads to keep virtual instances
 * synchronized with their composite definitions. Evaluation state persists the produced instance model
 * and tracks success/error status with descriptive messages showing the instance tree or error details.
 */
export type InstanceEvaluationState = Prisma.InstanceEvaluationStateModel
/**
 * Model InstanceState
 * 
 */
export type InstanceState = Prisma.InstanceStateModel
/**
 * Model UserProjectViewport
 * 
 */
export type UserProjectViewport = Prisma.UserProjectViewportModel
/**
 * Model UserCompositeViewport
 * 
 */
export type UserCompositeViewport = Prisma.UserCompositeViewportModel
/**
 * Model InstanceLock
 * 
 */
export type InstanceLock = Prisma.InstanceLockModel
/**
 * Model InstanceModel
 * The container for project instances. 
 * 
 * Only used when "database" project model storage is used.
 */
export type InstanceModel = Prisma.InstanceModelModel
/**
 * Model HubModel
 * The container for project hubs.
 * 
 * Only used when "database" project model storage is used.
 */
export type HubModel = Prisma.HubModelModel
/**
 * Model Operation
 * 
 */
export type Operation = Prisma.OperationModel
/**
 * Model InstanceOperationState
 * 
 */
export type InstanceOperationState = Prisma.InstanceOperationStateModel
/**
 * Model OperationLog
 * 
 */
export type OperationLog = Prisma.OperationLogModel
/**
 * Model Page
 * The page provides custom UI content for instances and service accounts.
 * 
 * Pages can be created by units to display instance-specific information or by service accounts.
 * The content consists of blocks that support markdown text, QR codes with optional content display,
 * and file attachments (inline or artifact references). Instance pages are explicitly deleted
 * when instances are destroyed.
 */
export type Page = Prisma.PageModel
/**
 * Model Secret
 * The secret stores sensitive configuration values for instances, service accounts, and system components.
 * 
 * Secrets can be instance-owned (for unit configuration), service account-owned, or system-level
 * (like Pulumi passwords). 
 * 
 * Secrets persist through normal destroy (recreate) operations
 * and are only deleted when explicitly forgetting instance state with the deleteSecrets flag or when manually deleted.
 * 
 * Secret updates invalidate instance input hashes via inputHashNonce, triggering re-execution
 * during operations. But the content of the secrets itself do not contribute to the input hash.
 * 
 * System secrets like Pulumi passwords are created on-demand and persist for the whole project lifetime.
 */
export type Secret = Prisma.SecretModel
/**
 * Model ServiceAccount
 * The service account represents an identity for non-human actors in the system.
 * 
 * Service accounts are automatically created for workers and can be manually created
 * for external integrations. They define the access scope for resources like artifacts,
 * secrets, terminals, and pages. Multiple API keys can impersonate the same service account,
 * allowing different authentication tokens to share the same permissions.
 */
export type ServiceAccount = Prisma.ServiceAccountModel
/**
 * Model Terminal
 * The terminal provides interactive shell access to infrastructure resources.
 * 
 * Terminals can be created by units (owned by instances) or by service accounts.
 * Each terminal maintains a specification for creating containers that power the terminal,
 * including image, command, environment, and mounted files.
 * 
 * Instance-owned terminals are marked unavailable when the instance is destroyed, preserving session history.
 * Service account terminals persist independently.
 */
export type Terminal = Prisma.TerminalModel
/**
 * Model TerminalSession
 * The terminal session represents a single interactive connection to a terminal.
 * 
 * Each session tracks when it started and finished. All session output is preserved in logs.
 */
export type TerminalSession = Prisma.TerminalSessionModel
/**
 * Model TerminalSessionLog
 * The terminal session log captures all input and output from a terminal session.
 * 
 * Logs are stored with ULID identifiers for timestamp ordering.
 */
export type TerminalSessionLog = Prisma.TerminalSessionLogModel
/**
 * Model Trigger
 * The trigger defines automated actions that execute in response to specific events.
 * 
 * Triggers are created by units to perform actions at defined points in the instance lifecycle
 * or on schedule. The spec field determines the trigger type and behavior - currently supporting
 * before-destroy triggers, with planned support for additional types like cron scheduling.
 * Triggers are deleted along with their instance.
 */
export type Trigger = Prisma.TriggerModel
/**
 * Model UnlockMethod
 * The unlock method enables decryption of project databases through user authentication.
 * 
 * Each project database is encrypted with a master key, which is then encrypted for each
 * unlock method's recipient using AGE encryption. Users authenticate (password or passkey)
 * to decrypt their specific AGE identity, which then decrypts the master key.
 * 
 * Multiple unlock methods can exist per project, allowing different authentication paths
 * to the same encrypted database. When unlock methods are added/removed, the master key
 * is re-encrypted for the new set of recipients.
 * 
 * The encryptedIdentity contains the AGE identity encrypted with the user's authentication
 * method (password-derived key or WebAuthn), while the recipient is the public key
 * corresponding to that identity.
 */
export type UnlockMethod = Prisma.UnlockMethodModel
/**
 * Model Worker
 * The worker represents a containerized application that extends unit capabilities beyond Pulumi execution.
 * 
 * Workers enable units to perform runtime operations after Pulumi program completion,
 * such as attaching custom statuses, monitoring resources, or triggering unit reconfigurations.
 * Since Pulumi programs cannot affect instances after execution, workers bypass this limitation
 * by providing persistent runtime behavior.
 * 
 * The worker identity (fully qualified image name) indicates the same publisher/party and services as natural authentication mechanism.
 * All versions of a worker share the same service account, meaning they operate over
 * the same resources and have the same access scope within the platform.
 */
export type Worker = Prisma.WorkerModel
/**
 * Model WorkerVersion
 * The worker version represents a specific container image digest of a worker.
 * 
 * Each version corresponds to an immutable container image identified by its SHA256 digest.
 * Versions are automatically created when units reference new image digests and deleted
 * when no longer referenced by any unit registrations.
 * 
 * Each version has its own API key for isolation, but all versions of a worker
 * share the same service account and thus the same access scope within the platform.
 * The runtime starts containers when registrations exist and stops them when removed.
 */
export type WorkerVersion = Prisma.WorkerVersionModel
/**
 * Model WorkerUnitRegistration
 * The worker unit registration tracks which unit instances require specific worker versions.
 * 
 * Units declare worker dependencies through their outputs, creating registrations that
 * trigger the runtime to start corresponding worker containers. Each registration
 * includes parameters passed to the worker for unit-specific configuration.
 * 
 * Registrations are managed during operation execution - created when units declare workers
 * and removed when units are destroyed. Worker versions without registrations are garbage collected.
 */
export type WorkerUnitRegistration = Prisma.WorkerUnitRegistrationModel
/**
 * Model WorkerVersionLog
 * The worker version log captures output from running worker containers.
 * 
 * Logs include both worker-generated output and system messages from the runtime.
 * The ULID identifier provides timestamp ordering. Logs are deleted with the worker version.
 */
export type WorkerVersionLog = Prisma.WorkerVersionLogModel

export type InstanceEvaluationStatus = $Enums.InstanceEvaluationStatus
export const InstanceEvaluationStatus = $Enums.InstanceEvaluationStatus

export type InstanceStatus = $Enums.InstanceStatus
export const InstanceStatus = $Enums.InstanceStatus

export type InstanceSource = $Enums.InstanceSource
export const InstanceSource = $Enums.InstanceSource

export type OperationStatus = $Enums.OperationStatus
export const OperationStatus = $Enums.OperationStatus

export type OperationType = $Enums.OperationType
export const OperationType = $Enums.OperationType

export type InstanceOperationStatus = $Enums.InstanceOperationStatus
export const InstanceOperationStatus = $Enums.InstanceOperationStatus

export type TerminalStatus = $Enums.TerminalStatus
export const TerminalStatus = $Enums.TerminalStatus

export type UnlockMethodType = $Enums.UnlockMethodType
export const UnlockMethodType = $Enums.UnlockMethodType

export type WorkerVersionStatus = $Enums.WorkerVersionStatus
export const WorkerVersionStatus = $Enums.WorkerVersionStatus
