
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.ts"
import { type PrismaClient } from "./class.ts"

export type * from '../models.ts'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Validator
 */
export const validator = runtime.Public.validator

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 6.14.0
 * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
 */
export const prismaVersion: PrismaVersion = {
  client: "6.14.0",
  engine: "717184b7b35ea05dfa71a3236b7af656013e1e49"
}

/**
 * Utility Types
 */

export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue

export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}

/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull

type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  ApiKey: 'ApiKey',
  Artifact: 'Artifact',
  InstanceCustomStatus: 'InstanceCustomStatus',
  InstanceEvaluationState: 'InstanceEvaluationState',
  InstanceState: 'InstanceState',
  UserProjectViewport: 'UserProjectViewport',
  UserCompositeViewport: 'UserCompositeViewport',
  InstanceLock: 'InstanceLock',
  InstanceModel: 'InstanceModel',
  HubModel: 'HubModel',
  Operation: 'Operation',
  InstanceOperationState: 'InstanceOperationState',
  OperationLog: 'OperationLog',
  Page: 'Page',
  Secret: 'Secret',
  ServiceAccount: 'ServiceAccount',
  Terminal: 'Terminal',
  TerminalSession: 'TerminalSession',
  TerminalSessionLog: 'TerminalSessionLog',
  Trigger: 'Trigger',
  UnlockMethod: 'UnlockMethod',
  Worker: 'Worker',
  WorkerVersion: 'WorkerVersion',
  WorkerUnitRegistration: 'WorkerUnitRegistration',
  WorkerVersionLog: 'WorkerVersionLog'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "apiKey" | "artifact" | "instanceCustomStatus" | "instanceEvaluationState" | "instanceState" | "userProjectViewport" | "userCompositeViewport" | "instanceLock" | "instanceModel" | "hubModel" | "operation" | "instanceOperationState" | "operationLog" | "page" | "secret" | "serviceAccount" | "terminal" | "terminalSession" | "terminalSessionLog" | "trigger" | "unlockMethod" | "worker" | "workerVersion" | "workerUnitRegistration" | "workerVersionLog"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    ApiKey: {
      payload: Prisma.$ApiKeyPayload<ExtArgs>
      fields: Prisma.ApiKeyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findFirst: {
          args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findMany: {
          args: Prisma.ApiKeyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        create: {
          args: Prisma.ApiKeyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        createMany: {
          args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        delete: {
          args: Prisma.ApiKeyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        update: {
          args: Prisma.ApiKeyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        deleteMany: {
          args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        upsert: {
          args: Prisma.ApiKeyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        aggregate: {
          args: Prisma.ApiKeyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApiKey>
        }
        groupBy: {
          args: Prisma.ApiKeyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApiKeyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyCountAggregateOutputType> | number
        }
      }
    }
    Artifact: {
      payload: Prisma.$ArtifactPayload<ExtArgs>
      fields: Prisma.ArtifactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ArtifactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ArtifactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>
        }
        findFirst: {
          args: Prisma.ArtifactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ArtifactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>
        }
        findMany: {
          args: Prisma.ArtifactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
        }
        create: {
          args: Prisma.ArtifactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>
        }
        createMany: {
          args: Prisma.ArtifactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ArtifactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
        }
        delete: {
          args: Prisma.ArtifactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>
        }
        update: {
          args: Prisma.ArtifactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>
        }
        deleteMany: {
          args: Prisma.ArtifactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ArtifactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ArtifactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
        }
        upsert: {
          args: Prisma.ArtifactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ArtifactPayload>
        }
        aggregate: {
          args: Prisma.ArtifactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArtifact>
        }
        groupBy: {
          args: Prisma.ArtifactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArtifactGroupByOutputType>[]
        }
        count: {
          args: Prisma.ArtifactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ArtifactCountAggregateOutputType> | number
        }
      }
    }
    InstanceCustomStatus: {
      payload: Prisma.$InstanceCustomStatusPayload<ExtArgs>
      fields: Prisma.InstanceCustomStatusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InstanceCustomStatusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InstanceCustomStatusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>
        }
        findFirst: {
          args: Prisma.InstanceCustomStatusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InstanceCustomStatusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>
        }
        findMany: {
          args: Prisma.InstanceCustomStatusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>[]
        }
        create: {
          args: Prisma.InstanceCustomStatusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>
        }
        createMany: {
          args: Prisma.InstanceCustomStatusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InstanceCustomStatusCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>[]
        }
        delete: {
          args: Prisma.InstanceCustomStatusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>
        }
        update: {
          args: Prisma.InstanceCustomStatusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>
        }
        deleteMany: {
          args: Prisma.InstanceCustomStatusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InstanceCustomStatusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InstanceCustomStatusUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>[]
        }
        upsert: {
          args: Prisma.InstanceCustomStatusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceCustomStatusPayload>
        }
        aggregate: {
          args: Prisma.InstanceCustomStatusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInstanceCustomStatus>
        }
        groupBy: {
          args: Prisma.InstanceCustomStatusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceCustomStatusGroupByOutputType>[]
        }
        count: {
          args: Prisma.InstanceCustomStatusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceCustomStatusCountAggregateOutputType> | number
        }
      }
    }
    InstanceEvaluationState: {
      payload: Prisma.$InstanceEvaluationStatePayload<ExtArgs>
      fields: Prisma.InstanceEvaluationStateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InstanceEvaluationStateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InstanceEvaluationStateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>
        }
        findFirst: {
          args: Prisma.InstanceEvaluationStateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InstanceEvaluationStateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>
        }
        findMany: {
          args: Prisma.InstanceEvaluationStateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>[]
        }
        create: {
          args: Prisma.InstanceEvaluationStateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>
        }
        createMany: {
          args: Prisma.InstanceEvaluationStateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InstanceEvaluationStateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>[]
        }
        delete: {
          args: Prisma.InstanceEvaluationStateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>
        }
        update: {
          args: Prisma.InstanceEvaluationStateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>
        }
        deleteMany: {
          args: Prisma.InstanceEvaluationStateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InstanceEvaluationStateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InstanceEvaluationStateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>[]
        }
        upsert: {
          args: Prisma.InstanceEvaluationStateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceEvaluationStatePayload>
        }
        aggregate: {
          args: Prisma.InstanceEvaluationStateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInstanceEvaluationState>
        }
        groupBy: {
          args: Prisma.InstanceEvaluationStateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceEvaluationStateGroupByOutputType>[]
        }
        count: {
          args: Prisma.InstanceEvaluationStateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceEvaluationStateCountAggregateOutputType> | number
        }
      }
    }
    InstanceState: {
      payload: Prisma.$InstanceStatePayload<ExtArgs>
      fields: Prisma.InstanceStateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InstanceStateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InstanceStateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>
        }
        findFirst: {
          args: Prisma.InstanceStateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InstanceStateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>
        }
        findMany: {
          args: Prisma.InstanceStateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>[]
        }
        create: {
          args: Prisma.InstanceStateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>
        }
        createMany: {
          args: Prisma.InstanceStateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InstanceStateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>[]
        }
        delete: {
          args: Prisma.InstanceStateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>
        }
        update: {
          args: Prisma.InstanceStateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>
        }
        deleteMany: {
          args: Prisma.InstanceStateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InstanceStateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InstanceStateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>[]
        }
        upsert: {
          args: Prisma.InstanceStateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceStatePayload>
        }
        aggregate: {
          args: Prisma.InstanceStateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInstanceState>
        }
        groupBy: {
          args: Prisma.InstanceStateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceStateGroupByOutputType>[]
        }
        count: {
          args: Prisma.InstanceStateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceStateCountAggregateOutputType> | number
        }
      }
    }
    UserProjectViewport: {
      payload: Prisma.$UserProjectViewportPayload<ExtArgs>
      fields: Prisma.UserProjectViewportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserProjectViewportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserProjectViewportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>
        }
        findFirst: {
          args: Prisma.UserProjectViewportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserProjectViewportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>
        }
        findMany: {
          args: Prisma.UserProjectViewportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>[]
        }
        create: {
          args: Prisma.UserProjectViewportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>
        }
        createMany: {
          args: Prisma.UserProjectViewportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserProjectViewportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>[]
        }
        delete: {
          args: Prisma.UserProjectViewportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>
        }
        update: {
          args: Prisma.UserProjectViewportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>
        }
        deleteMany: {
          args: Prisma.UserProjectViewportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserProjectViewportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserProjectViewportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>[]
        }
        upsert: {
          args: Prisma.UserProjectViewportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProjectViewportPayload>
        }
        aggregate: {
          args: Prisma.UserProjectViewportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserProjectViewport>
        }
        groupBy: {
          args: Prisma.UserProjectViewportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProjectViewportGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserProjectViewportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProjectViewportCountAggregateOutputType> | number
        }
      }
    }
    UserCompositeViewport: {
      payload: Prisma.$UserCompositeViewportPayload<ExtArgs>
      fields: Prisma.UserCompositeViewportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserCompositeViewportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserCompositeViewportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>
        }
        findFirst: {
          args: Prisma.UserCompositeViewportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserCompositeViewportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>
        }
        findMany: {
          args: Prisma.UserCompositeViewportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>[]
        }
        create: {
          args: Prisma.UserCompositeViewportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>
        }
        createMany: {
          args: Prisma.UserCompositeViewportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCompositeViewportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>[]
        }
        delete: {
          args: Prisma.UserCompositeViewportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>
        }
        update: {
          args: Prisma.UserCompositeViewportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>
        }
        deleteMany: {
          args: Prisma.UserCompositeViewportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserCompositeViewportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserCompositeViewportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>[]
        }
        upsert: {
          args: Prisma.UserCompositeViewportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCompositeViewportPayload>
        }
        aggregate: {
          args: Prisma.UserCompositeViewportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserCompositeViewport>
        }
        groupBy: {
          args: Prisma.UserCompositeViewportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCompositeViewportGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCompositeViewportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCompositeViewportCountAggregateOutputType> | number
        }
      }
    }
    InstanceLock: {
      payload: Prisma.$InstanceLockPayload<ExtArgs>
      fields: Prisma.InstanceLockFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InstanceLockFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InstanceLockFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>
        }
        findFirst: {
          args: Prisma.InstanceLockFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InstanceLockFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>
        }
        findMany: {
          args: Prisma.InstanceLockFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>[]
        }
        create: {
          args: Prisma.InstanceLockCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>
        }
        createMany: {
          args: Prisma.InstanceLockCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InstanceLockCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>[]
        }
        delete: {
          args: Prisma.InstanceLockDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>
        }
        update: {
          args: Prisma.InstanceLockUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>
        }
        deleteMany: {
          args: Prisma.InstanceLockDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InstanceLockUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InstanceLockUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>[]
        }
        upsert: {
          args: Prisma.InstanceLockUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceLockPayload>
        }
        aggregate: {
          args: Prisma.InstanceLockAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInstanceLock>
        }
        groupBy: {
          args: Prisma.InstanceLockGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceLockGroupByOutputType>[]
        }
        count: {
          args: Prisma.InstanceLockCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceLockCountAggregateOutputType> | number
        }
      }
    }
    InstanceModel: {
      payload: Prisma.$InstanceModelPayload<ExtArgs>
      fields: Prisma.InstanceModelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InstanceModelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InstanceModelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>
        }
        findFirst: {
          args: Prisma.InstanceModelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InstanceModelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>
        }
        findMany: {
          args: Prisma.InstanceModelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>[]
        }
        create: {
          args: Prisma.InstanceModelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>
        }
        createMany: {
          args: Prisma.InstanceModelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InstanceModelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>[]
        }
        delete: {
          args: Prisma.InstanceModelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>
        }
        update: {
          args: Prisma.InstanceModelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>
        }
        deleteMany: {
          args: Prisma.InstanceModelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InstanceModelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InstanceModelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>[]
        }
        upsert: {
          args: Prisma.InstanceModelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceModelPayload>
        }
        aggregate: {
          args: Prisma.InstanceModelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInstanceModel>
        }
        groupBy: {
          args: Prisma.InstanceModelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceModelGroupByOutputType>[]
        }
        count: {
          args: Prisma.InstanceModelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceModelCountAggregateOutputType> | number
        }
      }
    }
    HubModel: {
      payload: Prisma.$HubModelPayload<ExtArgs>
      fields: Prisma.HubModelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HubModelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HubModelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>
        }
        findFirst: {
          args: Prisma.HubModelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HubModelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>
        }
        findMany: {
          args: Prisma.HubModelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>[]
        }
        create: {
          args: Prisma.HubModelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>
        }
        createMany: {
          args: Prisma.HubModelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HubModelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>[]
        }
        delete: {
          args: Prisma.HubModelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>
        }
        update: {
          args: Prisma.HubModelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>
        }
        deleteMany: {
          args: Prisma.HubModelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HubModelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HubModelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>[]
        }
        upsert: {
          args: Prisma.HubModelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HubModelPayload>
        }
        aggregate: {
          args: Prisma.HubModelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHubModel>
        }
        groupBy: {
          args: Prisma.HubModelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HubModelGroupByOutputType>[]
        }
        count: {
          args: Prisma.HubModelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HubModelCountAggregateOutputType> | number
        }
      }
    }
    Operation: {
      payload: Prisma.$OperationPayload<ExtArgs>
      fields: Prisma.OperationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OperationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OperationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>
        }
        findFirst: {
          args: Prisma.OperationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OperationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>
        }
        findMany: {
          args: Prisma.OperationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>[]
        }
        create: {
          args: Prisma.OperationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>
        }
        createMany: {
          args: Prisma.OperationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OperationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>[]
        }
        delete: {
          args: Prisma.OperationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>
        }
        update: {
          args: Prisma.OperationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>
        }
        deleteMany: {
          args: Prisma.OperationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OperationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OperationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>[]
        }
        upsert: {
          args: Prisma.OperationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationPayload>
        }
        aggregate: {
          args: Prisma.OperationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOperation>
        }
        groupBy: {
          args: Prisma.OperationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OperationGroupByOutputType>[]
        }
        count: {
          args: Prisma.OperationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OperationCountAggregateOutputType> | number
        }
      }
    }
    InstanceOperationState: {
      payload: Prisma.$InstanceOperationStatePayload<ExtArgs>
      fields: Prisma.InstanceOperationStateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InstanceOperationStateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InstanceOperationStateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>
        }
        findFirst: {
          args: Prisma.InstanceOperationStateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InstanceOperationStateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>
        }
        findMany: {
          args: Prisma.InstanceOperationStateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>[]
        }
        create: {
          args: Prisma.InstanceOperationStateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>
        }
        createMany: {
          args: Prisma.InstanceOperationStateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InstanceOperationStateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>[]
        }
        delete: {
          args: Prisma.InstanceOperationStateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>
        }
        update: {
          args: Prisma.InstanceOperationStateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>
        }
        deleteMany: {
          args: Prisma.InstanceOperationStateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InstanceOperationStateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InstanceOperationStateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>[]
        }
        upsert: {
          args: Prisma.InstanceOperationStateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InstanceOperationStatePayload>
        }
        aggregate: {
          args: Prisma.InstanceOperationStateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInstanceOperationState>
        }
        groupBy: {
          args: Prisma.InstanceOperationStateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceOperationStateGroupByOutputType>[]
        }
        count: {
          args: Prisma.InstanceOperationStateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InstanceOperationStateCountAggregateOutputType> | number
        }
      }
    }
    OperationLog: {
      payload: Prisma.$OperationLogPayload<ExtArgs>
      fields: Prisma.OperationLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OperationLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OperationLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>
        }
        findFirst: {
          args: Prisma.OperationLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OperationLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>
        }
        findMany: {
          args: Prisma.OperationLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>[]
        }
        create: {
          args: Prisma.OperationLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>
        }
        createMany: {
          args: Prisma.OperationLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OperationLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>[]
        }
        delete: {
          args: Prisma.OperationLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>
        }
        update: {
          args: Prisma.OperationLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>
        }
        deleteMany: {
          args: Prisma.OperationLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OperationLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OperationLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>[]
        }
        upsert: {
          args: Prisma.OperationLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OperationLogPayload>
        }
        aggregate: {
          args: Prisma.OperationLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOperationLog>
        }
        groupBy: {
          args: Prisma.OperationLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OperationLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.OperationLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OperationLogCountAggregateOutputType> | number
        }
      }
    }
    Page: {
      payload: Prisma.$PagePayload<ExtArgs>
      fields: Prisma.PageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        findFirst: {
          args: Prisma.PageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        findMany: {
          args: Prisma.PageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>[]
        }
        create: {
          args: Prisma.PageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        createMany: {
          args: Prisma.PageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>[]
        }
        delete: {
          args: Prisma.PageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        update: {
          args: Prisma.PageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        deleteMany: {
          args: Prisma.PageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>[]
        }
        upsert: {
          args: Prisma.PageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PagePayload>
        }
        aggregate: {
          args: Prisma.PageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePage>
        }
        groupBy: {
          args: Prisma.PageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PageGroupByOutputType>[]
        }
        count: {
          args: Prisma.PageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PageCountAggregateOutputType> | number
        }
      }
    }
    Secret: {
      payload: Prisma.$SecretPayload<ExtArgs>
      fields: Prisma.SecretFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SecretFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SecretFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>
        }
        findFirst: {
          args: Prisma.SecretFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SecretFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>
        }
        findMany: {
          args: Prisma.SecretFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>[]
        }
        create: {
          args: Prisma.SecretCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>
        }
        createMany: {
          args: Prisma.SecretCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SecretCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>[]
        }
        delete: {
          args: Prisma.SecretDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>
        }
        update: {
          args: Prisma.SecretUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>
        }
        deleteMany: {
          args: Prisma.SecretDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SecretUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SecretUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>[]
        }
        upsert: {
          args: Prisma.SecretUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SecretPayload>
        }
        aggregate: {
          args: Prisma.SecretAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSecret>
        }
        groupBy: {
          args: Prisma.SecretGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SecretGroupByOutputType>[]
        }
        count: {
          args: Prisma.SecretCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SecretCountAggregateOutputType> | number
        }
      }
    }
    ServiceAccount: {
      payload: Prisma.$ServiceAccountPayload<ExtArgs>
      fields: Prisma.ServiceAccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceAccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceAccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>
        }
        findFirst: {
          args: Prisma.ServiceAccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceAccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>
        }
        findMany: {
          args: Prisma.ServiceAccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>[]
        }
        create: {
          args: Prisma.ServiceAccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>
        }
        createMany: {
          args: Prisma.ServiceAccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceAccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>[]
        }
        delete: {
          args: Prisma.ServiceAccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>
        }
        update: {
          args: Prisma.ServiceAccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>
        }
        deleteMany: {
          args: Prisma.ServiceAccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceAccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceAccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>[]
        }
        upsert: {
          args: Prisma.ServiceAccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAccountPayload>
        }
        aggregate: {
          args: Prisma.ServiceAccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServiceAccount>
        }
        groupBy: {
          args: Prisma.ServiceAccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceAccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceAccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceAccountCountAggregateOutputType> | number
        }
      }
    }
    Terminal: {
      payload: Prisma.$TerminalPayload<ExtArgs>
      fields: Prisma.TerminalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TerminalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TerminalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>
        }
        findFirst: {
          args: Prisma.TerminalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TerminalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>
        }
        findMany: {
          args: Prisma.TerminalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>[]
        }
        create: {
          args: Prisma.TerminalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>
        }
        createMany: {
          args: Prisma.TerminalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TerminalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>[]
        }
        delete: {
          args: Prisma.TerminalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>
        }
        update: {
          args: Prisma.TerminalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>
        }
        deleteMany: {
          args: Prisma.TerminalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TerminalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TerminalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>[]
        }
        upsert: {
          args: Prisma.TerminalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalPayload>
        }
        aggregate: {
          args: Prisma.TerminalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTerminal>
        }
        groupBy: {
          args: Prisma.TerminalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TerminalGroupByOutputType>[]
        }
        count: {
          args: Prisma.TerminalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TerminalCountAggregateOutputType> | number
        }
      }
    }
    TerminalSession: {
      payload: Prisma.$TerminalSessionPayload<ExtArgs>
      fields: Prisma.TerminalSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TerminalSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TerminalSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
        }
        findFirst: {
          args: Prisma.TerminalSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TerminalSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
        }
        findMany: {
          args: Prisma.TerminalSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>[]
        }
        create: {
          args: Prisma.TerminalSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
        }
        createMany: {
          args: Prisma.TerminalSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TerminalSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>[]
        }
        delete: {
          args: Prisma.TerminalSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
        }
        update: {
          args: Prisma.TerminalSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
        }
        deleteMany: {
          args: Prisma.TerminalSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TerminalSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TerminalSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>[]
        }
        upsert: {
          args: Prisma.TerminalSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
        }
        aggregate: {
          args: Prisma.TerminalSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTerminalSession>
        }
        groupBy: {
          args: Prisma.TerminalSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TerminalSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TerminalSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TerminalSessionCountAggregateOutputType> | number
        }
      }
    }
    TerminalSessionLog: {
      payload: Prisma.$TerminalSessionLogPayload<ExtArgs>
      fields: Prisma.TerminalSessionLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TerminalSessionLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TerminalSessionLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>
        }
        findFirst: {
          args: Prisma.TerminalSessionLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TerminalSessionLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>
        }
        findMany: {
          args: Prisma.TerminalSessionLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>[]
        }
        create: {
          args: Prisma.TerminalSessionLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>
        }
        createMany: {
          args: Prisma.TerminalSessionLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TerminalSessionLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>[]
        }
        delete: {
          args: Prisma.TerminalSessionLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>
        }
        update: {
          args: Prisma.TerminalSessionLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>
        }
        deleteMany: {
          args: Prisma.TerminalSessionLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TerminalSessionLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TerminalSessionLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>[]
        }
        upsert: {
          args: Prisma.TerminalSessionLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TerminalSessionLogPayload>
        }
        aggregate: {
          args: Prisma.TerminalSessionLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTerminalSessionLog>
        }
        groupBy: {
          args: Prisma.TerminalSessionLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TerminalSessionLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.TerminalSessionLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TerminalSessionLogCountAggregateOutputType> | number
        }
      }
    }
    Trigger: {
      payload: Prisma.$TriggerPayload<ExtArgs>
      fields: Prisma.TriggerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TriggerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TriggerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>
        }
        findFirst: {
          args: Prisma.TriggerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TriggerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>
        }
        findMany: {
          args: Prisma.TriggerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>[]
        }
        create: {
          args: Prisma.TriggerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>
        }
        createMany: {
          args: Prisma.TriggerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TriggerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>[]
        }
        delete: {
          args: Prisma.TriggerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>
        }
        update: {
          args: Prisma.TriggerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>
        }
        deleteMany: {
          args: Prisma.TriggerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TriggerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TriggerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>[]
        }
        upsert: {
          args: Prisma.TriggerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TriggerPayload>
        }
        aggregate: {
          args: Prisma.TriggerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrigger>
        }
        groupBy: {
          args: Prisma.TriggerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TriggerGroupByOutputType>[]
        }
        count: {
          args: Prisma.TriggerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TriggerCountAggregateOutputType> | number
        }
      }
    }
    UnlockMethod: {
      payload: Prisma.$UnlockMethodPayload<ExtArgs>
      fields: Prisma.UnlockMethodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UnlockMethodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UnlockMethodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>
        }
        findFirst: {
          args: Prisma.UnlockMethodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UnlockMethodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>
        }
        findMany: {
          args: Prisma.UnlockMethodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>[]
        }
        create: {
          args: Prisma.UnlockMethodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>
        }
        createMany: {
          args: Prisma.UnlockMethodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UnlockMethodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>[]
        }
        delete: {
          args: Prisma.UnlockMethodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>
        }
        update: {
          args: Prisma.UnlockMethodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>
        }
        deleteMany: {
          args: Prisma.UnlockMethodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UnlockMethodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UnlockMethodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>[]
        }
        upsert: {
          args: Prisma.UnlockMethodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnlockMethodPayload>
        }
        aggregate: {
          args: Prisma.UnlockMethodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUnlockMethod>
        }
        groupBy: {
          args: Prisma.UnlockMethodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnlockMethodGroupByOutputType>[]
        }
        count: {
          args: Prisma.UnlockMethodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnlockMethodCountAggregateOutputType> | number
        }
      }
    }
    Worker: {
      payload: Prisma.$WorkerPayload<ExtArgs>
      fields: Prisma.WorkerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>
        }
        findFirst: {
          args: Prisma.WorkerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>
        }
        findMany: {
          args: Prisma.WorkerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>[]
        }
        create: {
          args: Prisma.WorkerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>
        }
        createMany: {
          args: Prisma.WorkerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>[]
        }
        delete: {
          args: Prisma.WorkerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>
        }
        update: {
          args: Prisma.WorkerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>
        }
        deleteMany: {
          args: Prisma.WorkerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>[]
        }
        upsert: {
          args: Prisma.WorkerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerPayload>
        }
        aggregate: {
          args: Prisma.WorkerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorker>
        }
        groupBy: {
          args: Prisma.WorkerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkerGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkerCountAggregateOutputType> | number
        }
      }
    }
    WorkerVersion: {
      payload: Prisma.$WorkerVersionPayload<ExtArgs>
      fields: Prisma.WorkerVersionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkerVersionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkerVersionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>
        }
        findFirst: {
          args: Prisma.WorkerVersionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkerVersionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>
        }
        findMany: {
          args: Prisma.WorkerVersionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>[]
        }
        create: {
          args: Prisma.WorkerVersionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>
        }
        createMany: {
          args: Prisma.WorkerVersionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkerVersionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>[]
        }
        delete: {
          args: Prisma.WorkerVersionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>
        }
        update: {
          args: Prisma.WorkerVersionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>
        }
        deleteMany: {
          args: Prisma.WorkerVersionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkerVersionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkerVersionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>[]
        }
        upsert: {
          args: Prisma.WorkerVersionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionPayload>
        }
        aggregate: {
          args: Prisma.WorkerVersionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkerVersion>
        }
        groupBy: {
          args: Prisma.WorkerVersionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkerVersionGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkerVersionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkerVersionCountAggregateOutputType> | number
        }
      }
    }
    WorkerUnitRegistration: {
      payload: Prisma.$WorkerUnitRegistrationPayload<ExtArgs>
      fields: Prisma.WorkerUnitRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkerUnitRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkerUnitRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>
        }
        findFirst: {
          args: Prisma.WorkerUnitRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkerUnitRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>
        }
        findMany: {
          args: Prisma.WorkerUnitRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>[]
        }
        create: {
          args: Prisma.WorkerUnitRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>
        }
        createMany: {
          args: Prisma.WorkerUnitRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkerUnitRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>[]
        }
        delete: {
          args: Prisma.WorkerUnitRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>
        }
        update: {
          args: Prisma.WorkerUnitRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.WorkerUnitRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkerUnitRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkerUnitRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.WorkerUnitRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerUnitRegistrationPayload>
        }
        aggregate: {
          args: Prisma.WorkerUnitRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkerUnitRegistration>
        }
        groupBy: {
          args: Prisma.WorkerUnitRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkerUnitRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkerUnitRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkerUnitRegistrationCountAggregateOutputType> | number
        }
      }
    }
    WorkerVersionLog: {
      payload: Prisma.$WorkerVersionLogPayload<ExtArgs>
      fields: Prisma.WorkerVersionLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkerVersionLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkerVersionLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>
        }
        findFirst: {
          args: Prisma.WorkerVersionLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkerVersionLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>
        }
        findMany: {
          args: Prisma.WorkerVersionLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>[]
        }
        create: {
          args: Prisma.WorkerVersionLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>
        }
        createMany: {
          args: Prisma.WorkerVersionLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkerVersionLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>[]
        }
        delete: {
          args: Prisma.WorkerVersionLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>
        }
        update: {
          args: Prisma.WorkerVersionLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>
        }
        deleteMany: {
          args: Prisma.WorkerVersionLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkerVersionLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkerVersionLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>[]
        }
        upsert: {
          args: Prisma.WorkerVersionLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkerVersionLogPayload>
        }
        aggregate: {
          args: Prisma.WorkerVersionLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkerVersionLog>
        }
        groupBy: {
          args: Prisma.WorkerVersionLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkerVersionLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkerVersionLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkerVersionLogCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ApiKeyScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  serviceAccountId: 'serviceAccountId',
  token: 'token',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


export const ArtifactScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  hash: 'hash',
  size: 'size',
  chunkSize: 'chunkSize',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ArtifactScalarFieldEnum = (typeof ArtifactScalarFieldEnum)[keyof typeof ArtifactScalarFieldEnum]


export const InstanceCustomStatusScalarFieldEnum = {
  stateId: 'stateId',
  serviceAccountId: 'serviceAccountId',
  name: 'name',
  meta: 'meta',
  value: 'value',
  message: 'message',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InstanceCustomStatusScalarFieldEnum = (typeof InstanceCustomStatusScalarFieldEnum)[keyof typeof InstanceCustomStatusScalarFieldEnum]


export const InstanceEvaluationStateScalarFieldEnum = {
  stateId: 'stateId',
  status: 'status',
  message: 'message',
  model: 'model',
  evaluatedAt: 'evaluatedAt'
} as const

export type InstanceEvaluationStateScalarFieldEnum = (typeof InstanceEvaluationStateScalarFieldEnum)[keyof typeof InstanceEvaluationStateScalarFieldEnum]


export const InstanceStateScalarFieldEnum = {
  id: 'id',
  instanceId: 'instanceId',
  status: 'status',
  source: 'source',
  kind: 'kind',
  parentId: 'parentId',
  inputHashNonce: 'inputHashNonce',
  inputHash: 'inputHash',
  outputHash: 'outputHash',
  dependencyOutputHash: 'dependencyOutputHash',
  exportedArtifactIds: 'exportedArtifactIds',
  model: 'model',
  resolvedInputs: 'resolvedInputs',
  currentResourceCount: 'currentResourceCount',
  statusFields: 'statusFields'
} as const

export type InstanceStateScalarFieldEnum = (typeof InstanceStateScalarFieldEnum)[keyof typeof InstanceStateScalarFieldEnum]


export const UserProjectViewportScalarFieldEnum = {
  userId: 'userId',
  viewport: 'viewport'
} as const

export type UserProjectViewportScalarFieldEnum = (typeof UserProjectViewportScalarFieldEnum)[keyof typeof UserProjectViewportScalarFieldEnum]


export const UserCompositeViewportScalarFieldEnum = {
  userId: 'userId',
  stateId: 'stateId',
  viewport: 'viewport'
} as const

export type UserCompositeViewportScalarFieldEnum = (typeof UserCompositeViewportScalarFieldEnum)[keyof typeof UserCompositeViewportScalarFieldEnum]


export const InstanceLockScalarFieldEnum = {
  stateId: 'stateId',
  meta: 'meta',
  token: 'token',
  acquiredAt: 'acquiredAt'
} as const

export type InstanceLockScalarFieldEnum = (typeof InstanceLockScalarFieldEnum)[keyof typeof InstanceLockScalarFieldEnum]


export const InstanceModelScalarFieldEnum = {
  id: 'id',
  model: 'model',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InstanceModelScalarFieldEnum = (typeof InstanceModelScalarFieldEnum)[keyof typeof InstanceModelScalarFieldEnum]


export const HubModelScalarFieldEnum = {
  id: 'id',
  model: 'model',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type HubModelScalarFieldEnum = (typeof HubModelScalarFieldEnum)[keyof typeof HubModelScalarFieldEnum]


export const OperationScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  type: 'type',
  status: 'status',
  options: 'options',
  requestedInstanceIds: 'requestedInstanceIds',
  phases: 'phases',
  startedAt: 'startedAt',
  updatedAt: 'updatedAt',
  finishedAt: 'finishedAt'
} as const

export type OperationScalarFieldEnum = (typeof OperationScalarFieldEnum)[keyof typeof OperationScalarFieldEnum]


export const InstanceOperationStateScalarFieldEnum = {
  operationId: 'operationId',
  stateId: 'stateId',
  status: 'status',
  currentResourceCount: 'currentResourceCount',
  totalResourceCount: 'totalResourceCount',
  model: 'model',
  resolvedInputs: 'resolvedInputs',
  startedAt: 'startedAt',
  finishedAt: 'finishedAt'
} as const

export type InstanceOperationStateScalarFieldEnum = (typeof InstanceOperationStateScalarFieldEnum)[keyof typeof InstanceOperationStateScalarFieldEnum]


export const OperationLogScalarFieldEnum = {
  id: 'id',
  operationId: 'operationId',
  stateId: 'stateId',
  isSystem: 'isSystem',
  content: 'content'
} as const

export type OperationLogScalarFieldEnum = (typeof OperationLogScalarFieldEnum)[keyof typeof OperationLogScalarFieldEnum]


export const PageScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  stateId: 'stateId',
  name: 'name',
  serviceAccountId: 'serviceAccountId',
  content: 'content',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


export const SecretScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  stateId: 'stateId',
  name: 'name',
  systemName: 'systemName',
  serviceAccountId: 'serviceAccountId',
  content: 'content',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SecretScalarFieldEnum = (typeof SecretScalarFieldEnum)[keyof typeof SecretScalarFieldEnum]


export const ServiceAccountScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ServiceAccountScalarFieldEnum = (typeof ServiceAccountScalarFieldEnum)[keyof typeof ServiceAccountScalarFieldEnum]


export const TerminalScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  status: 'status',
  spec: 'spec',
  stateId: 'stateId',
  name: 'name',
  serviceAccountId: 'serviceAccountId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TerminalScalarFieldEnum = (typeof TerminalScalarFieldEnum)[keyof typeof TerminalScalarFieldEnum]


export const TerminalSessionScalarFieldEnum = {
  id: 'id',
  terminalId: 'terminalId',
  startedAt: 'startedAt',
  finishedAt: 'finishedAt'
} as const

export type TerminalSessionScalarFieldEnum = (typeof TerminalSessionScalarFieldEnum)[keyof typeof TerminalSessionScalarFieldEnum]


export const TerminalSessionLogScalarFieldEnum = {
  id: 'id',
  sessionId: 'sessionId',
  content: 'content'
} as const

export type TerminalSessionLogScalarFieldEnum = (typeof TerminalSessionLogScalarFieldEnum)[keyof typeof TerminalSessionLogScalarFieldEnum]


export const TriggerScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  stateId: 'stateId',
  name: 'name',
  spec: 'spec',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TriggerScalarFieldEnum = (typeof TriggerScalarFieldEnum)[keyof typeof TriggerScalarFieldEnum]


export const UnlockMethodScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  type: 'type',
  encryptedIdentity: 'encryptedIdentity',
  recipient: 'recipient',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UnlockMethodScalarFieldEnum = (typeof UnlockMethodScalarFieldEnum)[keyof typeof UnlockMethodScalarFieldEnum]


export const WorkerScalarFieldEnum = {
  id: 'id',
  identity: 'identity',
  serviceAccountId: 'serviceAccountId',
  createdAt: 'createdAt'
} as const

export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


export const WorkerVersionScalarFieldEnum = {
  id: 'id',
  meta: 'meta',
  status: 'status',
  enabled: 'enabled',
  runtimeId: 'runtimeId',
  workerId: 'workerId',
  digest: 'digest',
  apiKeyId: 'apiKeyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WorkerVersionScalarFieldEnum = (typeof WorkerVersionScalarFieldEnum)[keyof typeof WorkerVersionScalarFieldEnum]


export const WorkerUnitRegistrationScalarFieldEnum = {
  stateId: 'stateId',
  name: 'name',
  params: 'params',
  workerVersionId: 'workerVersionId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WorkerUnitRegistrationScalarFieldEnum = (typeof WorkerUnitRegistrationScalarFieldEnum)[keyof typeof WorkerUnitRegistrationScalarFieldEnum]


export const WorkerVersionLogScalarFieldEnum = {
  id: 'id',
  workerVersionId: 'workerVersionId',
  content: 'content',
  isSystem: 'isSystem'
} as const

export type WorkerVersionLogScalarFieldEnum = (typeof WorkerVersionLogScalarFieldEnum)[keyof typeof WorkerVersionLogScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'InstanceEvaluationStatus'
 */
export type EnumInstanceEvaluationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstanceEvaluationStatus'>
    


/**
 * Reference to a field of type 'InstanceStatus'
 */
export type EnumInstanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstanceStatus'>
    


/**
 * Reference to a field of type 'InstanceSource'
 */
export type EnumInstanceSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstanceSource'>
    


/**
 * Reference to a field of type 'OperationType'
 */
export type EnumOperationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperationType'>
    


/**
 * Reference to a field of type 'OperationStatus'
 */
export type EnumOperationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperationStatus'>
    


/**
 * Reference to a field of type 'InstanceOperationStatus'
 */
export type EnumInstanceOperationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstanceOperationStatus'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'TerminalStatus'
 */
export type EnumTerminalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerminalStatus'>
    


/**
 * Reference to a field of type 'UnlockMethodType'
 */
export type EnumUnlockMethodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnlockMethodType'>
    


/**
 * Reference to a field of type 'WorkerVersionStatus'
 */
export type EnumWorkerVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkerVersionStatus'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}


export type Datasource = {
  url?: string
}
export type Datasources = {
  db?: Datasource
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
   */
  adapter?: runtime.SqlDriverAdapterFactory | null
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  apiKey?: Prisma.ApiKeyOmit
  artifact?: Prisma.ArtifactOmit
  instanceCustomStatus?: Prisma.InstanceCustomStatusOmit
  instanceEvaluationState?: Prisma.InstanceEvaluationStateOmit
  instanceState?: Prisma.InstanceStateOmit
  userProjectViewport?: Prisma.UserProjectViewportOmit
  userCompositeViewport?: Prisma.UserCompositeViewportOmit
  instanceLock?: Prisma.InstanceLockOmit
  instanceModel?: Prisma.InstanceModelOmit
  hubModel?: Prisma.HubModelOmit
  operation?: Prisma.OperationOmit
  instanceOperationState?: Prisma.InstanceOperationStateOmit
  operationLog?: Prisma.OperationLogOmit
  page?: Prisma.PageOmit
  secret?: Prisma.SecretOmit
  serviceAccount?: Prisma.ServiceAccountOmit
  terminal?: Prisma.TerminalOmit
  terminalSession?: Prisma.TerminalSessionOmit
  terminalSessionLog?: Prisma.TerminalSessionLogOmit
  trigger?: Prisma.TriggerOmit
  unlockMethod?: Prisma.UnlockMethodOmit
  worker?: Prisma.WorkerOmit
  workerVersion?: Prisma.WorkerVersionOmit
  workerUnitRegistration?: Prisma.WorkerUnitRegistrationOmit
  workerVersionLog?: Prisma.WorkerVersionLogOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

