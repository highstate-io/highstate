// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace cilium {
    export namespace v2 {
        /**
         * CiliumClusterwideNetworkPolicy is a Kubernetes third-party resource with an
         * modified version of CiliumNetworkPolicy which is cluster scoped rather than
         * namespace scoped.
         */
        export interface CiliumClusterwideNetworkPolicy {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"cilium.io/v2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"CiliumClusterwideNetworkPolicy">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpec>;
            /**
             * Specs is a list of desired Cilium specific rule specification.
             */
            specs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecs>[]>;
            status?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicyStatus>;
        }

        /**
         * Spec is the desired Cilium specific rule specification.
         */
        export interface CiliumClusterwideNetworkPolicySpec {
            /**
             * Description is a free form string, it can be used by the creator of
             * the rule to store human readable explanation of the purpose of this
             * rule. Rules cannot be identified by comment.
             */
            description?: pulumi.Input<string>;
            /**
             * Egress is a list of EgressRule which are enforced at egress.
             * If omitted or empty, this rule does not apply at egress.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgress>[]>;
            /**
             * EgressDeny is a list of EgressDenyRule which are enforced at egress.
             * Any rule inserted here will be denied regardless of the allowed egress
             * rules in the 'egress' field.
             * If omitted or empty, this rule does not apply at egress.
             */
            egressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDeny>[]>;
            enableDefaultDeny?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEnableDefaultDeny>;
            endpointSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEndpointSelector>;
            /**
             * Ingress is a list of IngressRule which are enforced at ingress.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngress>[]>;
            /**
             * IngressDeny is a list of IngressDenyRule which are enforced at ingress.
             * Any rule inserted here will be denied regardless of the allowed ingress
             * rules in the 'ingress' field.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDeny>[]>;
            /**
             * Labels is a list of optional strings which can be used to
             * re-identify the rule or to store metadata. It is possible to lookup
             * or delete strings based on labels. Labels are not required to be
             * unique, multiple rules can have overlapping or identical labels.
             */
            labels?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecLabels>[]>;
            nodeSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecNodeSelector>;
        }

        /**
         * EgressRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgress {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressAuthentication>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressIcmps>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToCIDRSet>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToEndpoints>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
             * from DNS resolution of `ToFQDN.MatchName`s are added to the same
             * EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
             * L7 rules within this EgressRule will also apply to these IPs.
             * The DNS -> IP mapping is re-resolved periodically from within the
             * cilium-agent, and the IPs in the DNS response are effected in the policy
             * for selected pods as-is (i.e. the list of IPs is not modified in any way).
             * Note: An explicit rule to allow for DNS traffic is needed for the pods, as
             * ToFQDN counts as an egress rule and will enforce egress policy when
             * PolicyEnforcment=default.
             * Note: If the resolved IPs are IPs within the kubernetes cluster, the
             * ToFQDN rule will not apply to that IP.
             * Note: ToFQDN cannot occur in the same policy as other To* rules.
             */
            toFQDNs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToFQDNs>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToGroups>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToNodes>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * connect to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPorts>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToRequires>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServices>[]>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressAuthentication {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressAuthenticationPatch {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * EgressDenyRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDeny {
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is not allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyIcmps>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSet>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToGroups>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToNodes>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to connect
             * to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is not allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToPorts>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToRequires>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServices>[]>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsFieldsPatch>[]>;
        }

        /**
         * EgressDenyRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyPatch {
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is not allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyIcmpsPatch>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetPatch>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsPatch>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsPatch>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToNodesPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to connect
             * to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is not allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPatch>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresPatch>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesPatch>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToPorts {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPatch {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPortsPatch>[]>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServices {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sService>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelector>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sService {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServicePatch {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelector {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelector>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorPatch {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorPatch>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressDenyToServicesPatch {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServicePatch>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorPatch>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressIcmpsFieldsPatch>[]>;
        }

        /**
         * EgressRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressPatch {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressAuthenticationPatch>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressIcmpsPatch>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToCIDRSetPatch>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToEndpointsPatch>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
             * from DNS resolution of `ToFQDN.MatchName`s are added to the same
             * EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
             * L7 rules within this EgressRule will also apply to these IPs.
             * The DNS -> IP mapping is re-resolved periodically from within the
             * cilium-agent, and the IPs in the DNS response are effected in the policy
             * for selected pods as-is (i.e. the list of IPs is not modified in any way).
             * Note: An explicit rule to allow for DNS traffic is needed for the pods, as
             * ToFQDN counts as an egress rule and will enforce egress policy when
             * PolicyEnforcment=default.
             * Note: If the resolved IPs are IPs within the kubernetes cluster, the
             * ToFQDN rule will not apply to that IP.
             * Note: ToFQDN cannot occur in the same policy as other To* rules.
             */
            toFQDNs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToFQDNsPatch>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToGroupsPatch>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToNodesPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * connect to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsPatch>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToRequiresPatch>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesPatch>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface CiliumClusterwideNetworkPolicySpecEgressToFQDNs {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        export interface CiliumClusterwideNetworkPolicySpecEgressToFQDNsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPorts {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsListener>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTLS>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsPorts>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRules>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTLS>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsListener {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfig {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfigPatch {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsListenerPatch {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsListenerEnvoyConfigPatch>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsPatch {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsListenerPatch>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsOriginatingTLSPatch>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsPortsPatch>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesPatch>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTLSPatch>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRules {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDns {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDnsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttp {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesPatch {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecretPatch>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpPatch {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesPatch>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafka {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafkaPatch {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsRulesPatch {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesDnsPatch>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesHttpPatch>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsRulesKafkaPatch>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToPortsTerminatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServices {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesK8sService>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelector>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8sService {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServicePatch {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelector {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorSelector>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorPatch {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorPatch>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumClusterwideNetworkPolicySpecEgressToServicesPatch {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServicePatch>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressToServicesK8sServiceSelectorPatch>;
        }

        /**
         * EnableDefaultDeny determines whether this policy configures the
         * subject endpoint(s) to have a default deny mode. If enabled,
         * this causes all traffic not explicitly allowed by a network policy
         * to be dropped.
         *
         * If not specified, the default is true for each traffic direction
         * that has rules, and false otherwise. For example, if a policy
         * only has Ingress or IngressDeny rules, then the default for
         * ingress is true and egress is false.
         *
         * If multiple policies apply to an endpoint, that endpoint's default deny
         * will be enabled if any policy requests it.
         *
         * This is useful for creating broad-based network policies that will not
         * cause endpoints to enter default-deny mode.
         */
        export interface CiliumClusterwideNetworkPolicySpecEnableDefaultDeny {
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to egress traffic.
             */
            egress?: pulumi.Input<boolean>;
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to ingress traffic.
             */
            ingress?: pulumi.Input<boolean>;
        }

        /**
         * EnableDefaultDeny determines whether this policy configures the
         * subject endpoint(s) to have a default deny mode. If enabled,
         * this causes all traffic not explicitly allowed by a network policy
         * to be dropped.
         *
         * If not specified, the default is true for each traffic direction
         * that has rules, and false otherwise. For example, if a policy
         * only has Ingress or IngressDeny rules, then the default for
         * ingress is true and egress is false.
         *
         * If multiple policies apply to an endpoint, that endpoint's default deny
         * will be enabled if any policy requests it.
         *
         * This is useful for creating broad-based network policies that will not
         * cause endpoints to enter default-deny mode.
         */
        export interface CiliumClusterwideNetworkPolicySpecEnableDefaultDenyPatch {
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to egress traffic.
             */
            egress?: pulumi.Input<boolean>;
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to ingress traffic.
             */
            ingress?: pulumi.Input<boolean>;
        }

        /**
         * EndpointSelector selects all endpoints which should be subject to
         * this rule. EndpointSelector and NodeSelector cannot be both empty and
         * are mutually exclusive.
         */
        export interface CiliumClusterwideNetworkPolicySpecEndpointSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector selects all endpoints which should be subject to
         * this rule. EndpointSelector and NodeSelector cannot be both empty and
         * are mutually exclusive.
         */
        export interface CiliumClusterwideNetworkPolicySpecEndpointSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEndpointSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * IngressRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngress {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressAuthentication>;
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromCIDRSet>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromEndpoints>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromGroups>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromNodes>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromRequires>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressIcmps>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPorts>[]>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressAuthentication {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressAuthenticationPatch {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * IngressDenyRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDeny {
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSet>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromGroups>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromNodes>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyIcmps>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyToPorts>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsFieldsPatch>[]>;
        }

        /**
         * IngressDenyRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyPatch {
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromCIDRSetPatch>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromEndpointsPatch>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromGroupsPatch>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromNodesPatch>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyFromRequiresPatch>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyIcmpsPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPatch>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyToPorts {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPatch {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPortsPatch>[]>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressDenyToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressFromRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressIcmpsFieldsPatch>[]>;
        }

        /**
         * IngressRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressPatch {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressAuthenticationPatch>;
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromCIDRSetPatch>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromEndpointsPatch>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromGroupsPatch>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromNodesPatch>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressFromRequiresPatch>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressIcmpsPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsPatch>[]>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPorts {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsListener>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTLS>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsPorts>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRules>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTLS>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsListener {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfig {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfigPatch {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsListenerPatch {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsListenerEnvoyConfigPatch>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsPatch {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsListenerPatch>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsOriginatingTLSPatch>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsPortsPatch>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesPatch>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTLSPatch>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRules {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDns {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDnsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttp {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesPatch {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecretPatch>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpPatch {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesPatch>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafka {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafkaPatch {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsRulesPatch {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesDnsPatch>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesHttpPatch>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsRulesKafkaPatch>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecIngressToPortsTerminatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Label is the Cilium's representation of a container label.
         */
        export interface CiliumClusterwideNetworkPolicySpecLabels {
            key?: pulumi.Input<string>;
            /**
             * Source can be one of the above values (e.g.: LabelSourceContainer).
             */
            source?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        /**
         * Label is the Cilium's representation of a container label.
         */
        export interface CiliumClusterwideNetworkPolicySpecLabelsPatch {
            key?: pulumi.Input<string>;
            /**
             * Source can be one of the above values (e.g.: LabelSourceContainer).
             */
            source?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        /**
         * NodeSelector selects all nodes which should be subject to this rule.
         * EndpointSelector and NodeSelector cannot be both empty and are mutually
         * exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
         */
        export interface CiliumClusterwideNetworkPolicySpecNodeSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * NodeSelector selects all nodes which should be subject to this rule.
         * EndpointSelector and NodeSelector cannot be both empty and are mutually
         * exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
         */
        export interface CiliumClusterwideNetworkPolicySpecNodeSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecNodeSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Spec is the desired Cilium specific rule specification.
         */
        export interface CiliumClusterwideNetworkPolicySpecPatch {
            /**
             * Description is a free form string, it can be used by the creator of
             * the rule to store human readable explanation of the purpose of this
             * rule. Rules cannot be identified by comment.
             */
            description?: pulumi.Input<string>;
            /**
             * Egress is a list of EgressRule which are enforced at egress.
             * If omitted or empty, this rule does not apply at egress.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressPatch>[]>;
            /**
             * EgressDeny is a list of EgressDenyRule which are enforced at egress.
             * Any rule inserted here will be denied regardless of the allowed egress
             * rules in the 'egress' field.
             * If omitted or empty, this rule does not apply at egress.
             */
            egressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEgressDenyPatch>[]>;
            enableDefaultDeny?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEnableDefaultDenyPatch>;
            endpointSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecEndpointSelectorPatch>;
            /**
             * Ingress is a list of IngressRule which are enforced at ingress.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressPatch>[]>;
            /**
             * IngressDeny is a list of IngressDenyRule which are enforced at ingress.
             * Any rule inserted here will be denied regardless of the allowed ingress
             * rules in the 'ingress' field.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecIngressDenyPatch>[]>;
            /**
             * Labels is a list of optional strings which can be used to
             * re-identify the rule or to store metadata. It is possible to lookup
             * or delete strings based on labels. Labels are not required to be
             * unique, multiple rules can have overlapping or identical labels.
             */
            labels?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecLabelsPatch>[]>;
            nodeSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecNodeSelectorPatch>;
        }

        /**
         * Rule is a policy rule which must be applied to all endpoints which match the
         * labels contained in the endpointSelector
         *
         * Each rule is split into an ingress section which contains all rules
         * applicable at ingress, and an egress section applicable at egress. For rule
         * types such as `L4Rule` and `CIDR` which can be applied at both ingress and
         * egress, both ingress and egress side have to either specifically allow the
         * connection or one side has to be omitted.
         *
         * Either ingress, egress, or both can be provided. If both ingress and egress
         * are omitted, the rule has no effect.
         */
        export interface CiliumClusterwideNetworkPolicySpecs {
            /**
             * Description is a free form string, it can be used by the creator of
             * the rule to store human readable explanation of the purpose of this
             * rule. Rules cannot be identified by comment.
             */
            description?: pulumi.Input<string>;
            /**
             * Egress is a list of EgressRule which are enforced at egress.
             * If omitted or empty, this rule does not apply at egress.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgress>[]>;
            /**
             * EgressDeny is a list of EgressDenyRule which are enforced at egress.
             * Any rule inserted here will be denied regardless of the allowed egress
             * rules in the 'egress' field.
             * If omitted or empty, this rule does not apply at egress.
             */
            egressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDeny>[]>;
            enableDefaultDeny?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEnableDefaultDeny>;
            endpointSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEndpointSelector>;
            /**
             * Ingress is a list of IngressRule which are enforced at ingress.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngress>[]>;
            /**
             * IngressDeny is a list of IngressDenyRule which are enforced at ingress.
             * Any rule inserted here will be denied regardless of the allowed ingress
             * rules in the 'ingress' field.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDeny>[]>;
            /**
             * Labels is a list of optional strings which can be used to
             * re-identify the rule or to store metadata. It is possible to lookup
             * or delete strings based on labels. Labels are not required to be
             * unique, multiple rules can have overlapping or identical labels.
             */
            labels?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsLabels>[]>;
            nodeSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsNodeSelector>;
        }

        /**
         * EgressRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgress {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressAuthentication>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressIcmps>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToCIDRSet>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToEndpoints>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
             * from DNS resolution of `ToFQDN.MatchName`s are added to the same
             * EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
             * L7 rules within this EgressRule will also apply to these IPs.
             * The DNS -> IP mapping is re-resolved periodically from within the
             * cilium-agent, and the IPs in the DNS response are effected in the policy
             * for selected pods as-is (i.e. the list of IPs is not modified in any way).
             * Note: An explicit rule to allow for DNS traffic is needed for the pods, as
             * ToFQDN counts as an egress rule and will enforce egress policy when
             * PolicyEnforcment=default.
             * Note: If the resolved IPs are IPs within the kubernetes cluster, the
             * ToFQDN rule will not apply to that IP.
             * Note: ToFQDN cannot occur in the same policy as other To* rules.
             */
            toFQDNs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToFQDNs>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToGroups>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToNodes>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * connect to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPorts>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToRequires>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServices>[]>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressAuthentication {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressAuthenticationPatch {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * EgressDenyRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDeny {
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is not allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSet>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToNodes>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to connect
             * to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is not allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServices>[]>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsFieldsPatch>[]>;
        }

        /**
         * EgressDenyRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyPatch {
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is not allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyIcmpsPatch>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetPatch>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsPatch>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsPatch>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToNodesPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to connect
             * to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is not allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPatch>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresPatch>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesPatch>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToPorts {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPatch {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPortsPatch>[]>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServices {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sService>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelector>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sService {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServicePatch {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelector {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelector>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorPatch {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorPatch>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesPatch {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServicePatch>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorPatch>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressIcmpsFieldsPatch>[]>;
        }

        /**
         * EgressRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressPatch {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressAuthenticationPatch>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressIcmpsPatch>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetPatch>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToEndpointsPatch>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
             * from DNS resolution of `ToFQDN.MatchName`s are added to the same
             * EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
             * L7 rules within this EgressRule will also apply to these IPs.
             * The DNS -> IP mapping is re-resolved periodically from within the
             * cilium-agent, and the IPs in the DNS response are effected in the policy
             * for selected pods as-is (i.e. the list of IPs is not modified in any way).
             * Note: An explicit rule to allow for DNS traffic is needed for the pods, as
             * ToFQDN counts as an egress rule and will enforce egress policy when
             * PolicyEnforcment=default.
             * Note: If the resolved IPs are IPs within the kubernetes cluster, the
             * ToFQDN rule will not apply to that IP.
             * Note: ToFQDN cannot occur in the same policy as other To* rules.
             */
            toFQDNs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToFQDNsPatch>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToGroupsPatch>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToNodesPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * connect to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsPatch>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToRequiresPatch>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesPatch>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface CiliumClusterwideNetworkPolicySpecsEgressToFQDNs {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        export interface CiliumClusterwideNetworkPolicySpecsEgressToFQDNsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPorts {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsListener>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTLS>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRules>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTLS>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsListener {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfig {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfigPatch {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerPatch {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerEnvoyConfigPatch>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsPatch {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsListenerPatch>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsOriginatingTLSPatch>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsPortsPatch>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesPatch>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTLSPatch>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRules {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDns {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDnsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttp {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesPatch {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecretPatch>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpPatch {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesPatch>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafka {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafkaPatch {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesPatch {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesDnsPatch>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesHttpPatch>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsRulesKafkaPatch>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToPortsTerminatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServices {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sService>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelector>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sService {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServicePatch {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelector {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelector>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorPatch {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorPatch>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEgressToServicesPatch {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServicePatch>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressToServicesK8sServiceSelectorPatch>;
        }

        /**
         * EnableDefaultDeny determines whether this policy configures the
         * subject endpoint(s) to have a default deny mode. If enabled,
         * this causes all traffic not explicitly allowed by a network policy
         * to be dropped.
         *
         * If not specified, the default is true for each traffic direction
         * that has rules, and false otherwise. For example, if a policy
         * only has Ingress or IngressDeny rules, then the default for
         * ingress is true and egress is false.
         *
         * If multiple policies apply to an endpoint, that endpoint's default deny
         * will be enabled if any policy requests it.
         *
         * This is useful for creating broad-based network policies that will not
         * cause endpoints to enter default-deny mode.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEnableDefaultDeny {
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to egress traffic.
             */
            egress?: pulumi.Input<boolean>;
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to ingress traffic.
             */
            ingress?: pulumi.Input<boolean>;
        }

        /**
         * EnableDefaultDeny determines whether this policy configures the
         * subject endpoint(s) to have a default deny mode. If enabled,
         * this causes all traffic not explicitly allowed by a network policy
         * to be dropped.
         *
         * If not specified, the default is true for each traffic direction
         * that has rules, and false otherwise. For example, if a policy
         * only has Ingress or IngressDeny rules, then the default for
         * ingress is true and egress is false.
         *
         * If multiple policies apply to an endpoint, that endpoint's default deny
         * will be enabled if any policy requests it.
         *
         * This is useful for creating broad-based network policies that will not
         * cause endpoints to enter default-deny mode.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEnableDefaultDenyPatch {
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to egress traffic.
             */
            egress?: pulumi.Input<boolean>;
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to ingress traffic.
             */
            ingress?: pulumi.Input<boolean>;
        }

        /**
         * EndpointSelector selects all endpoints which should be subject to
         * this rule. EndpointSelector and NodeSelector cannot be both empty and
         * are mutually exclusive.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEndpointSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector selects all endpoints which should be subject to
         * this rule. EndpointSelector and NodeSelector cannot be both empty and
         * are mutually exclusive.
         */
        export interface CiliumClusterwideNetworkPolicySpecsEndpointSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEndpointSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * IngressRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngress {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressAuthentication>;
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSet>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromGroups>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromNodes>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromRequires>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressIcmps>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPorts>[]>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressAuthentication {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressAuthenticationPatch {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * IngressDenyRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDeny {
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSet>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromGroups>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromNodes>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsFieldsPatch>[]>;
        }

        /**
         * IngressDenyRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyPatch {
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromCIDRSetPatch>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromEndpointsPatch>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromGroupsPatch>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromNodesPatch>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyFromRequiresPatch>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyIcmpsPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPatch>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyToPorts {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPatch {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPortsPatch>[]>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressDenyToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressFromRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressIcmpsFieldsPatch>[]>;
        }

        /**
         * IngressRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressPatch {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressAuthenticationPatch>;
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromCIDRSetPatch>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromEndpointsPatch>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromGroupsPatch>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromNodesPatch>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressFromRequiresPatch>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressIcmpsPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsPatch>[]>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPorts {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsListener>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTLS>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRules>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTLS>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsListener {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfig {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfigPatch {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerPatch {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerEnvoyConfigPatch>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsPatch {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsListenerPatch>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsOriginatingTLSPatch>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsPortsPatch>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesPatch>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTLSPatch>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRules {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDns {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDnsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttp {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesPatch {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecretPatch>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpPatch {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesPatch>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafka {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafkaPatch {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesPatch {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesDnsPatch>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesHttpPatch>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsRulesKafkaPatch>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumClusterwideNetworkPolicySpecsIngressToPortsTerminatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Label is the Cilium's representation of a container label.
         */
        export interface CiliumClusterwideNetworkPolicySpecsLabels {
            key?: pulumi.Input<string>;
            /**
             * Source can be one of the above values (e.g.: LabelSourceContainer).
             */
            source?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        /**
         * Label is the Cilium's representation of a container label.
         */
        export interface CiliumClusterwideNetworkPolicySpecsLabelsPatch {
            key?: pulumi.Input<string>;
            /**
             * Source can be one of the above values (e.g.: LabelSourceContainer).
             */
            source?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        /**
         * NodeSelector selects all nodes which should be subject to this rule.
         * EndpointSelector and NodeSelector cannot be both empty and are mutually
         * exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
         */
        export interface CiliumClusterwideNetworkPolicySpecsNodeSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * NodeSelector selects all nodes which should be subject to this rule.
         * EndpointSelector and NodeSelector cannot be both empty and are mutually
         * exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
         */
        export interface CiliumClusterwideNetworkPolicySpecsNodeSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsNodeSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Rule is a policy rule which must be applied to all endpoints which match the
         * labels contained in the endpointSelector
         *
         * Each rule is split into an ingress section which contains all rules
         * applicable at ingress, and an egress section applicable at egress. For rule
         * types such as `L4Rule` and `CIDR` which can be applied at both ingress and
         * egress, both ingress and egress side have to either specifically allow the
         * connection or one side has to be omitted.
         *
         * Either ingress, egress, or both can be provided. If both ingress and egress
         * are omitted, the rule has no effect.
         */
        export interface CiliumClusterwideNetworkPolicySpecsPatch {
            /**
             * Description is a free form string, it can be used by the creator of
             * the rule to store human readable explanation of the purpose of this
             * rule. Rules cannot be identified by comment.
             */
            description?: pulumi.Input<string>;
            /**
             * Egress is a list of EgressRule which are enforced at egress.
             * If omitted or empty, this rule does not apply at egress.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressPatch>[]>;
            /**
             * EgressDeny is a list of EgressDenyRule which are enforced at egress.
             * Any rule inserted here will be denied regardless of the allowed egress
             * rules in the 'egress' field.
             * If omitted or empty, this rule does not apply at egress.
             */
            egressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEgressDenyPatch>[]>;
            enableDefaultDeny?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEnableDefaultDenyPatch>;
            endpointSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsEndpointSelectorPatch>;
            /**
             * Ingress is a list of IngressRule which are enforced at ingress.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressPatch>[]>;
            /**
             * IngressDeny is a list of IngressDenyRule which are enforced at ingress.
             * Any rule inserted here will be denied regardless of the allowed ingress
             * rules in the 'ingress' field.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsIngressDenyPatch>[]>;
            /**
             * Labels is a list of optional strings which can be used to
             * re-identify the rule or to store metadata. It is possible to lookup
             * or delete strings based on labels. Labels are not required to be
             * unique, multiple rules can have overlapping or identical labels.
             */
            labels?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsLabelsPatch>[]>;
            nodeSelector?: pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicySpecsNodeSelectorPatch>;
        }

        /**
         * Status is the status of the Cilium policy rule.
         *
         * The reason this field exists in this structure is due a bug in the k8s
         * code-generator that doesn't create a `UpdateStatus` method because the
         * field does not exist in the structure.
         */
        export interface CiliumClusterwideNetworkPolicyStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumClusterwideNetworkPolicyStatusConditions>[]>;
            /**
             * DerivativePolicies is the status of all policies derived from the Cilium
             * policy
             */
            derivativePolicies?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
        }

        export interface CiliumClusterwideNetworkPolicyStatusConditions {
            /**
             * The last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, one of True, False, or Unknown
             */
            status?: pulumi.Input<string>;
            /**
             * The type of the policy condition
             */
            type?: pulumi.Input<string>;
        }

        /**
         * CiliumNetworkPolicy is a Kubernetes third-party resource with an extended
         * version of NetworkPolicy.
         */
        export interface CiliumNetworkPolicy {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"cilium.io/v2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"CiliumNetworkPolicy">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpec>;
            /**
             * Specs is a list of desired Cilium specific rule specification.
             */
            specs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecs>[]>;
            status?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicyStatus>;
        }

        /**
         * Spec is the desired Cilium specific rule specification.
         */
        export interface CiliumNetworkPolicySpec {
            /**
             * Description is a free form string, it can be used by the creator of
             * the rule to store human readable explanation of the purpose of this
             * rule. Rules cannot be identified by comment.
             */
            description?: pulumi.Input<string>;
            /**
             * Egress is a list of EgressRule which are enforced at egress.
             * If omitted or empty, this rule does not apply at egress.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgress>[]>;
            /**
             * EgressDeny is a list of EgressDenyRule which are enforced at egress.
             * Any rule inserted here will be denied regardless of the allowed egress
             * rules in the 'egress' field.
             * If omitted or empty, this rule does not apply at egress.
             */
            egressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDeny>[]>;
            enableDefaultDeny?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEnableDefaultDeny>;
            endpointSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEndpointSelector>;
            /**
             * Ingress is a list of IngressRule which are enforced at ingress.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngress>[]>;
            /**
             * IngressDeny is a list of IngressDenyRule which are enforced at ingress.
             * Any rule inserted here will be denied regardless of the allowed ingress
             * rules in the 'ingress' field.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDeny>[]>;
            /**
             * Labels is a list of optional strings which can be used to
             * re-identify the rule or to store metadata. It is possible to lookup
             * or delete strings based on labels. Labels are not required to be
             * unique, multiple rules can have overlapping or identical labels.
             */
            labels?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecLabels>[]>;
            nodeSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecNodeSelector>;
        }

        /**
         * EgressRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumNetworkPolicySpecEgress {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressAuthentication>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressIcmps>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToCIDRSet>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToEndpoints>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
             * from DNS resolution of `ToFQDN.MatchName`s are added to the same
             * EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
             * L7 rules within this EgressRule will also apply to these IPs.
             * The DNS -> IP mapping is re-resolved periodically from within the
             * cilium-agent, and the IPs in the DNS response are effected in the policy
             * for selected pods as-is (i.e. the list of IPs is not modified in any way).
             * Note: An explicit rule to allow for DNS traffic is needed for the pods, as
             * ToFQDN counts as an egress rule and will enforce egress policy when
             * PolicyEnforcment=default.
             * Note: If the resolved IPs are IPs within the kubernetes cluster, the
             * ToFQDN rule will not apply to that IP.
             * Note: ToFQDN cannot occur in the same policy as other To* rules.
             */
            toFQDNs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToFQDNs>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToGroups>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToNodes>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * connect to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPorts>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToRequires>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServices>[]>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumNetworkPolicySpecEgressAuthentication {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumNetworkPolicySpecEgressAuthenticationPatch {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * EgressDenyRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumNetworkPolicySpecEgressDeny {
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is not allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyIcmps>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToCIDRSet>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToEndpoints>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToGroups>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToNodes>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to connect
             * to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is not allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToPorts>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToRequires>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServices>[]>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecEgressDenyIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecEgressDenyIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecEgressDenyIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecEgressDenyIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyIcmpsFieldsPatch>[]>;
        }

        /**
         * EgressDenyRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumNetworkPolicySpecEgressDenyPatch {
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is not allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyIcmpsPatch>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToCIDRSetPatch>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToEndpointsPatch>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToGroupsPatch>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToNodesPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to connect
             * to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is not allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToPortsPatch>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToRequiresPatch>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesPatch>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecEgressDenyToGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecEgressDenyToGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToPorts {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToPortsPorts>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToPortsPatch {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToPortsPortsPatch>[]>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecEgressDenyToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecEgressDenyToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServices {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesK8sService>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelector>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesK8sService {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesK8sServicePatch {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelector {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelector>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorPatch {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorPatch>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumNetworkPolicySpecEgressDenyToServicesPatch {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesK8sServicePatch>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyToServicesK8sServiceSelectorPatch>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecEgressIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecEgressIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecEgressIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecEgressIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressIcmpsFieldsPatch>[]>;
        }

        /**
         * EgressRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumNetworkPolicySpecEgressPatch {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressAuthenticationPatch>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressIcmpsPatch>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToCIDRSetPatch>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToEndpointsPatch>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
             * from DNS resolution of `ToFQDN.MatchName`s are added to the same
             * EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
             * L7 rules within this EgressRule will also apply to these IPs.
             * The DNS -> IP mapping is re-resolved periodically from within the
             * cilium-agent, and the IPs in the DNS response are effected in the policy
             * for selected pods as-is (i.e. the list of IPs is not modified in any way).
             * Note: An explicit rule to allow for DNS traffic is needed for the pods, as
             * ToFQDN counts as an egress rule and will enforce egress policy when
             * PolicyEnforcment=default.
             * Note: If the resolved IPs are IPs within the kubernetes cluster, the
             * ToFQDN rule will not apply to that IP.
             * Note: ToFQDN cannot occur in the same policy as other To* rules.
             */
            toFQDNs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToFQDNsPatch>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToGroupsPatch>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToNodesPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * connect to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsPatch>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToRequiresPatch>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesPatch>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecEgressToCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecEgressToCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecEgressToCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressToEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressToEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface CiliumNetworkPolicySpecEgressToFQDNs {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        export interface CiliumNetworkPolicySpecEgressToFQDNsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecEgressToGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecEgressToGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecEgressToGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecEgressToGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressToNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressToNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumNetworkPolicySpecEgressToPorts {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsListener>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsOriginatingTLS>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsPorts>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRules>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsTerminatingTLS>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsListener {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfig {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfigPatch {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsListenerPatch {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsListenerEnvoyConfigPatch>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsOriginatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsOriginatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsOriginatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsOriginatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsOriginatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsOriginatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsPatch {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsListenerPatch>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsOriginatingTLSPatch>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsPortsPatch>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesPatch>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsTerminatingTLSPatch>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecEgressToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecEgressToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRules {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesDns>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesHttp>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesKafka>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesDns {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesDnsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesHttp {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatches {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesPatch {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecretPatch>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesHttpPatch {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesHttpHeaderMatchesPatch>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesKafka {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesKafkaPatch {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsRulesPatch {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesDnsPatch>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesHttpPatch>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsRulesKafkaPatch>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsTerminatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsTerminatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsTerminatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToPortsTerminatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsTerminatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecEgressToPortsTerminatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressToRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecEgressToRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumNetworkPolicySpecEgressToServices {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesK8sService>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesK8sServiceSelector>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumNetworkPolicySpecEgressToServicesK8sService {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumNetworkPolicySpecEgressToServicesK8sServicePatch {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumNetworkPolicySpecEgressToServicesK8sServiceSelector {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorSelector>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorPatch {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorPatch>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumNetworkPolicySpecEgressToServicesPatch {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesK8sServicePatch>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressToServicesK8sServiceSelectorPatch>;
        }

        /**
         * EnableDefaultDeny determines whether this policy configures the
         * subject endpoint(s) to have a default deny mode. If enabled,
         * this causes all traffic not explicitly allowed by a network policy
         * to be dropped.
         *
         * If not specified, the default is true for each traffic direction
         * that has rules, and false otherwise. For example, if a policy
         * only has Ingress or IngressDeny rules, then the default for
         * ingress is true and egress is false.
         *
         * If multiple policies apply to an endpoint, that endpoint's default deny
         * will be enabled if any policy requests it.
         *
         * This is useful for creating broad-based network policies that will not
         * cause endpoints to enter default-deny mode.
         */
        export interface CiliumNetworkPolicySpecEnableDefaultDeny {
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to egress traffic.
             */
            egress?: pulumi.Input<boolean>;
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to ingress traffic.
             */
            ingress?: pulumi.Input<boolean>;
        }

        /**
         * EnableDefaultDeny determines whether this policy configures the
         * subject endpoint(s) to have a default deny mode. If enabled,
         * this causes all traffic not explicitly allowed by a network policy
         * to be dropped.
         *
         * If not specified, the default is true for each traffic direction
         * that has rules, and false otherwise. For example, if a policy
         * only has Ingress or IngressDeny rules, then the default for
         * ingress is true and egress is false.
         *
         * If multiple policies apply to an endpoint, that endpoint's default deny
         * will be enabled if any policy requests it.
         *
         * This is useful for creating broad-based network policies that will not
         * cause endpoints to enter default-deny mode.
         */
        export interface CiliumNetworkPolicySpecEnableDefaultDenyPatch {
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to egress traffic.
             */
            egress?: pulumi.Input<boolean>;
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to ingress traffic.
             */
            ingress?: pulumi.Input<boolean>;
        }

        /**
         * EndpointSelector selects all endpoints which should be subject to
         * this rule. EndpointSelector and NodeSelector cannot be both empty and
         * are mutually exclusive.
         */
        export interface CiliumNetworkPolicySpecEndpointSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEndpointSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEndpointSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecEndpointSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector selects all endpoints which should be subject to
         * this rule. EndpointSelector and NodeSelector cannot be both empty and
         * are mutually exclusive.
         */
        export interface CiliumNetworkPolicySpecEndpointSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEndpointSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * IngressRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumNetworkPolicySpecIngress {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressAuthentication>;
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromCIDRSet>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromEndpoints>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromGroups>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromNodes>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromRequires>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressIcmps>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPorts>[]>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumNetworkPolicySpecIngressAuthentication {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumNetworkPolicySpecIngressAuthenticationPatch {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * IngressDenyRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumNetworkPolicySpecIngressDeny {
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromCIDRSet>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromEndpoints>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromGroups>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromNodes>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromRequires>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyIcmps>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyToPorts>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressDenyFromRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecIngressDenyIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecIngressDenyIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecIngressDenyIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecIngressDenyIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyIcmpsFieldsPatch>[]>;
        }

        /**
         * IngressDenyRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumNetworkPolicySpecIngressDenyPatch {
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromCIDRSetPatch>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromEndpointsPatch>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromGroupsPatch>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromNodesPatch>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyFromRequiresPatch>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyIcmpsPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyToPortsPatch>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumNetworkPolicySpecIngressDenyToPorts {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyToPortsPorts>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumNetworkPolicySpecIngressDenyToPortsPatch {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyToPortsPortsPatch>[]>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecIngressDenyToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecIngressDenyToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecIngressFromCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecIngressFromCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecIngressFromCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressFromEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressFromEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecIngressFromGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecIngressFromGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecIngressFromGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecIngressFromGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressFromNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressFromNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressFromNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressFromNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressFromRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressFromRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecIngressFromRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecIngressFromRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecIngressIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecIngressIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecIngressIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecIngressIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressIcmpsFieldsPatch>[]>;
        }

        /**
         * IngressRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumNetworkPolicySpecIngressPatch {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressAuthenticationPatch>;
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromCIDRSetPatch>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromEndpointsPatch>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromGroupsPatch>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromNodesPatch>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressFromRequiresPatch>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressIcmpsPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsPatch>[]>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumNetworkPolicySpecIngressToPorts {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsListener>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsOriginatingTLS>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsPorts>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRules>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsTerminatingTLS>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsListener {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfig {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfigPatch {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsListenerPatch {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsListenerEnvoyConfigPatch>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsOriginatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsOriginatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsOriginatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsOriginatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsOriginatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsOriginatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsPatch {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsListenerPatch>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsOriginatingTLSPatch>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsPortsPatch>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesPatch>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsTerminatingTLSPatch>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecIngressToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecIngressToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRules {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesDns>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesHttp>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesKafka>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesDns {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesDnsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesHttp {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatches {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesPatch {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecretPatch>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesHttpPatch {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesHttpHeaderMatchesPatch>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesKafka {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesKafkaPatch {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsRulesPatch {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesDnsPatch>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesHttpPatch>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsRulesKafkaPatch>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsTerminatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsTerminatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsTerminatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressToPortsTerminatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsTerminatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecIngressToPortsTerminatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Label is the Cilium's representation of a container label.
         */
        export interface CiliumNetworkPolicySpecLabels {
            key?: pulumi.Input<string>;
            /**
             * Source can be one of the above values (e.g.: LabelSourceContainer).
             */
            source?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        /**
         * Label is the Cilium's representation of a container label.
         */
        export interface CiliumNetworkPolicySpecLabelsPatch {
            key?: pulumi.Input<string>;
            /**
             * Source can be one of the above values (e.g.: LabelSourceContainer).
             */
            source?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        /**
         * NodeSelector selects all nodes which should be subject to this rule.
         * EndpointSelector and NodeSelector cannot be both empty and are mutually
         * exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
         */
        export interface CiliumNetworkPolicySpecNodeSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecNodeSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecNodeSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecNodeSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * NodeSelector selects all nodes which should be subject to this rule.
         * EndpointSelector and NodeSelector cannot be both empty and are mutually
         * exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
         */
        export interface CiliumNetworkPolicySpecNodeSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecNodeSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Spec is the desired Cilium specific rule specification.
         */
        export interface CiliumNetworkPolicySpecPatch {
            /**
             * Description is a free form string, it can be used by the creator of
             * the rule to store human readable explanation of the purpose of this
             * rule. Rules cannot be identified by comment.
             */
            description?: pulumi.Input<string>;
            /**
             * Egress is a list of EgressRule which are enforced at egress.
             * If omitted or empty, this rule does not apply at egress.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressPatch>[]>;
            /**
             * EgressDeny is a list of EgressDenyRule which are enforced at egress.
             * Any rule inserted here will be denied regardless of the allowed egress
             * rules in the 'egress' field.
             * If omitted or empty, this rule does not apply at egress.
             */
            egressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEgressDenyPatch>[]>;
            enableDefaultDeny?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEnableDefaultDenyPatch>;
            endpointSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecEndpointSelectorPatch>;
            /**
             * Ingress is a list of IngressRule which are enforced at ingress.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressPatch>[]>;
            /**
             * IngressDeny is a list of IngressDenyRule which are enforced at ingress.
             * Any rule inserted here will be denied regardless of the allowed ingress
             * rules in the 'ingress' field.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecIngressDenyPatch>[]>;
            /**
             * Labels is a list of optional strings which can be used to
             * re-identify the rule or to store metadata. It is possible to lookup
             * or delete strings based on labels. Labels are not required to be
             * unique, multiple rules can have overlapping or identical labels.
             */
            labels?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecLabelsPatch>[]>;
            nodeSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecNodeSelectorPatch>;
        }

        /**
         * Rule is a policy rule which must be applied to all endpoints which match the
         * labels contained in the endpointSelector
         *
         * Each rule is split into an ingress section which contains all rules
         * applicable at ingress, and an egress section applicable at egress. For rule
         * types such as `L4Rule` and `CIDR` which can be applied at both ingress and
         * egress, both ingress and egress side have to either specifically allow the
         * connection or one side has to be omitted.
         *
         * Either ingress, egress, or both can be provided. If both ingress and egress
         * are omitted, the rule has no effect.
         */
        export interface CiliumNetworkPolicySpecs {
            /**
             * Description is a free form string, it can be used by the creator of
             * the rule to store human readable explanation of the purpose of this
             * rule. Rules cannot be identified by comment.
             */
            description?: pulumi.Input<string>;
            /**
             * Egress is a list of EgressRule which are enforced at egress.
             * If omitted or empty, this rule does not apply at egress.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgress>[]>;
            /**
             * EgressDeny is a list of EgressDenyRule which are enforced at egress.
             * Any rule inserted here will be denied regardless of the allowed egress
             * rules in the 'egress' field.
             * If omitted or empty, this rule does not apply at egress.
             */
            egressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDeny>[]>;
            enableDefaultDeny?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEnableDefaultDeny>;
            endpointSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEndpointSelector>;
            /**
             * Ingress is a list of IngressRule which are enforced at ingress.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngress>[]>;
            /**
             * IngressDeny is a list of IngressDenyRule which are enforced at ingress.
             * Any rule inserted here will be denied regardless of the allowed ingress
             * rules in the 'ingress' field.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDeny>[]>;
            /**
             * Labels is a list of optional strings which can be used to
             * re-identify the rule or to store metadata. It is possible to lookup
             * or delete strings based on labels. Labels are not required to be
             * unique, multiple rules can have overlapping or identical labels.
             */
            labels?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsLabels>[]>;
            nodeSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsNodeSelector>;
        }

        /**
         * EgressRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumNetworkPolicySpecsEgress {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressAuthentication>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressIcmps>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToCIDRSet>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToEndpoints>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
             * from DNS resolution of `ToFQDN.MatchName`s are added to the same
             * EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
             * L7 rules within this EgressRule will also apply to these IPs.
             * The DNS -> IP mapping is re-resolved periodically from within the
             * cilium-agent, and the IPs in the DNS response are effected in the policy
             * for selected pods as-is (i.e. the list of IPs is not modified in any way).
             * Note: An explicit rule to allow for DNS traffic is needed for the pods, as
             * ToFQDN counts as an egress rule and will enforce egress policy when
             * PolicyEnforcment=default.
             * Note: If the resolved IPs are IPs within the kubernetes cluster, the
             * ToFQDN rule will not apply to that IP.
             * Note: ToFQDN cannot occur in the same policy as other To* rules.
             */
            toFQDNs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToFQDNs>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToGroups>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToNodes>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * connect to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPorts>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToRequires>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServices>[]>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumNetworkPolicySpecsEgressAuthentication {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumNetworkPolicySpecsEgressAuthenticationPatch {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * EgressDenyRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumNetworkPolicySpecsEgressDeny {
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is not allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyIcmps>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToCIDRSet>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToEndpoints>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToGroups>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToNodes>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to connect
             * to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is not allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToPorts>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToRequires>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServices>[]>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyIcmpsFieldsPatch>[]>;
        }

        /**
         * EgressDenyRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyPatch {
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is not allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyIcmpsPatch>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToCIDRSetPatch>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToEndpointsPatch>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToGroupsPatch>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToNodesPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to connect
             * to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is not allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToPortsPatch>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToRequiresPatch>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesPatch>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToPorts {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToPortsPorts>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToPortsPatch {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToPortsPortsPatch>[]>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServices {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesK8sService>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelector>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8sService {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8sServicePatch {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelector {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelector>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorPatch {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorPatch>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumNetworkPolicySpecsEgressDenyToServicesPatch {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesK8sServicePatch>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyToServicesK8sServiceSelectorPatch>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecsEgressIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecsEgressIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecsEgressIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecsEgressIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressIcmpsFieldsPatch>[]>;
        }

        /**
         * EgressRule contains all rule types which can be applied at egress, i.e.
         * network traffic that originates inside the endpoint and exits the endpoint
         * selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members of the structure are specified, then all members
         *     must match in order for the rule to take effect. The exception to this
         *     rule is the ToRequires member; the effects of any Requires field in any
         *     rule will apply to all other rules as well.
         *
         *   - ToEndpoints, ToCIDR, ToCIDRSet, ToEntities, ToServices and ToGroups are
         *     mutually exclusive. Only one of these members may be present within an
         *     individual rule.
         */
        export interface CiliumNetworkPolicySpecsEgressPatch {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressAuthenticationPatch>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to connect to.
             *
             * Example:
             * Any endpoint with the label "app=httpd" is allowed to initiate
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressIcmpsPatch>[]>;
            /**
             * ToCIDR is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections. Only connections destined for
             * outside of the cluster and not targeting the host will be subject
             * to CIDR rules.  This will match on the destination IP address of
             * outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet
             * with no ExcludeCIDRs is equivalent. Overlaps are allowed between
             * ToCIDR and ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24
             */
            toCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToCIDRSet is a list of IP blocks which the endpoint subject to the rule
             * is allowed to initiate connections to in addition to connections
             * which are allowed via ToEndpoints, along with a list of subnets contained
             * within their corresponding IP block to which traffic should not be
             * allowed. This will match on the destination IP address of outgoing
             * connections. Adding a prefix into ToCIDR or into ToCIDRSet with no
             * ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and
             * ToCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=database-proxy" is allowed to
             * initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28.
             */
            toCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToCIDRSetPatch>[]>;
            /**
             * ToEndpoints is a list of endpoints identified by an EndpointSelector to
             * which the endpoints subject to the rule are allowed to communicate.
             *
             * Example:
             * Any endpoint with the label "role=frontend" can communicate with any
             * endpoint carrying the label "role=backend".
             */
            toEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToEndpointsPatch>[]>;
            /**
             * ToEntities is a list of special entities to which the endpoint subject
             * to the rule is allowed to initiate connections. Supported entities are
             * `world`, `cluster`,`host`,`remote-node`,`kube-apiserver`, `init`,
             * `health`,`unmanaged` and `all`.
             */
            toEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result
             * from DNS resolution of `ToFQDN.MatchName`s are added to the same
             * EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and
             * L7 rules within this EgressRule will also apply to these IPs.
             * The DNS -> IP mapping is re-resolved periodically from within the
             * cilium-agent, and the IPs in the DNS response are effected in the policy
             * for selected pods as-is (i.e. the list of IPs is not modified in any way).
             * Note: An explicit rule to allow for DNS traffic is needed for the pods, as
             * ToFQDN counts as an egress rule and will enforce egress policy when
             * PolicyEnforcment=default.
             * Note: If the resolved IPs are IPs within the kubernetes cluster, the
             * ToFQDN rule will not apply to that IP.
             * Note: ToFQDN cannot occur in the same policy as other To* rules.
             */
            toFQDNs?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToFQDNsPatch>[]>;
            /**
             * ToGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * toGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            toGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToGroupsPatch>[]>;
            /**
             * ToNodes is a list of nodes identified by an
             * EndpointSelector to which endpoints subject to the rule is allowed to communicate.
             */
            toNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToNodesPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * connect to.
             *
             * Example:
             * Any endpoint with the label "role=frontend" is allowed to initiate
             * connections to destination port 8080/tcp
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsPatch>[]>;
            /**
             * ToRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be able to connect to other
             * endpoints. These additional constraints do no by itself grant access
             * privileges and must always be accompanied with at least one matching
             * ToEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires any endpoint to which it
             * communicates to also carry the label "team=A".
             */
            toRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToRequiresPatch>[]>;
            /**
             * ToServices is a list of services to which the endpoint subject
             * to the rule is allowed to initiate connections.
             * Currently Cilium only supports toServices for K8s services.
             */
            toServices?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesPatch>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecsEgressToCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecsEgressToCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecsEgressToCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressToEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressToEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface CiliumNetworkPolicySpecsEgressToFQDNs {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        export interface CiliumNetworkPolicySpecsEgressToFQDNsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecsEgressToGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecsEgressToGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecsEgressToGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecsEgressToGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressToNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressToNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumNetworkPolicySpecsEgressToPorts {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsListener>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsOriginatingTLS>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsPorts>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRules>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsTerminatingTLS>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsListener {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfig {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfigPatch {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsListenerPatch {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsListenerEnvoyConfigPatch>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsOriginatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsOriginatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsOriginatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsOriginatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsOriginatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsOriginatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsPatch {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsListenerPatch>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsOriginatingTLSPatch>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsPortsPatch>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesPatch>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsTerminatingTLSPatch>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRules {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesDns>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesHttp>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesKafka>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesDns {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesDnsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttp {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatches {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesPatch {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecretPatch>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesHttpPatch {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesHttpHeaderMatchesPatch>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesKafka {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesKafkaPatch {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsRulesPatch {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesDnsPatch>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesHttpPatch>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsRulesKafkaPatch>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsTerminatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsTerminatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsTerminatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToPortsTerminatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsTerminatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecsEgressToPortsTerminatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressToRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsEgressToRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumNetworkPolicySpecsEgressToServices {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesK8sService>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelector>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesK8sService {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sService selects service by name and namespace pair
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesK8sServicePatch {
            namespace?: pulumi.Input<string>;
            serviceName?: pulumi.Input<string>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelector {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelector>;
        }

        /**
         * K8sServiceSelector selects services by k8s labels and namespace
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorPatch {
            namespace?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorPatch>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ServiceSelector is a label selector for k8s services
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Service selects policy targets that are bundled as part of a
         * logical load-balanced service.
         *
         * Currently only Kubernetes-based Services are supported.
         */
        export interface CiliumNetworkPolicySpecsEgressToServicesPatch {
            k8sService?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesK8sServicePatch>;
            k8sServiceSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressToServicesK8sServiceSelectorPatch>;
        }

        /**
         * EnableDefaultDeny determines whether this policy configures the
         * subject endpoint(s) to have a default deny mode. If enabled,
         * this causes all traffic not explicitly allowed by a network policy
         * to be dropped.
         *
         * If not specified, the default is true for each traffic direction
         * that has rules, and false otherwise. For example, if a policy
         * only has Ingress or IngressDeny rules, then the default for
         * ingress is true and egress is false.
         *
         * If multiple policies apply to an endpoint, that endpoint's default deny
         * will be enabled if any policy requests it.
         *
         * This is useful for creating broad-based network policies that will not
         * cause endpoints to enter default-deny mode.
         */
        export interface CiliumNetworkPolicySpecsEnableDefaultDeny {
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to egress traffic.
             */
            egress?: pulumi.Input<boolean>;
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to ingress traffic.
             */
            ingress?: pulumi.Input<boolean>;
        }

        /**
         * EnableDefaultDeny determines whether this policy configures the
         * subject endpoint(s) to have a default deny mode. If enabled,
         * this causes all traffic not explicitly allowed by a network policy
         * to be dropped.
         *
         * If not specified, the default is true for each traffic direction
         * that has rules, and false otherwise. For example, if a policy
         * only has Ingress or IngressDeny rules, then the default for
         * ingress is true and egress is false.
         *
         * If multiple policies apply to an endpoint, that endpoint's default deny
         * will be enabled if any policy requests it.
         *
         * This is useful for creating broad-based network policies that will not
         * cause endpoints to enter default-deny mode.
         */
        export interface CiliumNetworkPolicySpecsEnableDefaultDenyPatch {
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to egress traffic.
             */
            egress?: pulumi.Input<boolean>;
            /**
             * Whether or not the endpoint should have a default-deny rule applied
             * to ingress traffic.
             */
            ingress?: pulumi.Input<boolean>;
        }

        /**
         * EndpointSelector selects all endpoints which should be subject to
         * this rule. EndpointSelector and NodeSelector cannot be both empty and
         * are mutually exclusive.
         */
        export interface CiliumNetworkPolicySpecsEndpointSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEndpointSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsEndpointSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector selects all endpoints which should be subject to
         * this rule. EndpointSelector and NodeSelector cannot be both empty and
         * are mutually exclusive.
         */
        export interface CiliumNetworkPolicySpecsEndpointSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEndpointSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * IngressRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumNetworkPolicySpecsIngress {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressAuthentication>;
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromCIDRSet>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromEndpoints>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromGroups>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromNodes>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromRequires>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressIcmps>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPorts>[]>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumNetworkPolicySpecsIngressAuthentication {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * Authentication is the required authentication type for the allowed traffic, if any.
         */
        export interface CiliumNetworkPolicySpecsIngressAuthenticationPatch {
            /**
             * Mode is the required authentication mode for the allowed traffic, if any.
             */
            mode?: pulumi.Input<string>;
        }

        /**
         * IngressDenyRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumNetworkPolicySpecsIngressDeny {
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromCIDRSet>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromEndpoints>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromGroups>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromNodes>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromRequires>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyIcmps>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyToPorts>[]>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyFromRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyIcmpsFieldsPatch>[]>;
        }

        /**
         * IngressDenyRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet, FromGroups and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyPatch {
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromCIDRSetPatch>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromEndpointsPatch>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromGroupsPatch>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromNodesPatch>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyFromRequiresPatch>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyIcmpsPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is not allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can not accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyToPortsPatch>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyToPorts {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyToPortsPorts>[]>;
        }

        /**
         * PortDenyRule is a list of ports/protocol that should be used for deny
         * policies. This structure lacks the L7Rules since it's not supported in deny
         * policies.
         */
        export interface CiliumNetworkPolicySpecsIngressDenyToPortsPatch {
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyToPortsPortsPatch>[]>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecsIngressDenyToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecsIngressDenyToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecsIngressFromCIDRSet {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelector>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CIDRGroupSelector selects CiliumCIDRGroups by their labels,
         * rather than by name.
         */
        export interface CiliumNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * CIDRRule is a rule that specifies a CIDR prefix to/from which outside
         * communication  is allowed, along with an optional list of subnets within that
         * CIDR prefix to/from which outside communication is not allowed.
         */
        export interface CiliumNetworkPolicySpecsIngressFromCIDRSetPatch {
            /**
             * CIDR is a CIDR prefix / IP Block.
             */
            cidr?: pulumi.Input<string>;
            /**
             * CIDRGroupRef is a reference to a CiliumCIDRGroup object.
             * A CiliumCIDRGroup contains a list of CIDRs that the endpoint, subject to
             * the rule, can (Ingress/Egress) or cannot (IngressDeny/EgressDeny) receive
             * connections from.
             */
            cidrGroupRef?: pulumi.Input<string>;
            cidrGroupSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromCIDRSetCidrGroupSelectorPatch>;
            /**
             * ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule
             * is not allowed to initiate connections to. These CIDR prefixes should be
             * contained within Cidr, using ExceptCIDRs together with CIDRGroupRef is not
             * supported yet.
             * These exceptions are only applied to the Cidr in this CIDRRule, and do not
             * apply to any other CIDR prefixes in any other CIDRRules.
             */
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressFromEndpoints {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressFromEndpointsPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromEndpointsMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecsIngressFromGroups {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromGroupsAws>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecsIngressFromGroupsAws {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AWSGroup is an structure that can be used to whitelisting information from AWS integration
         */
        export interface CiliumNetworkPolicySpecsIngressFromGroupsAwsPatch {
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            region?: pulumi.Input<string>;
            securityGroupsIds?: pulumi.Input<pulumi.Input<string>[]>;
            securityGroupsNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Groups structure to store all kinds of new integrations that needs a new
         * derivative policy.
         */
        export interface CiliumNetworkPolicySpecsIngressFromGroupsPatch {
            aws?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromGroupsAwsPatch>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressFromNodes {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromNodesMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressFromNodesMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressFromNodesMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressFromNodesPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromNodesMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressFromRequires {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * EndpointSelector is a wrapper for k8s LabelSelector.
         */
        export interface CiliumNetworkPolicySpecsIngressFromRequiresPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromRequiresMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecsIngressIcmps {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressIcmpsFields>[]>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecsIngressIcmpsFields {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPField is a ICMP field.
         */
        export interface CiliumNetworkPolicySpecsIngressIcmpsFieldsPatch {
            /**
             * Family is a IP address version.
             * Currently, we support `IPv4` and `IPv6`.
             * `IPv4` is set as default.
             */
            family?: pulumi.Input<string>;
            /**
             * Type is a ICMP-type.
             * It should be an 8bit code (0-255), or it's CamelCase name (for example, "EchoReply").
             * Allowed ICMP types are:
             *     Ipv4: EchoReply | DestinationUnreachable | Redirect | Echo | EchoRequest |
             * 		     RouterAdvertisement | RouterSelection | TimeExceeded | ParameterProblem |
             * 			 Timestamp | TimestampReply | Photuris | ExtendedEcho Request | ExtendedEcho Reply
             *     Ipv6: DestinationUnreachable | PacketTooBig | TimeExceeded | ParameterProblem |
             * 			 EchoRequest | EchoReply | MulticastListenerQuery| MulticastListenerReport |
             * 			 MulticastListenerDone | RouterSolicitation | RouterAdvertisement | NeighborSolicitation |
             * 			 NeighborAdvertisement | RedirectMessage | RouterRenumbering | ICMPNodeInformationQuery |
             * 			 ICMPNodeInformationResponse | InverseNeighborDiscoverySolicitation | InverseNeighborDiscoveryAdvertisement |
             * 			 HomeAgentAddressDiscoveryRequest | HomeAgentAddressDiscoveryReply | MobilePrefixSolicitation |
             * 			 MobilePrefixAdvertisement | DuplicateAddressRequestCodeSuffix | DuplicateAddressConfirmationCodeSuffix |
             * 			 ExtendedEchoRequest | ExtendedEchoReply
             */
            type?: pulumi.Input<number | string>;
        }

        /**
         * ICMPRule is a list of ICMP fields.
         */
        export interface CiliumNetworkPolicySpecsIngressIcmpsPatch {
            /**
             * Fields is a list of ICMP fields.
             */
            fields?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressIcmpsFieldsPatch>[]>;
        }

        /**
         * IngressRule contains all rule types which can be applied at ingress,
         * i.e. network traffic that originates outside of the endpoint and
         * is entering the endpoint selected by the endpointSelector.
         *
         *   - All members of this structure are optional. If omitted or empty, the
         *     member will have no effect on the rule.
         *
         *   - If multiple members are set, all of them need to match in order for
         *     the rule to take effect. The exception to this rule is FromRequires field;
         *     the effects of any Requires field in any rule will apply to all other
         *     rules as well.
         *
         *   - FromEndpoints, FromCIDR, FromCIDRSet and FromEntities are mutually
         *     exclusive. Only one of these members may be present within an individual
         *     rule.
         */
        export interface CiliumNetworkPolicySpecsIngressPatch {
            authentication?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressAuthenticationPatch>;
            /**
             * FromCIDR is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from. Only connections which
             * do *not* originate from the cluster or from the local host are subject
             * to CIDR rules. In order to allow in-cluster connectivity, use the
             * FromEndpoints field.  This will match on the source IP address of
             * incoming connections. Adding  a prefix into FromCIDR or into
             * FromCIDRSet with no ExcludeCIDRs is  equivalent.  Overlaps are
             * allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.3.9.1
             */
            fromCIDR?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromCIDRSet is a list of IP blocks which the endpoint subject to the
             * rule is allowed to receive connections from in addition to FromEndpoints,
             * along with a list of subnets contained within their corresponding IP block
             * from which traffic should not be allowed.
             * This will match on the source IP address of incoming connections. Adding
             * a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is
             * equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet.
             *
             * Example:
             * Any endpoint with the label "app=my-legacy-pet" is allowed to receive
             * connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12.
             */
            fromCIDRSet?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromCIDRSetPatch>[]>;
            /**
             * FromEndpoints is a list of endpoints identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             *
             * Example:
             * Any endpoint with the label "role=backend" can be consumed by any
             * endpoint carrying the label "role=frontend".
             */
            fromEndpoints?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromEndpointsPatch>[]>;
            /**
             * FromEntities is a list of special entities which the endpoint subject
             * to the rule is allowed to receive connections from. Supported entities are
             * `world`, `cluster` and `host`
             */
            fromEntities?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FromGroups is a directive that allows the integration with multiple outside
             * providers. Currently, only AWS is supported, and the rule can select by
             * multiple sub directives:
             *
             * Example:
             * FromGroups:
             * - aws:
             *     securityGroupsIds:
             *     - 'sg-XXXXXXXXXXXXX'
             */
            fromGroups?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromGroupsPatch>[]>;
            /**
             * FromNodes is a list of nodes identified by an
             * EndpointSelector which are allowed to communicate with the endpoint
             * subject to the rule.
             */
            fromNodes?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromNodesPatch>[]>;
            /**
             * FromRequires is a list of additional constraints which must be met
             * in order for the selected endpoints to be reachable. These
             * additional constraints do no by itself grant access privileges and
             * must always be accompanied with at least one matching FromEndpoints.
             *
             * Example:
             * Any Endpoint with the label "team=A" requires consuming endpoint
             * to also carry the label "team=A".
             */
            fromRequires?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressFromRequiresPatch>[]>;
            /**
             * ICMPs is a list of ICMP rule identified by type number
             * which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * type 8 ICMP connections.
             */
            icmps?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressIcmpsPatch>[]>;
            /**
             * ToPorts is a list of destination ports identified by port number and
             * protocol which the endpoint subject to the rule is allowed to
             * receive connections on.
             *
             * Example:
             * Any endpoint with the label "app=httpd" can only accept incoming
             * connections on port 80/tcp.
             */
            toPorts?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsPatch>[]>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumNetworkPolicySpecsIngressToPorts {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsListener>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsOriginatingTLS>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsPorts>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRules>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsTerminatingTLS>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsListener {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfig {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * EnvoyConfig is a reference to the CEC or CCEC resource in which
         * the listener is defined.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfigPatch {
            /**
             * Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
             * CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
             * respectively. The only case this is currently explicitly needed is when referring to a
             * CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
             * from a cluster scoped policy is not allowed.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
             * the listener is defined in.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * listener specifies the name of a custom Envoy listener to which this traffic should be
         * redirected to.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsListenerPatch {
            envoyConfig?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsListenerEnvoyConfigPatch>;
            /**
             * Name is the name of the listener.
             */
            name?: pulumi.Input<string>;
            /**
             * Priority for this Listener that is used when multiple rules would apply different
             * listeners to a policy map entry. Behavior of this is implementation dependent.
             */
            priority?: pulumi.Input<number>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsOriginatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsOriginatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * OriginatingTLS is the TLS context for the connections originated by
         * the L7 proxy.  For egress policy this specifies the client-side TLS
         * parameters for the upstream connection originating from the L7 proxy
         * to the remote destination. For ingress policy this specifies the
         * client-side TLS parameters for the connection from the L7 proxy to
         * the local endpoint.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsOriginatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsOriginatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsOriginatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsOriginatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of ports/protocol combinations with optional Layer 7
         * rules which must be met.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsPatch {
            listener?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsListenerPatch>;
            originatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsOriginatingTLSPatch>;
            /**
             * Ports is a list of L4 port/protocol
             */
            ports?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsPortsPatch>[]>;
            rules?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesPatch>;
            /**
             * ServerNames is a list of allowed TLS SNI values. If not empty, then
             * TLS must be present and one of the provided SNIs must be indicated in the
             * TLS handshake.
             */
            serverNames?: pulumi.Input<pulumi.Input<string>[]>;
            terminatingTLS?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsTerminatingTLSPatch>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsPorts {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * PortProtocol specifies an L4 port with an optional transport protocol
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsPortsPatch {
            /**
             * EndPort can only be an L4 port number.
             */
            endPort?: pulumi.Input<number>;
            /**
             * Port can be an L4 port number, or a name in the form of "http"
             * or "http-8080".
             */
            port?: pulumi.Input<string>;
            /**
             * Protocol is the L4 protocol. If omitted or empty, any protocol
             * matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
             *
             * Matching on ICMP is not supported.
             *
             * Named port specified for a container may narrow this down, but may not
             * contradict this.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRules {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesDns>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesHttp>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesKafka>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesDns {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleDNS is a list of allowed DNS lookups.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesDnsPatch {
            /**
             * MatchName matches literal DNS names. A trailing "." is automatically added
             * when missing.
             */
            matchName?: pulumi.Input<string>;
            /**
             * MatchPattern allows using wildcards to match DNS names. All wildcards are
             * case insensitive. The wildcards are:
             * - "*" matches 0 or more DNS valid characters, and may occur anywhere in
             * the pattern. As a special case a "*" as the leftmost character, without a
             * following "." matches all subdomains as well as the name to the right.
             * A trailing "." is automatically added when missing.
             *
             * Examples:
             * `*.cilium.io` matches subomains of cilium at that level
             *   www.cilium.io and blog.cilium.io match, cilium.io and google.com do not
             * `*cilium.io` matches cilium.io and all subdomains ends with "cilium.io"
             *   except those containing "." separator, subcilium.io and sub-cilium.io match,
             *   www.cilium.io and blog.cilium.io does not
             * sub*.cilium.io matches subdomains of cilium where the subdomain component
             * begins with "sub"
             *   sub.cilium.io and subdomain.cilium.io match, www.cilium.io,
             *   blog.cilium.io, cilium.io and google.com do not
             */
            matchPattern?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttp {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatches {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * HeaderMatch extends the HeaderValue for matching requirement of a
         * named header field against an immediate string, a secret value, or
         * a regex.  If none of the optional fields is present, then the
         * header value is not matched, only presence of the header is enough.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesPatch {
            /**
             * Mismatch identifies what to do in case there is no match. The default is
             * to drop the request. Otherwise the overall rule is still considered as
             * matching, but the mismatches are logged in the access log.
             */
            mismatch?: pulumi.Input<string>;
            /**
             * Name identifies the header.
             */
            name?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecretPatch>;
            /**
             * Value matches the exact value of the header. Can be specified either
             * alone or together with "Secret"; will be used as the header value if the
             * secret can not be found in the latter case.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret refers to a secret that contains the value to be matched against.
         * The secret must only contain one entry. If the referred secret does not
         * exist, and there is no "Value" specified, the match will fail.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * PortRuleHTTP is a list of HTTP protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule does not have any
         * effect.
         *
         * All fields of this type are extended POSIX regex as defined by IEEE Std
         * 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax)
         * matched against the path of an incoming request. Currently it can contain
         * characters disallowed from the conventional "path" part of a URL as defined
         * by RFC 3986.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesHttpPatch {
            /**
             * HeaderMatches is a list of HTTP headers which must be
             * present and match against the given values. Mismatch field can be used
             * to specify what to do when there is no match.
             */
            headerMatches?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesHttpHeaderMatchesPatch>[]>;
            /**
             * Headers is a list of HTTP headers which must be present in the
             * request. If omitted or empty, requests are allowed regardless of
             * headers present.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Host is an extended POSIX regex matched against the host header of a
             * request. Examples:
             *
             * - foo.bar.com will match the host fooXbar.com or foo-bar.com
             * - foo\.bar\.com will only match the host foo.bar.com
             *
             * If omitted or empty, the value of the host header is ignored.
             */
            host?: pulumi.Input<string>;
            /**
             * Method is an extended POSIX regex matched against the method of a
             * request, e.g. "GET", "POST", "PUT", "PATCH", "DELETE", ...
             *
             * If omitted or empty, all methods are allowed.
             */
            method?: pulumi.Input<string>;
            /**
             * Path is an extended POSIX regex matched against the path of a
             * request. Currently it can contain characters disallowed from the
             * conventional "path" part of a URL as defined by RFC 3986.
             *
             * If omitted or empty, all paths are all allowed.
             */
            path?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesKafka {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * PortRule is a list of Kafka protocol constraints. All fields are
         * optional, if all fields are empty or missing, the rule will match all
         * Kafka messages.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesKafkaPatch {
            /**
             * APIKey is a case-insensitive string matched against the key of a
             * request, e.g. "produce", "fetch", "createtopic", "deletetopic", et al
             * Reference: https://kafka.apache.org/protocol#protocol_api_keys
             *
             * If omitted or empty, and if Role is not specified, then all keys are allowed.
             */
            apiKey?: pulumi.Input<string>;
            /**
             * APIVersion is the version matched against the api version of the
             * Kafka message. If set, it has to be a string representing a positive
             * integer.
             *
             * If omitted or empty, all versions are allowed.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * ClientID is the client identifier as provided in the request.
             *
             * From Kafka protocol documentation:
             * This is a user supplied identifier for the client application. The
             * user can use any identifier they like and it will be used when
             * logging errors, monitoring aggregates, etc. For example, one might
             * want to monitor not just the requests per second overall, but the
             * number coming from each client application (each of which could
             * reside on multiple servers). This id acts as a logical grouping
             * across all requests from a particular client.
             *
             * If omitted or empty, all client identifiers are allowed.
             */
            clientID?: pulumi.Input<string>;
            /**
             * Role is a case-insensitive string and describes a group of API keys
             * necessary to perform certain higher-level Kafka operations such as "produce"
             * or "consume". A Role automatically expands into all APIKeys required
             * to perform the specified higher-level operation.
             *
             * The following values are supported:
             *  - "produce": Allow producing to the topics specified in the rule
             *  - "consume": Allow consuming from the topics specified in the rule
             *
             * This field is incompatible with the APIKey field, i.e APIKey and Role
             * cannot both be specified in the same rule.
             *
             * If omitted or empty, and if APIKey is not specified, then all keys are
             * allowed.
             */
            role?: pulumi.Input<string>;
            /**
             * Topic is the topic name contained in the message. If a Kafka request
             * contains multiple topics, then all topics must be allowed or the
             * message will be rejected.
             *
             * This constraint is ignored if the matched request message type
             * doesn't contain any topic. Maximum size of Topic can be 249
             * characters as per recent Kafka spec and allowed characters are
             * a-z, A-Z, 0-9, -, . and _.
             *
             * Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10
             * version the length was changed from 255 to 249. For compatibility
             * reasons we are using 255.
             *
             * If omitted or empty, all topics are allowed.
             */
            topic?: pulumi.Input<string>;
        }

        /**
         * Rules is a list of additional port level rules which must be met in
         * order for the PortRule to allow the traffic. If omitted or empty,
         * no layer 7 rules are enforced.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsRulesPatch {
            /**
             * DNS-specific rules.
             */
            dns?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesDnsPatch>[]>;
            /**
             * HTTP specific rules.
             */
            http?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesHttpPatch>[]>;
            /**
             * Kafka-specific rules.
             */
            kafka?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsRulesKafkaPatch>[]>;
            /**
             * Key-value pair rules.
             */
            l7?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
            /**
             * Name of the L7 protocol for which the Key-value pair rules apply.
             */
            l7proto?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsTerminatingTLS {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsTerminatingTLSSecret>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * TerminatingTLS is the TLS context for the connection terminated by
         * the L7 proxy.  For egress policy this specifies the server-side TLS
         * parameters to be applied on the connections originated from the local
         * endpoint and terminated by the L7 proxy. For ingress policy this specifies
         * the server-side TLS parameters to be applied on the connections
         * originated from a remote source and terminated by the L7 proxy.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsTerminatingTLSPatch {
            /**
             * Certificate is the file name or k8s secret item name for the certificate
             * chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
             * item must exist.
             */
            certificate?: pulumi.Input<string>;
            /**
             * PrivateKey is the file name or k8s secret item name for the private key
             * matching the certificate chain. If omitted, 'tls.key' is assumed, if it
             * exists. If given, the item must exist.
             */
            privateKey?: pulumi.Input<string>;
            secret?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressToPortsTerminatingTLSSecretPatch>;
            /**
             * TrustedCA is the file name or k8s secret item name for the trusted CA.
             * If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
             * exist.
             */
            trustedCA?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsTerminatingTLSSecret {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Secret is the secret that contains the certificates and private key for
         * the TLS context.
         * By default, Cilium will search in this secret for the following items:
         *  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
         *  - 'tls.crt' - Which represents the public key certificate.
         *  - 'tls.key' - Which represents the private key matching the public key
         *                certificate.
         */
        export interface CiliumNetworkPolicySpecsIngressToPortsTerminatingTLSSecretPatch {
            /**
             * Name is the name of the secret.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace in which the secret exists. Context of use
             * determines the default value if left out (e.g., "default").
             */
            namespace?: pulumi.Input<string>;
        }

        /**
         * Label is the Cilium's representation of a container label.
         */
        export interface CiliumNetworkPolicySpecsLabels {
            key?: pulumi.Input<string>;
            /**
             * Source can be one of the above values (e.g.: LabelSourceContainer).
             */
            source?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        /**
         * Label is the Cilium's representation of a container label.
         */
        export interface CiliumNetworkPolicySpecsLabelsPatch {
            key?: pulumi.Input<string>;
            /**
             * Source can be one of the above values (e.g.: LabelSourceContainer).
             */
            source?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        /**
         * NodeSelector selects all nodes which should be subject to this rule.
         * EndpointSelector and NodeSelector cannot be both empty and are mutually
         * exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
         */
        export interface CiliumNetworkPolicySpecsNodeSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsNodeSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsNodeSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface CiliumNetworkPolicySpecsNodeSelectorMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * NodeSelector selects all nodes which should be subject to this rule.
         * EndpointSelector and NodeSelector cannot be both empty and are mutually
         * exclusive. Can only be used in CiliumClusterwideNetworkPolicies.
         */
        export interface CiliumNetworkPolicySpecsNodeSelectorPatch {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsNodeSelectorMatchExpressionsPatch>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Rule is a policy rule which must be applied to all endpoints which match the
         * labels contained in the endpointSelector
         *
         * Each rule is split into an ingress section which contains all rules
         * applicable at ingress, and an egress section applicable at egress. For rule
         * types such as `L4Rule` and `CIDR` which can be applied at both ingress and
         * egress, both ingress and egress side have to either specifically allow the
         * connection or one side has to be omitted.
         *
         * Either ingress, egress, or both can be provided. If both ingress and egress
         * are omitted, the rule has no effect.
         */
        export interface CiliumNetworkPolicySpecsPatch {
            /**
             * Description is a free form string, it can be used by the creator of
             * the rule to store human readable explanation of the purpose of this
             * rule. Rules cannot be identified by comment.
             */
            description?: pulumi.Input<string>;
            /**
             * Egress is a list of EgressRule which are enforced at egress.
             * If omitted or empty, this rule does not apply at egress.
             */
            egress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressPatch>[]>;
            /**
             * EgressDeny is a list of EgressDenyRule which are enforced at egress.
             * Any rule inserted here will be denied regardless of the allowed egress
             * rules in the 'egress' field.
             * If omitted or empty, this rule does not apply at egress.
             */
            egressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEgressDenyPatch>[]>;
            enableDefaultDeny?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEnableDefaultDenyPatch>;
            endpointSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsEndpointSelectorPatch>;
            /**
             * Ingress is a list of IngressRule which are enforced at ingress.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingress?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressPatch>[]>;
            /**
             * IngressDeny is a list of IngressDenyRule which are enforced at ingress.
             * Any rule inserted here will be denied regardless of the allowed ingress
             * rules in the 'ingress' field.
             * If omitted or empty, this rule does not apply at ingress.
             */
            ingressDeny?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsIngressDenyPatch>[]>;
            /**
             * Labels is a list of optional strings which can be used to
             * re-identify the rule or to store metadata. It is possible to lookup
             * or delete strings based on labels. Labels are not required to be
             * unique, multiple rules can have overlapping or identical labels.
             */
            labels?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsLabelsPatch>[]>;
            nodeSelector?: pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicySpecsNodeSelectorPatch>;
        }

        /**
         * Status is the status of the Cilium policy rule
         */
        export interface CiliumNetworkPolicyStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.cilium.v2.CiliumNetworkPolicyStatusConditions>[]>;
            /**
             * DerivativePolicies is the status of all policies derived from the Cilium
             * policy
             */
            derivativePolicies?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
        }

        export interface CiliumNetworkPolicyStatusConditions {
            /**
             * The last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, one of True, False, or Unknown
             */
            status?: pulumi.Input<string>;
            /**
             * The type of the policy condition
             */
            type?: pulumi.Input<string>;
        }

    }
}

export namespace meta {
    export namespace v1 {
        /**
         * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
         */
        export interface ListMeta {
            /**
             * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
             */
            continue?: pulumi.Input<string>;
            /**
             * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
             */
            remainingItemCount?: pulumi.Input<number>;
            /**
             * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
        }

        /**
         * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
         */
        export interface ManagedFieldsEntry {
            /**
             * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
             */
            fieldsType?: pulumi.Input<string>;
            /**
             * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
             */
            fieldsV1?: any;
            /**
             * Manager is an identifier of the workflow managing these fields.
             */
            manager?: pulumi.Input<string>;
            /**
             * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
             */
            operation?: pulumi.Input<string>;
            /**
             * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
             */
            subresource?: pulumi.Input<string>;
            /**
             * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
             */
            time?: pulumi.Input<string>;
        }

        /**
         * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
         */
        export interface ManagedFieldsEntryPatch {
            /**
             * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
             */
            fieldsType?: pulumi.Input<string>;
            /**
             * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
             */
            fieldsV1?: any;
            /**
             * Manager is an identifier of the workflow managing these fields.
             */
            manager?: pulumi.Input<string>;
            /**
             * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
             */
            operation?: pulumi.Input<string>;
            /**
             * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
             */
            subresource?: pulumi.Input<string>;
            /**
             * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
             */
            time?: pulumi.Input<string>;
        }

        /**
         * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
         */
        export interface ObjectMeta {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            creationTimestamp?: pulumi.Input<string>;
            /**
             * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
             */
            deletionGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
             *
             * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            deletionTimestamp?: pulumi.Input<string>;
            /**
             * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
             */
            finalizers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
             *
             * If this field is specified and the generated name exists, the server will return a 409.
             *
             * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             */
            generateName?: pulumi.Input<string>;
            /**
             * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
             */
            generation?: pulumi.Input<number>;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
             */
            managedFields?: pulumi.Input<pulumi.Input<inputs.meta.v1.ManagedFieldsEntry>[]>;
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
             *
             * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             */
            namespace?: pulumi.Input<string>;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
             */
            ownerReferences?: pulumi.Input<pulumi.Input<inputs.meta.v1.OwnerReference>[]>;
            /**
             * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
             *
             * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
            /**
             * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
             *
             * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
         */
        export interface ObjectMetaPatch {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            creationTimestamp?: pulumi.Input<string>;
            /**
             * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
             */
            deletionGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
             *
             * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            deletionTimestamp?: pulumi.Input<string>;
            /**
             * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
             */
            finalizers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
             *
             * If this field is specified and the generated name exists, the server will return a 409.
             *
             * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             */
            generateName?: pulumi.Input<string>;
            /**
             * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
             */
            generation?: pulumi.Input<number>;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
             */
            managedFields?: pulumi.Input<pulumi.Input<inputs.meta.v1.ManagedFieldsEntryPatch>[]>;
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
             *
             * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             */
            namespace?: pulumi.Input<string>;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
             */
            ownerReferences?: pulumi.Input<pulumi.Input<inputs.meta.v1.OwnerReferencePatch>[]>;
            /**
             * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
             *
             * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
            /**
             * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
             *
             * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface OwnerReference {
            /**
             * API version of the referent.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: pulumi.Input<boolean>;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: pulumi.Input<boolean>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: pulumi.Input<string>;
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface OwnerReferencePatch {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: pulumi.Input<boolean>;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: pulumi.Input<boolean>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }

    }
}
