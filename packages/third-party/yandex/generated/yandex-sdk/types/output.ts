// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AlbBackendGroupGrpcBackend {
    healthcheck?: outputs.AlbBackendGroupGrpcBackendHealthcheck;
    loadBalancingConfig?: outputs.AlbBackendGroupGrpcBackendLoadBalancingConfig;
    name: string;
    port?: number;
    targetGroupIds: string[];
    tls?: outputs.AlbBackendGroupGrpcBackendTls;
    weight?: number;
}

export interface AlbBackendGroupGrpcBackendHealthcheck {
    grpcHealthcheck?: outputs.AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck;
    healthcheckPort?: number;
    healthyThreshold?: number;
    httpHealthcheck?: outputs.AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent?: number;
    streamHealthcheck?: outputs.AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold?: number;
}

export interface AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck {
    serviceName?: string;
}

export interface AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck {
    host?: string;
    http2?: boolean;
    path: string;
}

export interface AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck {
    receive?: string;
    send?: string;
}

export interface AlbBackendGroupGrpcBackendLoadBalancingConfig {
    localityAwareRoutingPercent?: number;
    mode?: string;
    panicThreshold?: number;
    strictLocality?: boolean;
}

export interface AlbBackendGroupGrpcBackendTls {
    sni?: string;
    validationContext?: outputs.AlbBackendGroupGrpcBackendTlsValidationContext;
}

export interface AlbBackendGroupGrpcBackendTlsValidationContext {
    trustedCaBytes?: string;
    trustedCaId?: string;
}

export interface AlbBackendGroupHttpBackend {
    healthcheck?: outputs.AlbBackendGroupHttpBackendHealthcheck;
    http2?: boolean;
    loadBalancingConfig?: outputs.AlbBackendGroupHttpBackendLoadBalancingConfig;
    name: string;
    port?: number;
    storageBucket?: string;
    targetGroupIds?: string[];
    tls?: outputs.AlbBackendGroupHttpBackendTls;
    weight?: number;
}

export interface AlbBackendGroupHttpBackendHealthcheck {
    grpcHealthcheck?: outputs.AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck;
    healthcheckPort?: number;
    healthyThreshold?: number;
    httpHealthcheck?: outputs.AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent?: number;
    streamHealthcheck?: outputs.AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold?: number;
}

export interface AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck {
    serviceName?: string;
}

export interface AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck {
    host?: string;
    http2?: boolean;
    path: string;
}

export interface AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck {
    receive?: string;
    send?: string;
}

export interface AlbBackendGroupHttpBackendLoadBalancingConfig {
    localityAwareRoutingPercent?: number;
    mode?: string;
    panicThreshold?: number;
    strictLocality?: boolean;
}

export interface AlbBackendGroupHttpBackendTls {
    sni?: string;
    validationContext?: outputs.AlbBackendGroupHttpBackendTlsValidationContext;
}

export interface AlbBackendGroupHttpBackendTlsValidationContext {
    trustedCaBytes?: string;
    trustedCaId?: string;
}

export interface AlbBackendGroupSessionAffinity {
    /**
     * IP address affinity
     */
    connection?: outputs.AlbBackendGroupSessionAffinityConnection;
    /**
     * Cookie affinity
     */
    cookie?: outputs.AlbBackendGroupSessionAffinityCookie;
    /**
     * Request header affinity
     */
    header?: outputs.AlbBackendGroupSessionAffinityHeader;
}

export interface AlbBackendGroupSessionAffinityConnection {
    /**
     * Use source IP address
     */
    sourceIp?: boolean;
}

export interface AlbBackendGroupSessionAffinityCookie {
    /**
     * Name of the HTTP cookie
     */
    name: string;
    /**
     * TTL for the cookie (if not set, session cookie will be used)
     */
    ttl?: string;
}

export interface AlbBackendGroupSessionAffinityHeader {
    /**
     * The name of the request header that will be used
     */
    headerName: string;
}

export interface AlbBackendGroupStreamBackend {
    enableProxyProtocol?: boolean;
    healthcheck?: outputs.AlbBackendGroupStreamBackendHealthcheck;
    loadBalancingConfig?: outputs.AlbBackendGroupStreamBackendLoadBalancingConfig;
    name: string;
    port?: number;
    targetGroupIds: string[];
    tls?: outputs.AlbBackendGroupStreamBackendTls;
    weight?: number;
}

export interface AlbBackendGroupStreamBackendHealthcheck {
    grpcHealthcheck?: outputs.AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck;
    healthcheckPort?: number;
    healthyThreshold?: number;
    httpHealthcheck?: outputs.AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent?: number;
    streamHealthcheck?: outputs.AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold?: number;
}

export interface AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck {
    serviceName?: string;
}

export interface AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck {
    host?: string;
    http2?: boolean;
    path: string;
}

export interface AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck {
    receive?: string;
    send?: string;
}

export interface AlbBackendGroupStreamBackendLoadBalancingConfig {
    localityAwareRoutingPercent?: number;
    mode?: string;
    panicThreshold?: number;
    strictLocality?: boolean;
}

export interface AlbBackendGroupStreamBackendTls {
    sni?: string;
    validationContext?: outputs.AlbBackendGroupStreamBackendTlsValidationContext;
}

export interface AlbBackendGroupStreamBackendTlsValidationContext {
    trustedCaBytes?: string;
    trustedCaId?: string;
}

export interface AlbBackendGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbHttpRouterRouteOptions {
    rbac?: outputs.AlbHttpRouterRouteOptionsRbac;
    securityProfileId?: string;
}

export interface AlbHttpRouterRouteOptionsRbac {
    action?: string;
    principals: outputs.AlbHttpRouterRouteOptionsRbacPrincipal[];
}

export interface AlbHttpRouterRouteOptionsRbacPrincipal {
    andPrincipals: outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal[];
}

export interface AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal {
    any?: boolean;
    header?: outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeader;
    remoteIp?: string;
}

export interface AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeader {
    name: string;
    value?: outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValue;
}

export interface AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValue {
    exact?: string;
    prefix?: string;
    regex?: string;
}

export interface AlbHttpRouterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbLoadBalancerAllocationPolicy {
    locations: outputs.AlbLoadBalancerAllocationPolicyLocation[];
}

export interface AlbLoadBalancerAllocationPolicyLocation {
    disableTraffic?: boolean;
    subnetId: string;
    zoneId: string;
}

export interface AlbLoadBalancerListener {
    endpoints?: outputs.AlbLoadBalancerListenerEndpoint[];
    http?: outputs.AlbLoadBalancerListenerHttp;
    name: string;
    stream?: outputs.AlbLoadBalancerListenerStream;
    tls?: outputs.AlbLoadBalancerListenerTls;
}

export interface AlbLoadBalancerListenerEndpoint {
    addresses: outputs.AlbLoadBalancerListenerEndpointAddress[];
    ports: number[];
}

export interface AlbLoadBalancerListenerEndpointAddress {
    externalIpv4Address?: outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv4Address;
    externalIpv6Address?: outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv6Address;
    internalIpv4Address?: outputs.AlbLoadBalancerListenerEndpointAddressInternalIpv4Address;
}

export interface AlbLoadBalancerListenerEndpointAddressExternalIpv4Address {
    address: string;
}

export interface AlbLoadBalancerListenerEndpointAddressExternalIpv6Address {
    address: string;
}

export interface AlbLoadBalancerListenerEndpointAddressInternalIpv4Address {
    address: string;
    subnetId: string;
}

export interface AlbLoadBalancerListenerHttp {
    handler?: outputs.AlbLoadBalancerListenerHttpHandler;
    redirects?: outputs.AlbLoadBalancerListenerHttpRedirects;
}

export interface AlbLoadBalancerListenerHttpHandler {
    allowHttp10?: boolean;
    http2Options?: outputs.AlbLoadBalancerListenerHttpHandlerHttp2Options;
    httpRouterId?: string;
    rewriteRequestId?: boolean;
}

export interface AlbLoadBalancerListenerHttpHandlerHttp2Options {
    maxConcurrentStreams?: number;
}

export interface AlbLoadBalancerListenerHttpRedirects {
    httpToHttps?: boolean;
}

export interface AlbLoadBalancerListenerStream {
    handler?: outputs.AlbLoadBalancerListenerStreamHandler;
}

export interface AlbLoadBalancerListenerStreamHandler {
    backendGroupId?: string;
}

export interface AlbLoadBalancerListenerTls {
    defaultHandler: outputs.AlbLoadBalancerListenerTlsDefaultHandler;
    sniHandlers?: outputs.AlbLoadBalancerListenerTlsSniHandler[];
}

export interface AlbLoadBalancerListenerTlsDefaultHandler {
    certificateIds: string[];
    httpHandler?: outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler;
    streamHandler?: outputs.AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler;
}

export interface AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler {
    allowHttp10?: boolean;
    http2Options?: outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options;
    httpRouterId?: string;
    rewriteRequestId?: boolean;
}

export interface AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options {
    maxConcurrentStreams?: number;
}

export interface AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler {
    backendGroupId?: string;
}

export interface AlbLoadBalancerListenerTlsSniHandler {
    handler: outputs.AlbLoadBalancerListenerTlsSniHandlerHandler;
    name: string;
    serverNames: string[];
}

export interface AlbLoadBalancerListenerTlsSniHandlerHandler {
    certificateIds: string[];
    httpHandler?: outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler;
    streamHandler?: outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler;
}

export interface AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler {
    allowHttp10?: boolean;
    http2Options?: outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options;
    httpRouterId?: string;
    rewriteRequestId?: boolean;
}

export interface AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options {
    maxConcurrentStreams?: number;
}

export interface AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler {
    backendGroupId?: string;
}

export interface AlbLoadBalancerLogOptions {
    disable?: boolean;
    discardRules?: outputs.AlbLoadBalancerLogOptionsDiscardRule[];
    logGroupId?: string;
}

export interface AlbLoadBalancerLogOptionsDiscardRule {
    discardPercent?: number;
    grpcCodes?: string[];
    httpCodeIntervals?: string[];
    httpCodes?: number[];
}

export interface AlbLoadBalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbTargetGroupTarget {
    ipAddress: string;
    privateIpv4Address?: boolean;
    subnetId?: string;
}

export interface AlbTargetGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbVirtualHostModifyRequestHeader {
    append?: string;
    name: string;
    remove?: boolean;
    replace?: string;
}

export interface AlbVirtualHostModifyResponseHeader {
    append?: string;
    name: string;
    remove?: boolean;
    replace?: string;
}

export interface AlbVirtualHostRoute {
    grpcRoute?: outputs.AlbVirtualHostRouteGrpcRoute;
    httpRoute?: outputs.AlbVirtualHostRouteHttpRoute;
    name?: string;
    routeOptions?: outputs.AlbVirtualHostRouteRouteOptions;
}

export interface AlbVirtualHostRouteGrpcRoute {
    grpcMatches?: outputs.AlbVirtualHostRouteGrpcRouteGrpcMatch[];
    grpcRouteAction?: outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteAction;
    grpcStatusResponseAction?: outputs.AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction;
}

export interface AlbVirtualHostRouteGrpcRouteGrpcMatch {
    fqmn?: outputs.AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn;
}

export interface AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn {
    exact?: string;
    prefix?: string;
    regex?: string;
}

export interface AlbVirtualHostRouteGrpcRouteGrpcRouteAction {
    autoHostRewrite?: boolean;
    backendGroupId: string;
    hostRewrite?: string;
    idleTimeout?: string;
    maxTimeout?: string;
}

export interface AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction {
    status?: string;
}

export interface AlbVirtualHostRouteHttpRoute {
    directResponseAction?: outputs.AlbVirtualHostRouteHttpRouteDirectResponseAction;
    httpMatches?: outputs.AlbVirtualHostRouteHttpRouteHttpMatch[];
    httpRouteAction?: outputs.AlbVirtualHostRouteHttpRouteHttpRouteAction;
    redirectAction?: outputs.AlbVirtualHostRouteHttpRouteRedirectAction;
}

export interface AlbVirtualHostRouteHttpRouteDirectResponseAction {
    body?: string;
    status?: number;
}

export interface AlbVirtualHostRouteHttpRouteHttpMatch {
    httpMethods?: string[];
    path?: outputs.AlbVirtualHostRouteHttpRouteHttpMatchPath;
}

export interface AlbVirtualHostRouteHttpRouteHttpMatchPath {
    exact?: string;
    prefix?: string;
    regex?: string;
}

export interface AlbVirtualHostRouteHttpRouteHttpRouteAction {
    autoHostRewrite?: boolean;
    backendGroupId: string;
    hostRewrite?: string;
    idleTimeout?: string;
    prefixRewrite?: string;
    timeout?: string;
    upgradeTypes?: string[];
}

export interface AlbVirtualHostRouteHttpRouteRedirectAction {
    removeQuery?: boolean;
    replaceHost?: string;
    replacePath?: string;
    replacePort?: number;
    replacePrefix?: string;
    replaceScheme?: string;
    responseCode?: string;
}

export interface AlbVirtualHostRouteOptions {
    rbac?: outputs.AlbVirtualHostRouteOptionsRbac;
    securityProfileId?: string;
}

export interface AlbVirtualHostRouteOptionsRbac {
    action?: string;
    principals: outputs.AlbVirtualHostRouteOptionsRbacPrincipal[];
}

export interface AlbVirtualHostRouteOptionsRbacPrincipal {
    andPrincipals: outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal[];
}

export interface AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal {
    any?: boolean;
    header?: outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeader;
    remoteIp?: string;
}

export interface AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeader {
    name: string;
    value?: outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValue;
}

export interface AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValue {
    exact?: string;
    prefix?: string;
    regex?: string;
}

export interface AlbVirtualHostRouteRouteOptions {
    rbac?: outputs.AlbVirtualHostRouteRouteOptionsRbac;
    securityProfileId?: string;
}

export interface AlbVirtualHostRouteRouteOptionsRbac {
    action?: string;
    principals: outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipal[];
}

export interface AlbVirtualHostRouteRouteOptionsRbacPrincipal {
    andPrincipals: outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal[];
}

export interface AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal {
    any?: boolean;
    header?: outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeader;
    remoteIp?: string;
}

export interface AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeader {
    name: string;
    value?: outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValue;
}

export interface AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValue {
    exact?: string;
    prefix?: string;
    regex?: string;
}

export interface AlbVirtualHostTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApiGatewayCanary {
    variables?: {[key: string]: string};
    weight?: number;
}

export interface ApiGatewayConnectivity {
    networkId: string;
}

export interface ApiGatewayCustomDomain {
    certificateId: string;
    domainId: string;
    fqdn: string;
}

export interface ApiGatewayLogOptions {
    disabled?: boolean;
    folderId?: string;
    logGroupId?: string;
    minLevel?: string;
}

export interface ApiGatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AuditTrailsTrailDataStreamDestination {
    databaseId: string;
    streamName: string;
}

export interface AuditTrailsTrailFilter {
    eventFilters?: outputs.AuditTrailsTrailFilterEventFilter[];
    pathFilter?: outputs.AuditTrailsTrailFilterPathFilter;
}

export interface AuditTrailsTrailFilterEventFilter {
    categories: outputs.AuditTrailsTrailFilterEventFilterCategory[];
    pathFilter: outputs.AuditTrailsTrailFilterEventFilterPathFilter;
    service: string;
}

export interface AuditTrailsTrailFilterEventFilterCategory {
    plane: string;
    type: string;
}

export interface AuditTrailsTrailFilterEventFilterPathFilter {
    anyFilter?: outputs.AuditTrailsTrailFilterEventFilterPathFilterAnyFilter;
    someFilter?: outputs.AuditTrailsTrailFilterEventFilterPathFilterSomeFilter;
}

export interface AuditTrailsTrailFilterEventFilterPathFilterAnyFilter {
    resourceId: string;
    resourceType: string;
}

export interface AuditTrailsTrailFilterEventFilterPathFilterSomeFilter {
    anyFilters: outputs.AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter[];
    resourceId: string;
    resourceType: string;
}

export interface AuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter {
    resourceId: string;
    resourceType: string;
}

export interface AuditTrailsTrailFilterPathFilter {
    anyFilter?: outputs.AuditTrailsTrailFilterPathFilterAnyFilter;
    someFilter?: outputs.AuditTrailsTrailFilterPathFilterSomeFilter;
}

export interface AuditTrailsTrailFilterPathFilterAnyFilter {
    resourceId: string;
    resourceType: string;
}

export interface AuditTrailsTrailFilterPathFilterSomeFilter {
    anyFilters: outputs.AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter[];
    resourceId: string;
    resourceType: string;
}

export interface AuditTrailsTrailFilterPathFilterSomeFilterAnyFilter {
    resourceId: string;
    resourceType: string;
}

export interface AuditTrailsTrailLoggingDestination {
    logGroupId: string;
}

export interface AuditTrailsTrailStorageDestination {
    bucketName: string;
    objectPrefix?: string;
}

export interface AuditTrailsTrailTimeouts {
    default?: string;
}

export interface BackupPolicyBindingsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BackupPolicyReattempts {
    enabled?: boolean;
    interval?: string;
    maxAttempts?: number;
}

export interface BackupPolicyRetention {
    afterBackup?: boolean;
    rules?: outputs.BackupPolicyRetentionRule[];
}

export interface BackupPolicyRetentionRule {
    maxAge?: string;
    maxCount?: number;
    repeatPeriods?: string[];
}

export interface BackupPolicyScheduling {
    backupSets?: outputs.BackupPolicySchedulingBackupSet[];
    enabled?: boolean;
    /**
     * @deprecated Deprecated
     */
    executeByInterval?: number;
    /**
     * @deprecated Deprecated
     */
    executeByTimes?: outputs.BackupPolicySchedulingExecuteByTime[];
    maxParallelBackups?: number;
    randomMaxDelay?: string;
    scheme?: string;
    weeklyBackupDay?: string;
}

export interface BackupPolicySchedulingBackupSet {
    executeByInterval?: number;
    executeByTimes?: outputs.BackupPolicySchedulingBackupSetExecuteByTime[];
    type?: string;
}

export interface BackupPolicySchedulingBackupSetExecuteByTime {
    includeLastDayOfMonth?: boolean;
    monthdays?: number[];
    months?: number[];
    repeatAts?: string[];
    repeatEvery?: string;
    type: string;
    weekdays?: string[];
}

export interface BackupPolicySchedulingExecuteByTime {
    includeLastDayOfMonth?: boolean;
    monthdays?: number[];
    months?: number[];
    repeatAts?: string[];
    repeatEvery?: string;
    type: string;
    weekdays?: string[];
}

export interface BackupPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BackupPolicyVmSnapshotReattempts {
    enabled?: boolean;
    interval?: string;
    maxAttempts?: number;
}

export interface CdnOriginGroupOrigin {
    backup?: boolean;
    enabled?: boolean;
    originGroupId: number;
    source: string;
}

export interface CdnOriginGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CdnResourceOptions {
    allowedHttpMethods: string[];
    browserCacheSettings: number;
    cacheHttpHeaders: string[];
    cors: string[];
    customHostHeader: string;
    customServerName: string;
    disableCache: boolean;
    disableProxyForceRanges: boolean;
    edgeCacheSettings: number;
    enableIpUrlSigning: boolean;
    fetchedCompressed: boolean;
    forwardHostHeader: boolean;
    gzipOn: boolean;
    ignoreCookie: boolean;
    ignoreQueryParams: boolean;
    ipAddressAcl?: outputs.CdnResourceOptionsIpAddressAcl;
    proxyCacheMethodsSet: boolean;
    queryParamsBlacklists: string[];
    queryParamsWhitelists: string[];
    redirectHttpToHttps: boolean;
    redirectHttpsToHttp: boolean;
    secureKey: string;
    slice: boolean;
    staticRequestHeaders: {[key: string]: string};
    staticResponseHeaders: {[key: string]: string};
}

export interface CdnResourceOptionsIpAddressAcl {
    exceptedValues: string[];
    policyType: string;
}

export interface CdnResourceSslCertificate {
    certificateManagerId?: string;
    status: string;
    type: string;
}

export interface CdnResourceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CmCertificateChallenge {
    createdAt: string;
    dnsName: string;
    dnsType: string;
    dnsValue: string;
    domain: string;
    httpContent: string;
    httpUrl: string;
    message: string;
    type: string;
    updatedAt: string;
}

export interface CmCertificateManaged {
    challengeCount?: number;
    challengeType: string;
}

export interface CmCertificateSelfManaged {
    certificate: string;
    privateKey?: string;
    privateKeyLockboxSecret?: outputs.CmCertificateSelfManagedPrivateKeyLockboxSecret;
}

export interface CmCertificateSelfManagedPrivateKeyLockboxSecret {
    id: string;
    key: string;
}

export interface CmCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ComputeDiskDiskPlacementPolicy {
    diskPlacementGroupId: string;
}

export interface ComputeDiskPlacementGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeDiskTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeFilesystemTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeGpuClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeImageTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeInstanceBootDisk {
    autoDelete?: boolean;
    deviceName: string;
    diskId: string;
    initializeParams?: outputs.ComputeInstanceBootDiskInitializeParams;
    mode: string;
}

export interface ComputeInstanceBootDiskInitializeParams {
    blockSize: number;
    description: string;
    imageId: string;
    name: string;
    size: number;
    snapshotId: string;
    type?: string;
}

export interface ComputeInstanceFilesystem {
    deviceName: string;
    filesystemId: string;
    mode?: string;
}

export interface ComputeInstanceGroupAllocationPolicy {
    instanceTagsPools?: outputs.ComputeInstanceGroupAllocationPolicyInstanceTagsPool[];
    zones: string[];
}

export interface ComputeInstanceGroupAllocationPolicyInstanceTagsPool {
    tags: string[];
    zone: string;
}

export interface ComputeInstanceGroupApplicationLoadBalancer {
    ignoreHealthChecks?: boolean;
    maxOpeningTrafficDuration?: number;
    statusMessage: string;
    targetGroupDescription?: string;
    targetGroupId: string;
    targetGroupLabels?: {[key: string]: string};
    targetGroupName?: string;
}

export interface ComputeInstanceGroupDeployPolicy {
    maxCreating?: number;
    maxDeleting?: number;
    maxExpansion: number;
    maxUnavailable: number;
    startupDuration?: number;
    strategy: string;
}

export interface ComputeInstanceGroupHealthCheck {
    healthyThreshold?: number;
    httpOptions?: outputs.ComputeInstanceGroupHealthCheckHttpOptions;
    interval?: number;
    tcpOptions?: outputs.ComputeInstanceGroupHealthCheckTcpOptions;
    timeout?: number;
    unhealthyThreshold?: number;
}

export interface ComputeInstanceGroupHealthCheckHttpOptions {
    path: string;
    port: number;
}

export interface ComputeInstanceGroupHealthCheckTcpOptions {
    port: number;
}

export interface ComputeInstanceGroupInstance {
    fqdn: string;
    instanceId: string;
    instanceTag: string;
    name: string;
    networkInterfaces: outputs.ComputeInstanceGroupInstanceNetworkInterface[];
    status: string;
    statusChangedAt: string;
    statusMessage: string;
    zoneId: string;
}

export interface ComputeInstanceGroupInstanceNetworkInterface {
    index: number;
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    macAddress: string;
    nat: boolean;
    natIpAddress: string;
    natIpVersion: string;
    subnetId: string;
}

export interface ComputeInstanceGroupInstanceTemplate {
    bootDisk: outputs.ComputeInstanceGroupInstanceTemplateBootDisk;
    description?: string;
    filesystems?: outputs.ComputeInstanceGroupInstanceTemplateFilesystem[];
    hostname?: string;
    labels: {[key: string]: string};
    metadata: {[key: string]: string};
    metadataOptions?: outputs.ComputeInstanceGroupInstanceTemplateMetadataOptions;
    name?: string;
    networkInterfaces: outputs.ComputeInstanceGroupInstanceTemplateNetworkInterface[];
    networkSettings?: outputs.ComputeInstanceGroupInstanceTemplateNetworkSetting[];
    placementPolicy?: outputs.ComputeInstanceGroupInstanceTemplatePlacementPolicy;
    platformId?: string;
    resources: outputs.ComputeInstanceGroupInstanceTemplateResources;
    schedulingPolicy?: outputs.ComputeInstanceGroupInstanceTemplateSchedulingPolicy;
    secondaryDisks?: outputs.ComputeInstanceGroupInstanceTemplateSecondaryDisk[];
    serviceAccountId?: string;
}

export interface ComputeInstanceGroupInstanceTemplateBootDisk {
    deviceName: string;
    diskId?: string;
    initializeParams?: outputs.ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams;
    mode?: string;
    name?: string;
}

export interface ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams {
    description?: string;
    imageId: string;
    size: number;
    snapshotId: string;
    type?: string;
}

export interface ComputeInstanceGroupInstanceTemplateFilesystem {
    deviceName?: string;
    filesystemId: string;
    mode?: string;
}

export interface ComputeInstanceGroupInstanceTemplateMetadataOptions {
    awsV1HttpEndpoint: number;
    awsV1HttpToken: number;
    gceHttpEndpoint: number;
    gceHttpToken: number;
}

export interface ComputeInstanceGroupInstanceTemplateNetworkInterface {
    dnsRecords?: outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord[];
    ipAddress: string;
    ipv4?: boolean;
    ipv6: boolean;
    ipv6Address: string;
    ipv6DnsRecords?: outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord[];
    nat: boolean;
    natDnsRecords?: outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord[];
    natIpAddress?: string;
    networkId?: string;
    securityGroupIds?: string[];
    subnetIds?: string[];
}

export interface ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr: boolean;
    ttl?: number;
}

export interface ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr: boolean;
    ttl?: number;
}

export interface ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr: boolean;
    ttl?: number;
}

export interface ComputeInstanceGroupInstanceTemplateNetworkSetting {
    type?: string;
}

export interface ComputeInstanceGroupInstanceTemplatePlacementPolicy {
    placementGroupId: string;
}

export interface ComputeInstanceGroupInstanceTemplateResources {
    coreFraction?: number;
    cores: number;
    gpus?: number;
    memory: number;
}

export interface ComputeInstanceGroupInstanceTemplateSchedulingPolicy {
    preemptible?: boolean;
}

export interface ComputeInstanceGroupInstanceTemplateSecondaryDisk {
    deviceName?: string;
    diskId?: string;
    initializeParams?: outputs.ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams;
    mode?: string;
    name?: string;
}

export interface ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams {
    description?: string;
    imageId?: string;
    size?: number;
    snapshotId?: string;
    type?: string;
}

export interface ComputeInstanceGroupLoadBalancer {
    ignoreHealthChecks?: boolean;
    maxOpeningTrafficDuration?: number;
    statusMessage: string;
    targetGroupDescription?: string;
    targetGroupId: string;
    targetGroupLabels?: {[key: string]: string};
    targetGroupName?: string;
}

export interface ComputeInstanceGroupScalePolicy {
    autoScale?: outputs.ComputeInstanceGroupScalePolicyAutoScale;
    fixedScale?: outputs.ComputeInstanceGroupScalePolicyFixedScale;
    testAutoScale?: outputs.ComputeInstanceGroupScalePolicyTestAutoScale;
}

export interface ComputeInstanceGroupScalePolicyAutoScale {
    autoScaleType?: string;
    cpuUtilizationTarget?: number;
    customRules?: outputs.ComputeInstanceGroupScalePolicyAutoScaleCustomRule[];
    initialSize: number;
    maxSize?: number;
    measurementDuration: number;
    minZoneSize?: number;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface ComputeInstanceGroupScalePolicyAutoScaleCustomRule {
    folderId?: string;
    labels?: {[key: string]: string};
    metricName: string;
    metricType: string;
    ruleType: string;
    service?: string;
    target: number;
}

export interface ComputeInstanceGroupScalePolicyFixedScale {
    size: number;
}

export interface ComputeInstanceGroupScalePolicyTestAutoScale {
    autoScaleType?: string;
    cpuUtilizationTarget?: number;
    customRules?: outputs.ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule[];
    initialSize: number;
    maxSize?: number;
    measurementDuration: number;
    minZoneSize?: number;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule {
    folderId?: string;
    labels?: {[key: string]: string};
    metricName: string;
    metricType: string;
    ruleType: string;
    service?: string;
    target: number;
}

export interface ComputeInstanceGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeInstanceLocalDisk {
    deviceName: string;
    sizeBytes: number;
}

export interface ComputeInstanceMetadataOptions {
    awsV1HttpEndpoint: number;
    awsV1HttpToken: number;
    gceHttpEndpoint: number;
    gceHttpToken: number;
}

export interface ComputeInstanceNetworkInterface {
    dnsRecords?: outputs.ComputeInstanceNetworkInterfaceDnsRecord[];
    index: number;
    ipAddress: string;
    ipv4?: boolean;
    ipv6: boolean;
    ipv6Address: string;
    ipv6DnsRecords?: outputs.ComputeInstanceNetworkInterfaceIpv6DnsRecord[];
    macAddress: string;
    nat?: boolean;
    natDnsRecords?: outputs.ComputeInstanceNetworkInterfaceNatDnsRecord[];
    natIpAddress: string;
    natIpVersion: string;
    securityGroupIds: string[];
    subnetId: string;
}

export interface ComputeInstanceNetworkInterfaceDnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface ComputeInstanceNetworkInterfaceIpv6DnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface ComputeInstanceNetworkInterfaceNatDnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface ComputeInstancePlacementPolicy {
    hostAffinityRules: outputs.ComputeInstancePlacementPolicyHostAffinityRule[];
    placementGroupId?: string;
    placementGroupPartition?: number;
}

export interface ComputeInstancePlacementPolicyHostAffinityRule {
    key: string;
    op: string;
    values: string[];
}

export interface ComputeInstanceResources {
    coreFraction?: number;
    cores: number;
    gpus?: number;
    memory: number;
}

export interface ComputeInstanceSchedulingPolicy {
    preemptible?: boolean;
}

export interface ComputeInstanceSecondaryDisk {
    autoDelete?: boolean;
    deviceName: string;
    diskId: string;
    mode?: string;
}

export interface ComputeInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputePlacementGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeSnapshotScheduleSchedulePolicy {
    expression?: string;
    startAt: string;
}

export interface ComputeSnapshotScheduleSnapshotSpec {
    description?: string;
    labels?: {[key: string]: string};
}

export interface ComputeSnapshotScheduleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeSnapshotTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ContainerRegistryIamBindingTimeouts {
    default?: string;
}

export interface ContainerRegistryIpPermissionTimeouts {
    default?: string;
}

export interface ContainerRegistryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ContainerRepositoryIamBindingTimeouts {
    default?: string;
}

export interface ContainerRepositoryLifecyclePolicyRule {
    description: string;
    expirePeriod?: string;
    retainedTop: number;
    tagRegexp?: string;
    untagged: boolean;
}

export interface ContainerRepositoryLifecyclePolicyTimeouts {
    default?: string;
}

export interface ContainerRepositoryTimeouts {
    create?: string;
    delete?: string;
}

export interface DataprocClusterClusterConfig {
    hadoop?: outputs.DataprocClusterClusterConfigHadoop;
    subclusterSpecs: outputs.DataprocClusterClusterConfigSubclusterSpec[];
    versionId: string;
}

export interface DataprocClusterClusterConfigHadoop {
    initializationActions?: outputs.DataprocClusterClusterConfigHadoopInitializationAction[];
    properties?: {[key: string]: string};
    services?: string[];
    sshPublicKeys?: string[];
}

export interface DataprocClusterClusterConfigHadoopInitializationAction {
    args: string[];
    timeout: string;
    uri: string;
}

export interface DataprocClusterClusterConfigSubclusterSpec {
    assignPublicIp?: boolean;
    autoscalingConfig?: outputs.DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig;
    hostsCount: number;
    id: string;
    name: string;
    resources: outputs.DataprocClusterClusterConfigSubclusterSpecResources;
    role: string;
    subnetId: string;
}

export interface DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig {
    cpuUtilizationTarget: string;
    decommissionTimeout: string;
    maxHostsCount: number;
    measurementDuration: string;
    preemptible?: boolean;
    stabilizationDuration: string;
    warmupDuration: string;
}

export interface DataprocClusterClusterConfigSubclusterSpecResources {
    diskSize: number;
    diskTypeId?: string;
    resourcePresetId: string;
}

export interface DataprocClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DatasphereCommunityTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface DatasphereProjectLimits {
    balance: number;
    maxUnitsPerExecution: number;
    maxUnitsPerHour: number;
}

export interface DatasphereProjectSettings {
    commitMode: string;
    dataProcClusterId: string;
    defaultFolderId: string;
    ide: string;
    securityGroupIds?: string[];
    serviceAccountId: string;
    staleExecTimeoutMode: string;
    subnetId: string;
}

export interface DatasphereProjectTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface DatatransferEndpointSettings {
    clickhouseSource?: outputs.DatatransferEndpointSettingsClickhouseSource;
    clickhouseTarget?: outputs.DatatransferEndpointSettingsClickhouseTarget;
    kafkaSource?: outputs.DatatransferEndpointSettingsKafkaSource;
    kafkaTarget?: outputs.DatatransferEndpointSettingsKafkaTarget;
    metrikaSource?: outputs.DatatransferEndpointSettingsMetrikaSource;
    mongoSource?: outputs.DatatransferEndpointSettingsMongoSource;
    mongoTarget?: outputs.DatatransferEndpointSettingsMongoTarget;
    mysqlSource?: outputs.DatatransferEndpointSettingsMysqlSource;
    mysqlTarget?: outputs.DatatransferEndpointSettingsMysqlTarget;
    postgresSource?: outputs.DatatransferEndpointSettingsPostgresSource;
    postgresTarget?: outputs.DatatransferEndpointSettingsPostgresTarget;
    ydbSource?: outputs.DatatransferEndpointSettingsYdbSource;
    ydbTarget?: outputs.DatatransferEndpointSettingsYdbTarget;
    ydsSource?: outputs.DatatransferEndpointSettingsYdsSource;
    ydsTarget?: outputs.DatatransferEndpointSettingsYdsTarget;
}

export interface DatatransferEndpointSettingsClickhouseSource {
    clickhouseClusterName: string;
    connection?: outputs.DatatransferEndpointSettingsClickhouseSourceConnection;
    excludeTables: string[];
    includeTables: string[];
    securityGroups: string[];
    subnetId: string;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnection {
    connectionOptions?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions {
    database: string;
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise;
    password?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPassword;
    user: string;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise {
    httpPort: number;
    nativePort: number;
    shards?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShard[];
    tlsMode?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShard {
    hosts: string[];
    name: string;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsClickhouseTarget {
    altNames?: outputs.DatatransferEndpointSettingsClickhouseTargetAltName[];
    cleanupPolicy: string;
    clickhouseClusterName: string;
    connection?: outputs.DatatransferEndpointSettingsClickhouseTargetConnection;
    securityGroups: string[];
    sharding?: outputs.DatatransferEndpointSettingsClickhouseTargetSharding;
    subnetId: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetAltName {
    fromName: string;
    toName: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnection {
    connectionOptions?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions {
    database: string;
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise;
    password?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPassword;
    user: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise {
    httpPort: number;
    nativePort: number;
    shards?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShard[];
    tlsMode?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShard {
    hosts: string[];
    name: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetSharding {
    columnValueHash?: outputs.DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash;
    customMapping?: outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping;
    roundRobin?: outputs.DatatransferEndpointSettingsClickhouseTargetShardingRoundRobin;
    transferId?: outputs.DatatransferEndpointSettingsClickhouseTargetShardingTransferId;
}

export interface DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash {
    columnName: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetShardingCustomMapping {
    columnName: string;
    mappings?: outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping[];
}

export interface DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMapping {
    columnValue?: outputs.DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue;
    shardName: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetShardingCustomMappingMappingColumnValue {
    stringValue: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetShardingRoundRobin {
}

export interface DatatransferEndpointSettingsClickhouseTargetShardingTransferId {
}

export interface DatatransferEndpointSettingsKafkaSource {
    auth?: outputs.DatatransferEndpointSettingsKafkaSourceAuth;
    connection?: outputs.DatatransferEndpointSettingsKafkaSourceConnection;
    parser?: outputs.DatatransferEndpointSettingsKafkaSourceParser;
    securityGroups: string[];
    topicName: string;
    topicNames: string[];
    transformer?: outputs.DatatransferEndpointSettingsKafkaSourceTransformer;
}

export interface DatatransferEndpointSettingsKafkaSourceAuth {
    noAuth?: outputs.DatatransferEndpointSettingsKafkaSourceAuthNoAuth;
    sasl?: outputs.DatatransferEndpointSettingsKafkaSourceAuthSasl;
}

export interface DatatransferEndpointSettingsKafkaSourceAuthNoAuth {
}

export interface DatatransferEndpointSettingsKafkaSourceAuthSasl {
    mechanism: string;
    password?: outputs.DatatransferEndpointSettingsKafkaSourceAuthSaslPassword;
    user: string;
}

export interface DatatransferEndpointSettingsKafkaSourceAuthSaslPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsKafkaSourceConnection {
    clusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremise;
}

export interface DatatransferEndpointSettingsKafkaSourceConnectionOnPremise {
    brokerUrls: string[];
    subnetId: string;
    tlsMode?: outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsKafkaSourceConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsKafkaSourceParser {
    auditTrailsV1Parser?: outputs.DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1Parser;
    cloudLoggingParser?: outputs.DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParser;
    jsonParser?: outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParser;
    tskvParser?: outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParser;
}

export interface DatatransferEndpointSettingsKafkaSourceParserAuditTrailsV1Parser {
}

export interface DatatransferEndpointSettingsKafkaSourceParserCloudLoggingParser {
}

export interface DatatransferEndpointSettingsKafkaSourceParserJsonParser {
    addRestColumn: boolean;
    dataSchema?: outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema;
    nullKeysAllowed: boolean;
    unescapeStringValues: boolean;
}

export interface DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchema {
    fields?: outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFields;
    jsonFields?: string;
}

export interface DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFields {
    fields?: outputs.DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsField[];
}

export interface DatatransferEndpointSettingsKafkaSourceParserJsonParserDataSchemaFieldsField {
    key: boolean;
    name: string;
    path: string;
    required: boolean;
    type: string;
}

export interface DatatransferEndpointSettingsKafkaSourceParserTskvParser {
    addRestColumn: boolean;
    dataSchema?: outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema;
    nullKeysAllowed: boolean;
    unescapeStringValues: boolean;
}

export interface DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchema {
    fields?: outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFields;
    jsonFields?: string;
}

export interface DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFields {
    fields?: outputs.DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsField[];
}

export interface DatatransferEndpointSettingsKafkaSourceParserTskvParserDataSchemaFieldsField {
    key: boolean;
    name: string;
    path: string;
    required: boolean;
    type: string;
}

export interface DatatransferEndpointSettingsKafkaSourceTransformer {
    bufferFlushInterval: string;
    bufferSize: string;
    cloudFunction: string;
    invocationTimeout: string;
    numberOfRetries: number;
    serviceAccountId: string;
}

export interface DatatransferEndpointSettingsKafkaTarget {
    auth?: outputs.DatatransferEndpointSettingsKafkaTargetAuth;
    connection?: outputs.DatatransferEndpointSettingsKafkaTargetConnection;
    securityGroups: string[];
    serializer?: outputs.DatatransferEndpointSettingsKafkaTargetSerializer;
    topicSettings?: outputs.DatatransferEndpointSettingsKafkaTargetTopicSettings;
}

export interface DatatransferEndpointSettingsKafkaTargetAuth {
    noAuth?: outputs.DatatransferEndpointSettingsKafkaTargetAuthNoAuth;
    sasl?: outputs.DatatransferEndpointSettingsKafkaTargetAuthSasl;
}

export interface DatatransferEndpointSettingsKafkaTargetAuthNoAuth {
}

export interface DatatransferEndpointSettingsKafkaTargetAuthSasl {
    mechanism: string;
    password?: outputs.DatatransferEndpointSettingsKafkaTargetAuthSaslPassword;
    user: string;
}

export interface DatatransferEndpointSettingsKafkaTargetAuthSaslPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsKafkaTargetConnection {
    clusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremise;
}

export interface DatatransferEndpointSettingsKafkaTargetConnectionOnPremise {
    brokerUrls: string[];
    subnetId: string;
    tlsMode?: outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsKafkaTargetConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsKafkaTargetSerializer {
    serializerAuto?: outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerAuto;
    serializerDebezium?: outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium;
    serializerJson?: outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerJson;
}

export interface DatatransferEndpointSettingsKafkaTargetSerializerSerializerAuto {
}

export interface DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebezium {
    serializerParameters?: outputs.DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameter[];
}

export interface DatatransferEndpointSettingsKafkaTargetSerializerSerializerDebeziumSerializerParameter {
    key: string;
    value: string;
}

export interface DatatransferEndpointSettingsKafkaTargetSerializerSerializerJson {
}

export interface DatatransferEndpointSettingsKafkaTargetTopicSettings {
    topic?: outputs.DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic;
    topicPrefix?: string;
}

export interface DatatransferEndpointSettingsKafkaTargetTopicSettingsTopic {
    saveTxOrder: boolean;
    topicName: string;
}

export interface DatatransferEndpointSettingsMetrikaSource {
    counterIds: number[];
    streams?: outputs.DatatransferEndpointSettingsMetrikaSourceStream[];
    token?: outputs.DatatransferEndpointSettingsMetrikaSourceToken;
}

export interface DatatransferEndpointSettingsMetrikaSourceStream {
    columns: string[];
    type: string;
}

export interface DatatransferEndpointSettingsMetrikaSourceToken {
    raw: string;
}

export interface DatatransferEndpointSettingsMongoSource {
    collections?: outputs.DatatransferEndpointSettingsMongoSourceCollection[];
    connection?: outputs.DatatransferEndpointSettingsMongoSourceConnection;
    excludedCollections?: outputs.DatatransferEndpointSettingsMongoSourceExcludedCollection[];
    secondaryPreferredMode: boolean;
    securityGroups: string[];
    subnetId: string;
}

export interface DatatransferEndpointSettingsMongoSourceCollection {
    collectionName: string;
    databaseName: string;
}

export interface DatatransferEndpointSettingsMongoSourceConnection {
    connectionOptions?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions {
    authSource: string;
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise;
    password?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPassword;
    user: string;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise {
    hosts: string[];
    port: number;
    replicaSet: string;
    tlsMode?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsMongoSourceExcludedCollection {
    collectionName: string;
    databaseName: string;
}

export interface DatatransferEndpointSettingsMongoTarget {
    cleanupPolicy: string;
    connection?: outputs.DatatransferEndpointSettingsMongoTargetConnection;
    database: string;
    securityGroups: string[];
    subnetId: string;
}

export interface DatatransferEndpointSettingsMongoTargetConnection {
    connectionOptions?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions {
    authSource: string;
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise;
    password?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPassword;
    user: string;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise {
    hosts: string[];
    port: number;
    replicaSet: string;
    tlsMode?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsMysqlSource {
    connection?: outputs.DatatransferEndpointSettingsMysqlSourceConnection;
    database: string;
    excludeTablesRegexes: string[];
    includeTablesRegexes: string[];
    objectTransferSettings?: outputs.DatatransferEndpointSettingsMysqlSourceObjectTransferSettings;
    password?: outputs.DatatransferEndpointSettingsMysqlSourcePassword;
    securityGroups: string[];
    serviceDatabase: string;
    timezone: string;
    user: string;
}

export interface DatatransferEndpointSettingsMysqlSourceConnection {
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremise;
}

export interface DatatransferEndpointSettingsMysqlSourceConnectionOnPremise {
    hosts: string[];
    port: number;
    subnetId: string;
    tlsMode?: outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsMysqlSourceObjectTransferSettings {
    routine: string;
    tables: string;
    trigger: string;
    view: string;
}

export interface DatatransferEndpointSettingsMysqlSourcePassword {
    raw: string;
}

export interface DatatransferEndpointSettingsMysqlTarget {
    cleanupPolicy: string;
    connection?: outputs.DatatransferEndpointSettingsMysqlTargetConnection;
    database: string;
    password?: outputs.DatatransferEndpointSettingsMysqlTargetPassword;
    securityGroups: string[];
    serviceDatabase: string;
    skipConstraintChecks: boolean;
    sqlMode: string;
    timezone: string;
    user: string;
}

export interface DatatransferEndpointSettingsMysqlTargetConnection {
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremise;
}

export interface DatatransferEndpointSettingsMysqlTargetConnectionOnPremise {
    hosts: string[];
    port: number;
    subnetId: string;
    tlsMode?: outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsMysqlTargetPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsPostgresSource {
    connection?: outputs.DatatransferEndpointSettingsPostgresSourceConnection;
    database: string;
    excludeTables: string[];
    includeTables: string[];
    objectTransferSettings?: outputs.DatatransferEndpointSettingsPostgresSourceObjectTransferSettings;
    password?: outputs.DatatransferEndpointSettingsPostgresSourcePassword;
    securityGroups: string[];
    serviceSchema: string;
    slotGigabyteLagLimit: number;
    user: string;
}

export interface DatatransferEndpointSettingsPostgresSourceConnection {
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremise;
}

export interface DatatransferEndpointSettingsPostgresSourceConnectionOnPremise {
    hosts: string[];
    port: number;
    subnetId: string;
    tlsMode?: outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsPostgresSourceObjectTransferSettings {
    cast: string;
    collation: string;
    constraint: string;
    defaultValues: string;
    fkConstraint: string;
    function: string;
    index: string;
    materializedView: string;
    policy: string;
    primaryKey: string;
    rule: string;
    sequence: string;
    sequenceOwnedBy: string;
    sequenceSet: string;
    table: string;
    trigger: string;
    type: string;
    view: string;
}

export interface DatatransferEndpointSettingsPostgresSourcePassword {
    raw: string;
}

export interface DatatransferEndpointSettingsPostgresTarget {
    cleanupPolicy: string;
    connection?: outputs.DatatransferEndpointSettingsPostgresTargetConnection;
    database: string;
    password?: outputs.DatatransferEndpointSettingsPostgresTargetPassword;
    securityGroups: string[];
    user: string;
}

export interface DatatransferEndpointSettingsPostgresTargetConnection {
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremise;
}

export interface DatatransferEndpointSettingsPostgresTargetConnectionOnPremise {
    hosts: string[];
    port: number;
    subnetId: string;
    tlsMode?: outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsPostgresTargetPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsYdbSource {
    changefeedCustomName: string;
    database: string;
    instance: string;
    paths: string[];
    saKeyContent: string;
    securityGroups: string[];
    serviceAccountId: string;
    subnetId: string;
}

export interface DatatransferEndpointSettingsYdbTarget {
    cleanupPolicy: string;
    database: string;
    defaultCompression: string;
    instance: string;
    isTableColumnOriented: boolean;
    path: string;
    saKeyContent: string;
    securityGroups: string[];
    serviceAccountId: string;
    subnetId: string;
}

export interface DatatransferEndpointSettingsYdsSource {
    allowTtlRewind: boolean;
    consumer: string;
    database: string;
    endpoint: string;
    parser?: outputs.DatatransferEndpointSettingsYdsSourceParser;
    securityGroups: string[];
    serviceAccountId: string;
    stream: string;
    subnetId: string;
    supportedCodecs: string[];
}

export interface DatatransferEndpointSettingsYdsSourceParser {
    auditTrailsV1Parser?: outputs.DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1Parser;
    cloudLoggingParser?: outputs.DatatransferEndpointSettingsYdsSourceParserCloudLoggingParser;
    jsonParser?: outputs.DatatransferEndpointSettingsYdsSourceParserJsonParser;
    tskvParser?: outputs.DatatransferEndpointSettingsYdsSourceParserTskvParser;
}

export interface DatatransferEndpointSettingsYdsSourceParserAuditTrailsV1Parser {
}

export interface DatatransferEndpointSettingsYdsSourceParserCloudLoggingParser {
}

export interface DatatransferEndpointSettingsYdsSourceParserJsonParser {
    addRestColumn: boolean;
    dataSchema?: outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema;
    nullKeysAllowed: boolean;
    unescapeStringValues: boolean;
}

export interface DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchema {
    fields?: outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFields;
    jsonFields?: string;
}

export interface DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFields {
    fields?: outputs.DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsField[];
}

export interface DatatransferEndpointSettingsYdsSourceParserJsonParserDataSchemaFieldsField {
    key: boolean;
    name: string;
    path: string;
    required: boolean;
    type: string;
}

export interface DatatransferEndpointSettingsYdsSourceParserTskvParser {
    addRestColumn: boolean;
    dataSchema?: outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema;
    nullKeysAllowed: boolean;
    unescapeStringValues: boolean;
}

export interface DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchema {
    fields?: outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFields;
    jsonFields?: string;
}

export interface DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFields {
    fields?: outputs.DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsField[];
}

export interface DatatransferEndpointSettingsYdsSourceParserTskvParserDataSchemaFieldsField {
    key: boolean;
    name: string;
    path: string;
    required: boolean;
    type: string;
}

export interface DatatransferEndpointSettingsYdsTarget {
    database: string;
    endpoint: string;
    saveTxOrder: boolean;
    securityGroups: string[];
    serializer?: outputs.DatatransferEndpointSettingsYdsTargetSerializer;
    serviceAccountId: string;
    stream: string;
    subnetId: string;
}

export interface DatatransferEndpointSettingsYdsTargetSerializer {
    serializerAuto?: outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerAuto;
    serializerDebezium?: outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium;
    serializerJson?: outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerJson;
}

export interface DatatransferEndpointSettingsYdsTargetSerializerSerializerAuto {
}

export interface DatatransferEndpointSettingsYdsTargetSerializerSerializerDebezium {
    serializerParameters?: outputs.DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameter[];
}

export interface DatatransferEndpointSettingsYdsTargetSerializerSerializerDebeziumSerializerParameter {
    key: string;
    value: string;
}

export interface DatatransferEndpointSettingsYdsTargetSerializerSerializerJson {
}

export interface DatatransferTransferRuntime {
    ycRuntime?: outputs.DatatransferTransferRuntimeYcRuntime;
}

export interface DatatransferTransferRuntimeYcRuntime {
    jobCount: number;
    uploadShardParams?: outputs.DatatransferTransferRuntimeYcRuntimeUploadShardParams;
}

export interface DatatransferTransferRuntimeYcRuntimeUploadShardParams {
    jobCount: number;
    processCount: number;
}

export interface DatatransferTransferTransformation {
    transformers?: outputs.DatatransferTransferTransformationTransformer[];
}

export interface DatatransferTransferTransformationTransformer {
    convertToString?: outputs.DatatransferTransferTransformationTransformerConvertToString;
    filterColumns?: outputs.DatatransferTransferTransformationTransformerFilterColumns;
    filterRows?: outputs.DatatransferTransferTransformationTransformerFilterRows;
    maskField?: outputs.DatatransferTransferTransformationTransformerMaskField;
    renameTables?: outputs.DatatransferTransferTransformationTransformerRenameTables;
    replacePrimaryKey?: outputs.DatatransferTransferTransformationTransformerReplacePrimaryKey;
    sharderTransformer?: outputs.DatatransferTransferTransformationTransformerSharderTransformer;
    tableSplitterTransformer?: outputs.DatatransferTransferTransformationTransformerTableSplitterTransformer;
}

export interface DatatransferTransferTransformationTransformerConvertToString {
    columns?: outputs.DatatransferTransferTransformationTransformerConvertToStringColumns;
    tables?: outputs.DatatransferTransferTransformationTransformerConvertToStringTables;
}

export interface DatatransferTransferTransformationTransformerConvertToStringColumns {
    excludeColumns?: string[];
    includeColumns?: string[];
}

export interface DatatransferTransferTransformationTransformerConvertToStringTables {
    excludeTables?: string[];
    includeTables?: string[];
}

export interface DatatransferTransferTransformationTransformerFilterColumns {
    columns?: outputs.DatatransferTransferTransformationTransformerFilterColumnsColumns;
    tables?: outputs.DatatransferTransferTransformationTransformerFilterColumnsTables;
}

export interface DatatransferTransferTransformationTransformerFilterColumnsColumns {
    excludeColumns?: string[];
    includeColumns?: string[];
}

export interface DatatransferTransferTransformationTransformerFilterColumnsTables {
    excludeTables?: string[];
    includeTables?: string[];
}

export interface DatatransferTransferTransformationTransformerFilterRows {
    filter?: string;
    tables?: outputs.DatatransferTransferTransformationTransformerFilterRowsTables;
}

export interface DatatransferTransferTransformationTransformerFilterRowsTables {
    excludeTables?: string[];
    includeTables?: string[];
}

export interface DatatransferTransferTransformationTransformerMaskField {
    columns?: string[];
    function?: outputs.DatatransferTransferTransformationTransformerMaskFieldFunction;
    tables?: outputs.DatatransferTransferTransformationTransformerMaskFieldTables;
}

export interface DatatransferTransferTransformationTransformerMaskFieldFunction {
    maskFunctionHash?: outputs.DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash;
}

export interface DatatransferTransferTransformationTransformerMaskFieldFunctionMaskFunctionHash {
    userDefinedSalt?: string;
}

export interface DatatransferTransferTransformationTransformerMaskFieldTables {
    excludeTables?: string[];
    includeTables?: string[];
}

export interface DatatransferTransferTransformationTransformerRenameTables {
    renameTables?: outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTable[];
}

export interface DatatransferTransferTransformationTransformerRenameTablesRenameTable {
    newName?: outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName;
    originalName?: outputs.DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName;
}

export interface DatatransferTransferTransformationTransformerRenameTablesRenameTableNewName {
    name?: string;
    nameSpace?: string;
}

export interface DatatransferTransferTransformationTransformerRenameTablesRenameTableOriginalName {
    name?: string;
    nameSpace?: string;
}

export interface DatatransferTransferTransformationTransformerReplacePrimaryKey {
    keys?: string[];
    tables?: outputs.DatatransferTransferTransformationTransformerReplacePrimaryKeyTables;
}

export interface DatatransferTransferTransformationTransformerReplacePrimaryKeyTables {
    excludeTables?: string[];
    includeTables?: string[];
}

export interface DatatransferTransferTransformationTransformerSharderTransformer {
    columns?: outputs.DatatransferTransferTransformationTransformerSharderTransformerColumns;
    shardsCount?: number;
    tables?: outputs.DatatransferTransferTransformationTransformerSharderTransformerTables;
}

export interface DatatransferTransferTransformationTransformerSharderTransformerColumns {
    excludeColumns?: string[];
    includeColumns?: string[];
}

export interface DatatransferTransferTransformationTransformerSharderTransformerTables {
    excludeTables?: string[];
    includeTables?: string[];
}

export interface DatatransferTransferTransformationTransformerTableSplitterTransformer {
    columns?: string[];
    splitter?: string;
    tables?: outputs.DatatransferTransferTransformationTransformerTableSplitterTransformerTables;
}

export interface DatatransferTransferTransformationTransformerTableSplitterTransformerTables {
    excludeTables?: string[];
    includeTables?: string[];
}

export interface DnsRecordsetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DnsZoneIamBindingTimeouts {
    default?: string;
}

export interface DnsZoneTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FunctionAsyncInvocation {
    retriesCount?: number;
    serviceAccountId?: string;
    ymqFailureTarget?: outputs.FunctionAsyncInvocationYmqFailureTarget;
    ymqSuccessTarget?: outputs.FunctionAsyncInvocationYmqSuccessTarget;
}

export interface FunctionAsyncInvocationYmqFailureTarget {
    arn: string;
    serviceAccountId: string;
}

export interface FunctionAsyncInvocationYmqSuccessTarget {
    arn: string;
    serviceAccountId: string;
}

export interface FunctionConnectivity {
    networkId: string;
}

export interface FunctionContent {
    zipFilename: string;
}

export interface FunctionIamBindingTimeouts {
    default?: string;
}

export interface FunctionLogOptions {
    disabled?: boolean;
    folderId?: string;
    logGroupId?: string;
    minLevel?: string;
}

export interface FunctionPackage {
    bucketName: string;
    objectName: string;
    sha256?: string;
}

export interface FunctionScalingPolicyPolicy {
    tag: string;
    zoneInstancesLimit?: number;
    zoneRequestsLimit?: number;
}

export interface FunctionSecret {
    environmentVariable: string;
    id: string;
    key: string;
    versionId: string;
}

export interface FunctionStorageMount {
    bucket: string;
    mountPointName: string;
    prefix?: string;
    readOnly?: boolean;
}

export interface FunctionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FunctionTriggerContainer {
    id: string;
    path?: string;
    retryAttempts?: string;
    retryInterval?: string;
    serviceAccountId?: string;
}

export interface FunctionTriggerContainerRegistry {
    batchCutoff: string;
    batchSize?: string;
    createImage?: boolean;
    createImageTag?: boolean;
    deleteImage?: boolean;
    deleteImageTag?: boolean;
    imageName?: string;
    registryId: string;
    tag?: string;
}

export interface FunctionTriggerDataStreams {
    batchCutoff: string;
    batchSize?: string;
    database: string;
    serviceAccountId: string;
    streamName: string;
}

export interface FunctionTriggerDlq {
    queueId: string;
    serviceAccountId: string;
}

export interface FunctionTriggerFunction {
    id: string;
    retryAttempts?: string;
    retryInterval?: string;
    serviceAccountId?: string;
    tag?: string;
}

export interface FunctionTriggerIot {
    batchCutoff: string;
    batchSize?: string;
    deviceId?: string;
    registryId: string;
    topic?: string;
}

export interface FunctionTriggerLogGroup {
    batchCutoff: string;
    batchSize?: string;
    logGroupIds: string[];
}

export interface FunctionTriggerLogging {
    batchCutoff: string;
    batchSize?: string;
    groupId: string;
    levels?: string[];
    resourceIds?: string[];
    resourceTypes?: string[];
    streamNames?: string[];
}

export interface FunctionTriggerMail {
    attachmentsBucketId?: string;
    batchCutoff: string;
    batchSize?: string;
    serviceAccountId?: string;
}

export interface FunctionTriggerMessageQueue {
    batchCutoff: string;
    batchSize?: string;
    queueId: string;
    serviceAccountId: string;
    visibilityTimeout?: string;
}

export interface FunctionTriggerObjectStorage {
    batchCutoff: string;
    batchSize?: string;
    bucketId: string;
    create?: boolean;
    delete?: boolean;
    prefix?: string;
    suffix?: string;
    update?: boolean;
}

export interface FunctionTriggerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FunctionTriggerTimer {
    cronExpression: string;
    payload?: string;
}

export interface GetAlbBackendGroupGrpcBackend {
    healthcheck?: outputs.GetAlbBackendGroupGrpcBackendHealthcheck;
    loadBalancingConfig?: outputs.GetAlbBackendGroupGrpcBackendLoadBalancingConfig;
    name: string;
    port: number;
    targetGroupIds: string[];
    tls?: outputs.GetAlbBackendGroupGrpcBackendTls;
    weight: number;
}

export interface GetAlbBackendGroupGrpcBackendHealthcheck {
    grpcHealthcheck?: outputs.GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck;
    healthcheckPort: number;
    healthyThreshold: number;
    httpHealthcheck?: outputs.GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent: number;
    streamHealthcheck?: outputs.GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold: number;
}

export interface GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck {
    serviceName: string;
}

export interface GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck {
    host: string;
    http2: boolean;
    path: string;
}

export interface GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck {
    receive: string;
    send: string;
}

export interface GetAlbBackendGroupGrpcBackendLoadBalancingConfig {
    localityAwareRoutingPercent: number;
    mode: string;
    panicThreshold: number;
    strictLocality: boolean;
}

export interface GetAlbBackendGroupGrpcBackendTls {
    sni: string;
    validationContext?: outputs.GetAlbBackendGroupGrpcBackendTlsValidationContext;
}

export interface GetAlbBackendGroupGrpcBackendTlsValidationContext {
    trustedCaBytes: string;
    trustedCaId: string;
}

export interface GetAlbBackendGroupHttpBackend {
    healthcheck?: outputs.GetAlbBackendGroupHttpBackendHealthcheck;
    http2: boolean;
    loadBalancingConfig?: outputs.GetAlbBackendGroupHttpBackendLoadBalancingConfig;
    name: string;
    port: number;
    storageBucket: string;
    targetGroupIds: string[];
    tls?: outputs.GetAlbBackendGroupHttpBackendTls;
    weight: number;
}

export interface GetAlbBackendGroupHttpBackendHealthcheck {
    grpcHealthcheck?: outputs.GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck;
    healthcheckPort: number;
    healthyThreshold: number;
    httpHealthcheck?: outputs.GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent: number;
    streamHealthcheck?: outputs.GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold: number;
}

export interface GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck {
    serviceName: string;
}

export interface GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheck {
    host: string;
    http2: boolean;
    path: string;
}

export interface GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheck {
    receive: string;
    send: string;
}

export interface GetAlbBackendGroupHttpBackendLoadBalancingConfig {
    localityAwareRoutingPercent: number;
    mode: string;
    panicThreshold: number;
    strictLocality: boolean;
}

export interface GetAlbBackendGroupHttpBackendTls {
    sni: string;
    validationContext?: outputs.GetAlbBackendGroupHttpBackendTlsValidationContext;
}

export interface GetAlbBackendGroupHttpBackendTlsValidationContext {
    trustedCaBytes: string;
    trustedCaId: string;
}

export interface GetAlbBackendGroupSessionAffinity {
    /**
     * IP address affinity
     */
    connection?: outputs.GetAlbBackendGroupSessionAffinityConnection;
    /**
     * Cookie affinity
     */
    cookie?: outputs.GetAlbBackendGroupSessionAffinityCookie;
    /**
     * Request header affinity
     */
    header?: outputs.GetAlbBackendGroupSessionAffinityHeader;
}

export interface GetAlbBackendGroupSessionAffinityConnection {
    /**
     * Use source IP address
     */
    sourceIp: boolean;
}

export interface GetAlbBackendGroupSessionAffinityCookie {
    /**
     * Name of the HTTP cookie
     */
    name: string;
    /**
     * TTL for the cookie (if not set, session cookie will be used)
     */
    ttl: string;
}

export interface GetAlbBackendGroupSessionAffinityHeader {
    /**
     * The name of the request header that will be used
     */
    headerName: string;
}

export interface GetAlbBackendGroupStreamBackend {
    enableProxyProtocol: boolean;
    healthcheck?: outputs.GetAlbBackendGroupStreamBackendHealthcheck;
    loadBalancingConfig?: outputs.GetAlbBackendGroupStreamBackendLoadBalancingConfig;
    name: string;
    port: number;
    targetGroupIds: string[];
    tls?: outputs.GetAlbBackendGroupStreamBackendTls;
    weight: number;
}

export interface GetAlbBackendGroupStreamBackendHealthcheck {
    grpcHealthcheck?: outputs.GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck;
    healthcheckPort: number;
    healthyThreshold: number;
    httpHealthcheck?: outputs.GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent: number;
    streamHealthcheck?: outputs.GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold: number;
}

export interface GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck {
    serviceName: string;
}

export interface GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheck {
    host: string;
    http2: boolean;
    path: string;
}

export interface GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheck {
    receive: string;
    send: string;
}

export interface GetAlbBackendGroupStreamBackendLoadBalancingConfig {
    localityAwareRoutingPercent: number;
    mode: string;
    panicThreshold: number;
    strictLocality: boolean;
}

export interface GetAlbBackendGroupStreamBackendTls {
    sni: string;
    validationContext?: outputs.GetAlbBackendGroupStreamBackendTlsValidationContext;
}

export interface GetAlbBackendGroupStreamBackendTlsValidationContext {
    trustedCaBytes: string;
    trustedCaId: string;
}

export interface GetAlbHttpRouterRouteOption {
    rbacs: outputs.GetAlbHttpRouterRouteOptionRbac[];
    securityProfileId: string;
}

export interface GetAlbHttpRouterRouteOptionRbac {
    action: string;
    principals: outputs.GetAlbHttpRouterRouteOptionRbacPrincipal[];
}

export interface GetAlbHttpRouterRouteOptionRbacPrincipal {
    andPrincipals: outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipal[];
}

export interface GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipal {
    any: boolean;
    headers: outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeader[];
    remoteIp: string;
}

export interface GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeader {
    name: string;
    values: outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValue[];
}

export interface GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValue {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetAlbLoadBalancerAllocationPolicy {
    locations: outputs.GetAlbLoadBalancerAllocationPolicyLocation[];
}

export interface GetAlbLoadBalancerAllocationPolicyLocation {
    disableTraffic: boolean;
    subnetId: string;
    zoneId: string;
}

export interface GetAlbLoadBalancerListener {
    endpoints: outputs.GetAlbLoadBalancerListenerEndpoint[];
    https: outputs.GetAlbLoadBalancerListenerHttp[];
    name: string;
    streams: outputs.GetAlbLoadBalancerListenerStream[];
    tls: outputs.GetAlbLoadBalancerListenerTl[];
}

export interface GetAlbLoadBalancerListenerEndpoint {
    addresses: outputs.GetAlbLoadBalancerListenerEndpointAddress[];
    ports: number[];
}

export interface GetAlbLoadBalancerListenerEndpointAddress {
    externalIpv4Addresses: outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv4Address[];
    externalIpv6Addresses: outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv6Address[];
    internalIpv4Addresses: outputs.GetAlbLoadBalancerListenerEndpointAddressInternalIpv4Address[];
}

export interface GetAlbLoadBalancerListenerEndpointAddressExternalIpv4Address {
    address: string;
}

export interface GetAlbLoadBalancerListenerEndpointAddressExternalIpv6Address {
    address: string;
}

export interface GetAlbLoadBalancerListenerEndpointAddressInternalIpv4Address {
    address: string;
    subnetId: string;
}

export interface GetAlbLoadBalancerListenerHttp {
    handlers: outputs.GetAlbLoadBalancerListenerHttpHandler[];
    redirects: outputs.GetAlbLoadBalancerListenerHttpRedirect[];
}

export interface GetAlbLoadBalancerListenerHttpHandler {
    allowHttp10: boolean;
    http2Options: outputs.GetAlbLoadBalancerListenerHttpHandlerHttp2Option[];
    httpRouterId: string;
    rewriteRequestId: boolean;
}

export interface GetAlbLoadBalancerListenerHttpHandlerHttp2Option {
    maxConcurrentStreams: number;
}

export interface GetAlbLoadBalancerListenerHttpRedirect {
    httpToHttps: boolean;
}

export interface GetAlbLoadBalancerListenerStream {
    handlers: outputs.GetAlbLoadBalancerListenerStreamHandler[];
}

export interface GetAlbLoadBalancerListenerStreamHandler {
    backendGroupId: string;
}

export interface GetAlbLoadBalancerListenerTl {
    defaultHandlers: outputs.GetAlbLoadBalancerListenerTlDefaultHandler[];
    sniHandlers: outputs.GetAlbLoadBalancerListenerTlSniHandler[];
}

export interface GetAlbLoadBalancerListenerTlDefaultHandler {
    certificateIds: string[];
    httpHandlers: outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandler[];
    streamHandlers: outputs.GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandler[];
}

export interface GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandler {
    allowHttp10: boolean;
    http2Options: outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2Option[];
    httpRouterId: string;
    rewriteRequestId: boolean;
}

export interface GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2Option {
    maxConcurrentStreams: number;
}

export interface GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandler {
    backendGroupId: string;
}

export interface GetAlbLoadBalancerListenerTlSniHandler {
    handlers: outputs.GetAlbLoadBalancerListenerTlSniHandlerHandler[];
    name: string;
    serverNames: string[];
}

export interface GetAlbLoadBalancerListenerTlSniHandlerHandler {
    certificateIds: string[];
    httpHandlers: outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandler[];
    streamHandlers: outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandler[];
}

export interface GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandler {
    allowHttp10: boolean;
    http2Options: outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2Option[];
    httpRouterId: string;
    rewriteRequestId: boolean;
}

export interface GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2Option {
    maxConcurrentStreams: number;
}

export interface GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandler {
    backendGroupId: string;
}

export interface GetAlbLoadBalancerLogOption {
    disable: boolean;
    discardRules: outputs.GetAlbLoadBalancerLogOptionDiscardRule[];
    logGroupId: string;
}

export interface GetAlbLoadBalancerLogOptionDiscardRule {
    discardPercent: number;
    grpcCodes: string[];
    httpCodeIntervals: string[];
    httpCodes: number[];
}

export interface GetAlbLoadBalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GetAlbTargetGroupTarget {
    ipAddress: string;
    privateIpv4Address: boolean;
    subnetId: string;
}

export interface GetAlbVirtualHostModifyRequestHeader {
    append: string;
    name: string;
    remove: boolean;
    replace: string;
}

export interface GetAlbVirtualHostModifyResponseHeader {
    append: string;
    name: string;
    remove: boolean;
    replace: string;
}

export interface GetAlbVirtualHostRoute {
    grpcRoutes: outputs.GetAlbVirtualHostRouteGrpcRoute[];
    httpRoutes: outputs.GetAlbVirtualHostRouteHttpRoute[];
    name: string;
    routeOptions: outputs.GetAlbVirtualHostRouteRouteOption[];
}

export interface GetAlbVirtualHostRouteGrpcRoute {
    grpcMatches: outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatch[];
    grpcRouteActions: outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteAction[];
    grpcStatusResponseActions: outputs.GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction[];
}

export interface GetAlbVirtualHostRouteGrpcRouteGrpcMatch {
    fqmns: outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmn[];
}

export interface GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmn {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetAlbVirtualHostRouteGrpcRouteGrpcRouteAction {
    autoHostRewrite: boolean;
    backendGroupId: string;
    hostRewrite: string;
    idleTimeout: string;
    maxTimeout: string;
}

export interface GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction {
    status: string;
}

export interface GetAlbVirtualHostRouteHttpRoute {
    directResponseActions: outputs.GetAlbVirtualHostRouteHttpRouteDirectResponseAction[];
    httpMatches: outputs.GetAlbVirtualHostRouteHttpRouteHttpMatch[];
    httpRouteActions: outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteAction[];
    redirectActions: outputs.GetAlbVirtualHostRouteHttpRouteRedirectAction[];
}

export interface GetAlbVirtualHostRouteHttpRouteDirectResponseAction {
    body: string;
    status: number;
}

export interface GetAlbVirtualHostRouteHttpRouteHttpMatch {
    httpMethods: string[];
    paths: outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchPath[];
}

export interface GetAlbVirtualHostRouteHttpRouteHttpMatchPath {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetAlbVirtualHostRouteHttpRouteHttpRouteAction {
    autoHostRewrite: boolean;
    backendGroupId: string;
    hostRewrite: string;
    idleTimeout: string;
    prefixRewrite: string;
    timeout: string;
    upgradeTypes: string[];
}

export interface GetAlbVirtualHostRouteHttpRouteRedirectAction {
    removeQuery: boolean;
    replaceHost: string;
    replacePath: string;
    replacePort: number;
    replacePrefix: string;
    replaceScheme: string;
    responseCode: string;
}

export interface GetAlbVirtualHostRouteOption {
    rbacs: outputs.GetAlbVirtualHostRouteOptionRbac[];
    securityProfileId: string;
}

export interface GetAlbVirtualHostRouteOptionRbac {
    action: string;
    principals: outputs.GetAlbVirtualHostRouteOptionRbacPrincipal[];
}

export interface GetAlbVirtualHostRouteOptionRbacPrincipal {
    andPrincipals: outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipal[];
}

export interface GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipal {
    any: boolean;
    headers: outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeader[];
    remoteIp: string;
}

export interface GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeader {
    name: string;
    values: outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValue[];
}

export interface GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValue {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetAlbVirtualHostRouteRouteOption {
    rbacs: outputs.GetAlbVirtualHostRouteRouteOptionRbac[];
    securityProfileId: string;
}

export interface GetAlbVirtualHostRouteRouteOptionRbac {
    action: string;
    principals: outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipal[];
}

export interface GetAlbVirtualHostRouteRouteOptionRbacPrincipal {
    andPrincipals: outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipal[];
}

export interface GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipal {
    any: boolean;
    headers: outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeader[];
    remoteIp: string;
}

export interface GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeader {
    name: string;
    values: outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValue[];
}

export interface GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValue {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetApiGatewayCanary {
    variables?: {[key: string]: string};
    weight?: number;
}

export interface GetApiGatewayConnectivity {
    networkId: string;
}

export interface GetApiGatewayCustomDomain {
    certificateId: string;
    domainId: string;
    fqdn: string;
}

export interface GetApiGatewayLogOption {
    disabled: boolean;
    folderId: string;
    logGroupId: string;
    minLevel: string;
}

export interface GetAuditTrailsTrailDataStreamDestination {
    databaseId: string;
    streamName: string;
}

export interface GetAuditTrailsTrailFilter {
    eventFilters: outputs.GetAuditTrailsTrailFilterEventFilter[];
    pathFilters: outputs.GetAuditTrailsTrailFilterPathFilter[];
}

export interface GetAuditTrailsTrailFilterEventFilter {
    categories: outputs.GetAuditTrailsTrailFilterEventFilterCategory[];
    pathFilters: outputs.GetAuditTrailsTrailFilterEventFilterPathFilter[];
    service: string;
}

export interface GetAuditTrailsTrailFilterEventFilterCategory {
    plane: string;
    type: string;
}

export interface GetAuditTrailsTrailFilterEventFilterPathFilter {
    anyFilters: outputs.GetAuditTrailsTrailFilterEventFilterPathFilterAnyFilter[];
    someFilters: outputs.GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilter[];
}

export interface GetAuditTrailsTrailFilterEventFilterPathFilterAnyFilter {
    resourceId: string;
    resourceType: string;
}

export interface GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilter {
    anyFilters: outputs.GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter[];
    resourceId: string;
    resourceType: string;
}

export interface GetAuditTrailsTrailFilterEventFilterPathFilterSomeFilterAnyFilter {
    resourceId: string;
    resourceType: string;
}

export interface GetAuditTrailsTrailFilterPathFilter {
    anyFilters: outputs.GetAuditTrailsTrailFilterPathFilterAnyFilter[];
    someFilters: outputs.GetAuditTrailsTrailFilterPathFilterSomeFilter[];
}

export interface GetAuditTrailsTrailFilterPathFilterAnyFilter {
    resourceId: string;
    resourceType: string;
}

export interface GetAuditTrailsTrailFilterPathFilterSomeFilter {
    anyFilters: outputs.GetAuditTrailsTrailFilterPathFilterSomeFilterAnyFilter[];
    resourceId: string;
    resourceType: string;
}

export interface GetAuditTrailsTrailFilterPathFilterSomeFilterAnyFilter {
    resourceId: string;
    resourceType: string;
}

export interface GetAuditTrailsTrailLoggingDestination {
    logGroupId: string;
}

export interface GetAuditTrailsTrailStorageDestination {
    bucketName: string;
    objectPrefix: string;
}

export interface GetBackupPolicyReattempt {
    enabled: boolean;
    interval: string;
    maxAttempts: number;
}

export interface GetBackupPolicyRetention {
    afterBackup: boolean;
    rules: outputs.GetBackupPolicyRetentionRule[];
}

export interface GetBackupPolicyRetentionRule {
    maxAge: string;
    maxCount: number;
    repeatPeriods: string[];
}

export interface GetBackupPolicyScheduling {
    backupSets: outputs.GetBackupPolicySchedulingBackupSet[];
    enabled: boolean;
    maxParallelBackups: number;
    randomMaxDelay: string;
    scheme: string;
    weeklyBackupDay: string;
}

export interface GetBackupPolicySchedulingBackupSet {
    executeByInterval: number;
    executeByTimes: outputs.GetBackupPolicySchedulingBackupSetExecuteByTime[];
    type: string;
}

export interface GetBackupPolicySchedulingBackupSetExecuteByTime {
    includeLastDayOfMonth: boolean;
    monthdays: number[];
    months: number[];
    repeatAts: string[];
    repeatEvery: string;
    type: string;
    weekdays: string[];
}

export interface GetBackupPolicyVmSnapshotReattempt {
    enabled: boolean;
    interval: string;
    maxAttempts: number;
}

export interface GetCdnOriginGroupOrigin {
    backup: boolean;
    enabled: boolean;
    originGroupId: number;
    source: string;
}

export interface GetCdnResourceOptions {
    allowedHttpMethods: string[];
    browserCacheSettings: number;
    cacheHttpHeaders: string[];
    cors: string[];
    customHostHeader: string;
    customServerName: string;
    disableCache: boolean;
    disableProxyForceRanges: boolean;
    edgeCacheSettings: number;
    enableIpUrlSigning: boolean;
    fetchedCompressed: boolean;
    forwardHostHeader: boolean;
    gzipOn: boolean;
    ignoreCookie: boolean;
    ignoreQueryParams: boolean;
    ipAddressAcl?: outputs.GetCdnResourceOptionsIpAddressAcl;
    proxyCacheMethodsSet: boolean;
    queryParamsBlacklists: string[];
    queryParamsWhitelists: string[];
    redirectHttpToHttps: boolean;
    redirectHttpsToHttp: boolean;
    secureKey: string;
    slice: boolean;
    staticRequestHeaders: {[key: string]: string};
    staticResponseHeaders: {[key: string]: string};
}

export interface GetCdnResourceOptionsIpAddressAcl {
    exceptedValues: string[];
    policyType: string;
}

export interface GetCdnResourceSslCertificate {
    certificateManagerId?: string;
    status: string;
    type: string;
}

export interface GetCmCertificateChallenge {
    createdAt: string;
    dnsName: string;
    dnsType: string;
    dnsValue: string;
    domain: string;
    httpContent: string;
    httpUrl: string;
    message: string;
    type: string;
    updatedAt: string;
}

export interface GetComputeDiskDiskPlacementPolicy {
    diskPlacementGroupId: string;
}

export interface GetComputeInstanceBootDisk {
    autoDelete: boolean;
    deviceName: string;
    diskId: string;
    initializeParams: outputs.GetComputeInstanceBootDiskInitializeParam[];
    mode: string;
}

export interface GetComputeInstanceBootDiskInitializeParam {
    blockSize: number;
    description: string;
    imageId: string;
    name: string;
    size: number;
    snapshotId: string;
    type: string;
}

export interface GetComputeInstanceFilesystem {
    deviceName: string;
    filesystemId: string;
    mode: string;
}

export interface GetComputeInstanceGroupAllocationPolicy {
    instanceTagsPools: outputs.GetComputeInstanceGroupAllocationPolicyInstanceTagsPool[];
    zones: string[];
}

export interface GetComputeInstanceGroupAllocationPolicyInstanceTagsPool {
    tags: string[];
    zone: string;
}

export interface GetComputeInstanceGroupApplicationBalancerState {
    statusMessage: string;
    targetGroupId: string;
}

export interface GetComputeInstanceGroupApplicationLoadBalancer {
    ignoreHealthChecks: boolean;
    maxOpeningTrafficDuration: number;
    statusMessage: string;
    targetGroupDescription: string;
    targetGroupId: string;
    targetGroupLabels: {[key: string]: string};
    targetGroupName: string;
}

export interface GetComputeInstanceGroupDeployPolicy {
    maxCreating: number;
    maxDeleting: number;
    maxExpansion: number;
    maxUnavailable: number;
    startupDuration: number;
    strategy: string;
}

export interface GetComputeInstanceGroupHealthCheck {
    healthyThreshold: number;
    httpOptions: outputs.GetComputeInstanceGroupHealthCheckHttpOption[];
    interval: number;
    tcpOptions: outputs.GetComputeInstanceGroupHealthCheckTcpOption[];
    timeout: number;
    unhealthyThreshold: number;
}

export interface GetComputeInstanceGroupHealthCheckHttpOption {
    path: string;
    port: number;
}

export interface GetComputeInstanceGroupHealthCheckTcpOption {
    port: number;
}

export interface GetComputeInstanceGroupInstance {
    fqdn: string;
    instanceId: string;
    instanceTag: string;
    name: string;
    networkInterfaces: outputs.GetComputeInstanceGroupInstanceNetworkInterface[];
    status: string;
    statusChangedAt: string;
    statusMessage: string;
    zoneId: string;
}

export interface GetComputeInstanceGroupInstanceNetworkInterface {
    index: number;
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    macAddress: string;
    nat: boolean;
    natIpAddress: string;
    natIpVersion: string;
    subnetId: string;
}

export interface GetComputeInstanceGroupInstanceTemplate {
    bootDisks: outputs.GetComputeInstanceGroupInstanceTemplateBootDisk[];
    description: string;
    filesystems: outputs.GetComputeInstanceGroupInstanceTemplateFilesystem[];
    hostname: string;
    labels: {[key: string]: string};
    metadata: {[key: string]: string};
    metadataOptions: outputs.GetComputeInstanceGroupInstanceTemplateMetadataOption[];
    name: string;
    networkInterfaces: outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterface[];
    networkSettings: outputs.GetComputeInstanceGroupInstanceTemplateNetworkSetting[];
    placementPolicies: outputs.GetComputeInstanceGroupInstanceTemplatePlacementPolicy[];
    platformId: string;
    resources: outputs.GetComputeInstanceGroupInstanceTemplateResource[];
    schedulingPolicies: outputs.GetComputeInstanceGroupInstanceTemplateSchedulingPolicy[];
    secondaryDisks: outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDisk[];
    serviceAccountId: string;
}

export interface GetComputeInstanceGroupInstanceTemplateBootDisk {
    deviceName: string;
    diskId: string;
    initializeParams: outputs.GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParam[];
    mode: string;
    name: string;
}

export interface GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParam {
    description: string;
    imageId: string;
    size: number;
    snapshotId: string;
    type: string;
}

export interface GetComputeInstanceGroupInstanceTemplateFilesystem {
    deviceName: string;
    filesystemId: string;
    mode: string;
}

export interface GetComputeInstanceGroupInstanceTemplateMetadataOption {
    awsV1HttpEndpoint: number;
    awsV1HttpToken: number;
    gceHttpEndpoint: number;
    gceHttpToken: number;
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkInterface {
    dnsRecords: outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord[];
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    ipv6DnsRecords: outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord[];
    nat: boolean;
    natDnsRecords: outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord[];
    natIpAddress: string;
    networkId: string;
    securityGroupIds: string[];
    subnetIds: string[];
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkSetting {
    type: string;
}

export interface GetComputeInstanceGroupInstanceTemplatePlacementPolicy {
    placementGroupId: string;
}

export interface GetComputeInstanceGroupInstanceTemplateResource {
    coreFraction: number;
    cores: number;
    gpus: number;
    memory: number;
}

export interface GetComputeInstanceGroupInstanceTemplateSchedulingPolicy {
    preemptible: boolean;
}

export interface GetComputeInstanceGroupInstanceTemplateSecondaryDisk {
    deviceName: string;
    diskId: string;
    initializeParams: outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParam[];
    mode: string;
    name: string;
}

export interface GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParam {
    description: string;
    imageId: string;
    size: number;
    snapshotId: string;
    type: string;
}

export interface GetComputeInstanceGroupLoadBalancer {
    ignoreHealthChecks: boolean;
    maxOpeningTrafficDuration: number;
    statusMessage: string;
    targetGroupDescription: string;
    targetGroupId: string;
    targetGroupLabels: {[key: string]: string};
    targetGroupName: string;
}

export interface GetComputeInstanceGroupLoadBalancerState {
    statusMessage: string;
    targetGroupId: string;
}

export interface GetComputeInstanceGroupScalePolicy {
    autoScales: outputs.GetComputeInstanceGroupScalePolicyAutoScale[];
    fixedScales: outputs.GetComputeInstanceGroupScalePolicyFixedScale[];
    testAutoScales: outputs.GetComputeInstanceGroupScalePolicyTestAutoScale[];
}

export interface GetComputeInstanceGroupScalePolicyAutoScale {
    autoScaleType: string;
    cpuUtilizationTarget: number;
    customRules: outputs.GetComputeInstanceGroupScalePolicyAutoScaleCustomRule[];
    initialSize: number;
    maxSize: number;
    measurementDuration: number;
    minZoneSize: number;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface GetComputeInstanceGroupScalePolicyAutoScaleCustomRule {
    folderId: string;
    labels: {[key: string]: string};
    metricName: string;
    metricType: string;
    ruleType: string;
    service: string;
    target: number;
}

export interface GetComputeInstanceGroupScalePolicyFixedScale {
    size: number;
}

export interface GetComputeInstanceGroupScalePolicyTestAutoScale {
    autoScaleType: string;
    cpuUtilizationTarget: number;
    customRules: outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRule[];
    initialSize: number;
    maxSize: number;
    measurementDuration: number;
    minZoneSize: number;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRule {
    folderId: string;
    labels: {[key: string]: string};
    metricName: string;
    metricType: string;
    ruleType: string;
    service: string;
    target: number;
}

export interface GetComputeInstanceLocalDisk {
    deviceName: string;
    sizeBytes: number;
}

export interface GetComputeInstanceMetadataOptions {
    awsV1HttpEndpoint: number;
    awsV1HttpToken: number;
    gceHttpEndpoint: number;
    gceHttpToken: number;
}

export interface GetComputeInstanceNetworkInterface {
    dnsRecords: outputs.GetComputeInstanceNetworkInterfaceDnsRecord[];
    index: number;
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    ipv6DnsRecords: outputs.GetComputeInstanceNetworkInterfaceIpv6DnsRecord[];
    macAddress: string;
    nat: boolean;
    natDnsRecords: outputs.GetComputeInstanceNetworkInterfaceNatDnsRecord[];
    natIpAddress: string;
    natIpVersion: string;
    securityGroupIds: string[];
    subnetId: string;
}

export interface GetComputeInstanceNetworkInterfaceDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceNetworkInterfaceIpv6DnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceNetworkInterfaceNatDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstancePlacementPolicy {
    hostAffinityRules: outputs.GetComputeInstancePlacementPolicyHostAffinityRule[];
    placementGroupId?: string;
    placementGroupPartition?: number;
}

export interface GetComputeInstancePlacementPolicyHostAffinityRule {
    key: string;
    op: string;
    values: string[];
}

export interface GetComputeInstanceResource {
    coreFraction: number;
    cores: number;
    gpus: number;
    memory: number;
}

export interface GetComputeInstanceSchedulingPolicy {
    preemptible: boolean;
}

export interface GetComputeInstanceSecondaryDisk {
    autoDelete: boolean;
    deviceName: string;
    diskId: string;
    mode: string;
}

export interface GetComputeSnapshotScheduleSchedulePolicy {
    expression: string;
    startAt: string;
}

export interface GetComputeSnapshotScheduleSnapshotSpec {
    description: string;
    labels: {[key: string]: string};
}

export interface GetContainerRegistryIpPermissionTimeouts {
    default?: string;
}

export interface GetContainerRepositoryLifecyclePolicyRule {
    description: string;
    expirePeriod: string;
    retainedTop: number;
    tagRegexp: string;
    untagged: boolean;
}

export interface GetContainerRepositoryLifecyclePolicyTimeouts {
    default?: string;
}

export interface GetDataprocClusterClusterConfig {
    hadoops: outputs.GetDataprocClusterClusterConfigHadoop[];
    subclusterSpecs: outputs.GetDataprocClusterClusterConfigSubclusterSpec[];
    versionId: string;
}

export interface GetDataprocClusterClusterConfigHadoop {
    initializationActions: outputs.GetDataprocClusterClusterConfigHadoopInitializationAction[];
    properties: {[key: string]: string};
    services: string[];
    sshPublicKeys: string[];
}

export interface GetDataprocClusterClusterConfigHadoopInitializationAction {
    args: string[];
    timeout: string;
    uri: string;
}

export interface GetDataprocClusterClusterConfigSubclusterSpec {
    assignPublicIp: boolean;
    autoscalingConfigs: outputs.GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfig[];
    hostsCount: number;
    id: string;
    name: string;
    resources: outputs.GetDataprocClusterClusterConfigSubclusterSpecResource[];
    role: string;
    subnetId: string;
}

export interface GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfig {
    cpuUtilizationTarget: string;
    decommissionTimeout: string;
    maxHostsCount: number;
    measurementDuration: string;
    preemptible: boolean;
    stabilizationDuration: string;
    warmupDuration: string;
}

export interface GetDataprocClusterClusterConfigSubclusterSpecResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetDatasphereCommunityTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface GetDatasphereProjectLimits {
    balance: number;
    maxUnitsPerExecution: number;
    maxUnitsPerHour: number;
}

export interface GetDatasphereProjectSettings {
    commitMode: string;
    dataProcClusterId: string;
    defaultFolderId: string;
    ide: string;
    securityGroupIds: string[];
    serviceAccountId: string;
    staleExecTimeoutMode: string;
    subnetId: string;
}

export interface GetDatasphereProjectTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface GetDnsZoneTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GetFunctionAsyncInvocation {
    retriesCount: number;
    serviceAccountId: string;
    ymqFailureTargets: outputs.GetFunctionAsyncInvocationYmqFailureTarget[];
    ymqSuccessTargets: outputs.GetFunctionAsyncInvocationYmqSuccessTarget[];
}

export interface GetFunctionAsyncInvocationYmqFailureTarget {
    arn: string;
    serviceAccountId: string;
}

export interface GetFunctionAsyncInvocationYmqSuccessTarget {
    arn: string;
    serviceAccountId: string;
}

export interface GetFunctionConnectivity {
    networkId: string;
}

export interface GetFunctionLogOption {
    disabled: boolean;
    folderId: string;
    logGroupId: string;
    minLevel: string;
}

export interface GetFunctionScalingPolicyPolicy {
    tag: string;
    zoneInstancesLimit?: number;
    zoneRequestsLimit?: number;
}

export interface GetFunctionSecret {
    environmentVariable: string;
    id: string;
    key: string;
    versionId: string;
}

export interface GetFunctionStorageMount {
    bucket: string;
    mountPointName: string;
    prefix?: string;
    readOnly?: boolean;
}

export interface GetFunctionTriggerContainer {
    id: string;
    path: string;
    retryAttempts: string;
    retryInterval: string;
    serviceAccountId: string;
}

export interface GetFunctionTriggerContainerRegistry {
    batchCutoff: string;
    batchSize: string;
    createImage: boolean;
    createImageTag: boolean;
    deleteImage: boolean;
    deleteImageTag: boolean;
    imageName: string;
    registryId: string;
    tag: string;
}

export interface GetFunctionTriggerDataStream {
    batchCutoff: string;
    batchSize: string;
    database: string;
    serviceAccountId: boolean;
    streamName: string;
    suffix: string;
}

export interface GetFunctionTriggerDlq {
    queueId: string;
    serviceAccountId: string;
}

export interface GetFunctionTriggerFunction {
    id: string;
    retryAttempts: string;
    retryInterval: string;
    serviceAccountId: string;
    tag: string;
}

export interface GetFunctionTriggerIot {
    batchCutoff: string;
    batchSize: string;
    deviceId: string;
    registryId: string;
    topic: string;
}

export interface GetFunctionTriggerLogGroup {
    batchCutoff: string;
    batchSize: string;
    logGroupIds: string[];
}

export interface GetFunctionTriggerLogging {
    batchCutoff: string;
    batchSize: string;
    groupId: string;
    levels: string[];
    resourceIds: string[];
    resourceTypes: string[];
    streamNames: string[];
}

export interface GetFunctionTriggerMail {
    attachmentsBucketId: string;
    batchCutoff: string;
    batchSize: string;
    serviceAccountId: string;
}

export interface GetFunctionTriggerMessageQueue {
    batchCutoff: string;
    batchSize: string;
    queueId: string;
    serviceAccountId: string;
    visibilityTimeout: string;
}

export interface GetFunctionTriggerObjectStorage {
    batchCutoff: string;
    batchSize: string;
    bucketId: string;
    create: boolean;
    delete: boolean;
    prefix: string;
    suffix: string;
    update: boolean;
}

export interface GetFunctionTriggerTimer {
    cronExpression: string;
    payload: string;
}

export interface GetIamPolicyBinding {
    members: string[];
    role: string;
}

export interface GetIotCoreBrokerLogOption {
    disabled: boolean;
    folderId: string;
    logGroupId: string;
    minLevel: string;
}

export interface GetIotCoreRegistryLogOption {
    disabled: boolean;
    folderId: string;
    logGroupId: string;
    minLevel: string;
}

export interface GetKubernetesClusterKmsProvider {
    keyId: string;
}

export interface GetKubernetesClusterMaster {
    clusterCaCertificate: string;
    etcdClusterSize: number;
    externalV4Address: string;
    externalV4Endpoint: string;
    externalV6Address: string;
    externalV6Endpoint: string;
    internalV4Address: string;
    internalV4Endpoint: string;
    maintenancePolicies: outputs.GetKubernetesClusterMasterMaintenancePolicy[];
    masterLocations: outputs.GetKubernetesClusterMasterMasterLocation[];
    masterLoggings: outputs.GetKubernetesClusterMasterMasterLogging[];
    publicIp: boolean;
    regionals: outputs.GetKubernetesClusterMasterRegional[];
    securityGroupIds: string[];
    version: string;
    versionInfos: outputs.GetKubernetesClusterMasterVersionInfo[];
    zonals: outputs.GetKubernetesClusterMasterZonal[];
}

export interface GetKubernetesClusterMasterMaintenancePolicy {
    autoUpgrade: boolean;
    maintenanceWindows: outputs.GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindow[];
}

export interface GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindow {
    day: string;
    duration: string;
    startTime: string;
}

export interface GetKubernetesClusterMasterMasterLocation {
    subnetId: string;
    zone: string;
}

export interface GetKubernetesClusterMasterMasterLogging {
    auditEnabled: boolean;
    clusterAutoscalerEnabled: boolean;
    enabled: boolean;
    eventsEnabled: boolean;
    folderId: string;
    kubeApiserverEnabled: boolean;
    logGroupId: string;
}

export interface GetKubernetesClusterMasterRegional {
    region: string;
}

export interface GetKubernetesClusterMasterVersionInfo {
    currentVersion: string;
    newRevisionAvailable: boolean;
    newRevisionSummary: string;
    versionDeprecated: boolean;
}

export interface GetKubernetesClusterMasterZonal {
    zone: string;
}

export interface GetKubernetesClusterNetworkImplementation {
    cilia: outputs.GetKubernetesClusterNetworkImplementationCilium[];
}

export interface GetKubernetesClusterNetworkImplementationCilium {
    routingMode: string;
}

export interface GetKubernetesNodeGroupAllocationPolicy {
    locations: outputs.GetKubernetesNodeGroupAllocationPolicyLocation[];
}

export interface GetKubernetesNodeGroupAllocationPolicyLocation {
    subnetId: string;
    zone: string;
}

export interface GetKubernetesNodeGroupDeployPolicy {
    maxExpansion: number;
    maxUnavailable: number;
}

export interface GetKubernetesNodeGroupInstanceTemplate {
    bootDisks: outputs.GetKubernetesNodeGroupInstanceTemplateBootDisk[];
    containerNetworks: outputs.GetKubernetesNodeGroupInstanceTemplateContainerNetwork[];
    containerRuntimes: outputs.GetKubernetesNodeGroupInstanceTemplateContainerRuntime[];
    gpuSettings: outputs.GetKubernetesNodeGroupInstanceTemplateGpuSetting[];
    labels: {[key: string]: string};
    metadata: {[key: string]: string};
    name: string;
    nat: boolean;
    networkAccelerationType: string;
    networkInterfaces: outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterface[];
    placementPolicies: outputs.GetKubernetesNodeGroupInstanceTemplatePlacementPolicy[];
    platformId: string;
    resources: outputs.GetKubernetesNodeGroupInstanceTemplateResource[];
    schedulingPolicies: outputs.GetKubernetesNodeGroupInstanceTemplateSchedulingPolicy[];
}

export interface GetKubernetesNodeGroupInstanceTemplateBootDisk {
    size: number;
    type: string;
}

export interface GetKubernetesNodeGroupInstanceTemplateContainerNetwork {
    podMtu: number;
}

export interface GetKubernetesNodeGroupInstanceTemplateContainerRuntime {
    type: string;
}

export interface GetKubernetesNodeGroupInstanceTemplateGpuSetting {
    gpuClusterId: string;
    gpuEnvironment: string;
}

export interface GetKubernetesNodeGroupInstanceTemplateNetworkInterface {
    ipv4: boolean;
    ipv4DnsRecords: outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord[];
    ipv6: boolean;
    ipv6DnsRecords: outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord[];
    nat: boolean;
    securityGroupIds: string[];
    subnetIds: string[];
}

export interface GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetKubernetesNodeGroupInstanceTemplatePlacementPolicy {
    placementGroupId: string;
}

export interface GetKubernetesNodeGroupInstanceTemplateResource {
    coreFraction: number;
    cores: number;
    gpus: number;
    memory: number;
}

export interface GetKubernetesNodeGroupInstanceTemplateSchedulingPolicy {
    preemptible: boolean;
}

export interface GetKubernetesNodeGroupMaintenancePolicy {
    autoRepair: boolean;
    autoUpgrade: boolean;
    maintenanceWindows: outputs.GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindow[];
}

export interface GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindow {
    day: string;
    duration: string;
    startTime: string;
}

export interface GetKubernetesNodeGroupScalePolicy {
    autoScales: outputs.GetKubernetesNodeGroupScalePolicyAutoScale[];
    fixedScales: outputs.GetKubernetesNodeGroupScalePolicyFixedScale[];
}

export interface GetKubernetesNodeGroupScalePolicyAutoScale {
    initial: number;
    max: number;
    min: number;
}

export interface GetKubernetesNodeGroupScalePolicyFixedScale {
    size: number;
}

export interface GetKubernetesNodeGroupVersionInfo {
    currentVersion: string;
    newRevisionAvailable: boolean;
    newRevisionSummary: string;
    versionDeprecated: boolean;
}

export interface GetLbNetworkLoadBalancerAttachedTargetGroup {
    healthchecks: outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheck[];
    targetGroupId: string;
}

export interface GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheck {
    healthyThreshold: number;
    httpOptions: outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOption[];
    interval: number;
    name: string;
    tcpOptions: outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOption[];
    timeout: number;
    unhealthyThreshold: number;
}

export interface GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOption {
    path: string;
    port: number;
}

export interface GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOption {
    port: number;
}

export interface GetLbNetworkLoadBalancerListener {
    externalAddressSpecs: outputs.GetLbNetworkLoadBalancerListenerExternalAddressSpec[];
    internalAddressSpecs: outputs.GetLbNetworkLoadBalancerListenerInternalAddressSpec[];
    name: string;
    port: number;
    protocol: string;
    targetPort: number;
}

export interface GetLbNetworkLoadBalancerListenerExternalAddressSpec {
    address: string;
    ipVersion: string;
}

export interface GetLbNetworkLoadBalancerListenerInternalAddressSpec {
    address: string;
    ipVersion: string;
    subnetId: string;
}

export interface GetLbTargetGroupTarget {
    address: string;
    subnetId: string;
}

export interface GetLoadtestingAgentComputeInstance {
    bootDisks: outputs.GetLoadtestingAgentComputeInstanceBootDisk[];
    computedMetadata: {[key: string]: string};
    labels: {[key: string]: string};
    metadata: {[key: string]: string};
    networkInterfaces: outputs.GetLoadtestingAgentComputeInstanceNetworkInterface[];
    platformId: string;
    resources: outputs.GetLoadtestingAgentComputeInstanceResource[];
    serviceAccountId: string;
    zoneId: string;
}

export interface GetLoadtestingAgentComputeInstanceBootDisk {
    autoDelete: boolean;
    deviceName: string;
    diskId: string;
    initializeParams: outputs.GetLoadtestingAgentComputeInstanceBootDiskInitializeParam[];
}

export interface GetLoadtestingAgentComputeInstanceBootDiskInitializeParam {
    blockSize: number;
    description: string;
    name: string;
    size: number;
    type: string;
}

export interface GetLoadtestingAgentComputeInstanceNetworkInterface {
    index: number;
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    macAddress: string;
    nat: boolean;
    natIpAddress: string;
    natIpVersion: string;
    securityGroupIds: string[];
    subnetId: string;
}

export interface GetLoadtestingAgentComputeInstanceResource {
    coreFraction: number;
    cores: number;
    memory: number;
}

export interface GetLockboxSecretCurrentVersion {
    createdAt: string;
    description: string;
    destroyAt: string;
    id: string;
    payloadEntryKeys: string[];
    secretId: string;
    status: string;
}

export interface GetLockboxSecretVersionEntry {
    key: string;
    textValue: string;
}

export interface GetMdbClickhouseClusterAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
    metrika?: boolean;
    serverless?: boolean;
    webSql?: boolean;
    yandexQuery?: boolean;
}

export interface GetMdbClickhouseClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface GetMdbClickhouseClusterClickhouse {
    config?: outputs.GetMdbClickhouseClusterClickhouseConfig;
    resources?: outputs.GetMdbClickhouseClusterClickhouseResources;
}

export interface GetMdbClickhouseClusterClickhouseConfig {
    backgroundFetchesPoolSize: number;
    backgroundMergesMutationsConcurrencyRatio: number;
    backgroundMessageBrokerSchedulePoolSize: number;
    backgroundPoolSize: number;
    backgroundSchedulePoolSize: number;
    compressions?: outputs.GetMdbClickhouseClusterClickhouseConfigCompression[];
    defaultDatabase: string;
    geobaseEnabled: boolean;
    geobaseUri: string;
    graphiteRollups?: outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollup[];
    kafka?: outputs.GetMdbClickhouseClusterClickhouseConfigKafka;
    kafkaTopics?: outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopic[];
    keepAliveTimeout: number;
    logLevel: string;
    markCacheSize: number;
    maxConcurrentQueries: number;
    maxConnections: number;
    maxPartitionSizeToDrop: number;
    maxTableSizeToDrop: number;
    mergeTree?: outputs.GetMdbClickhouseClusterClickhouseConfigMergeTree;
    metricLogEnabled: boolean;
    metricLogRetentionSize: number;
    metricLogRetentionTime: number;
    partLogRetentionSize: number;
    partLogRetentionTime: number;
    queryLogRetentionSize: number;
    queryLogRetentionTime: number;
    queryThreadLogEnabled: boolean;
    queryThreadLogRetentionSize: number;
    queryThreadLogRetentionTime: number;
    rabbitmq?: outputs.GetMdbClickhouseClusterClickhouseConfigRabbitmq;
    textLogEnabled: boolean;
    textLogLevel: string;
    textLogRetentionSize: number;
    textLogRetentionTime: number;
    timezone: string;
    totalMemoryProfilerStep: number;
    traceLogEnabled: boolean;
    traceLogRetentionSize: number;
    traceLogRetentionTime: number;
    uncompressedCacheSize: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigCompression {
    level?: number;
    method?: string;
    minPartSize?: number;
    minPartSizeRatio?: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigGraphiteRollup {
    name?: string;
    patterns?: outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPattern[];
}

export interface GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPattern {
    function?: string;
    regexp: string;
    retentions?: outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention[];
}

export interface GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention {
    age?: number;
    precision?: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigKafka {
    enableSslCertificateVerification: boolean;
    maxPollIntervalMs: number;
    saslMechanism: string;
    saslPassword: string;
    saslUsername: string;
    securityProtocol: string;
    sessionTimeoutMs: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigKafkaTopic {
    name?: string;
    settings?: outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettings;
}

export interface GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettings {
    enableSslCertificateVerification: boolean;
    maxPollIntervalMs: number;
    saslMechanism?: string;
    saslPassword?: string;
    saslUsername?: string;
    securityProtocol?: string;
    sessionTimeoutMs: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigMergeTree {
    cleanupDelayPeriod: number;
    maxAvgPartSizeForTooManyParts: number;
    maxBytesToMergeAtMinSpaceInPool: number;
    maxNumberOfMergesWithTtlInPool: number;
    maxPartsInTotal: number;
    maxReplicatedMergesInQueue: number;
    mergeSelectingSleepMs: number;
    mergeWithRecompressionTtlTimeout: number;
    mergeWithTtlTimeout: number;
    minAgeToForceMergeOnPartitionOnly: boolean;
    minAgeToForceMergeSeconds: number;
    minBytesForWidePart: number;
    minRowsForWidePart: number;
    numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge: number;
    partsToDelayInsert: number;
    partsToThrowInsert: number;
    replicatedDeduplicationWindow: number;
    replicatedDeduplicationWindowSeconds: number;
    ttlOnlyDropParts: boolean;
}

export interface GetMdbClickhouseClusterClickhouseConfigRabbitmq {
    password: string;
    username: string;
    vhost: string;
}

export interface GetMdbClickhouseClusterClickhouseResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbClickhouseClusterCloudStorage {
    dataCacheEnabled: boolean;
    dataCacheMaxSize: number;
    enabled?: boolean;
    moveFactor: number;
    preferNotToMerge: boolean;
}

export interface GetMdbClickhouseClusterDatabase {
    name?: string;
}

export interface GetMdbClickhouseClusterFormatSchema {
    name?: string;
    type?: string;
    uri?: string;
}

export interface GetMdbClickhouseClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    shardName: string;
    subnetId: string;
    type?: string;
    zone?: string;
}

export interface GetMdbClickhouseClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type?: string;
}

export interface GetMdbClickhouseClusterMlModel {
    name?: string;
    type?: string;
    uri?: string;
}

export interface GetMdbClickhouseClusterShard {
    name?: string;
    resources?: outputs.GetMdbClickhouseClusterShardResources;
    weight: number;
}

export interface GetMdbClickhouseClusterShardGroup {
    description?: string;
    name?: string;
    shardNames?: string[];
}

export interface GetMdbClickhouseClusterShardResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbClickhouseClusterUser {
    name?: string;
    password?: string;
    permissions?: outputs.GetMdbClickhouseClusterUserPermission[];
    quotas?: outputs.GetMdbClickhouseClusterUserQuota[];
    settings?: outputs.GetMdbClickhouseClusterUserSettings;
}

export interface GetMdbClickhouseClusterUserPermission {
    databaseName?: string;
}

export interface GetMdbClickhouseClusterUserQuota {
    errors: number;
    executionTime: number;
    intervalDuration?: number;
    queries: number;
    readRows: number;
    resultRows: number;
}

export interface GetMdbClickhouseClusterUserSettings {
    addHttpCorsHeader: boolean;
    allowDdl: boolean;
    allowIntrospectionFunctions: boolean;
    allowSuspiciousLowCardinalityTypes: boolean;
    asyncInsert: boolean;
    asyncInsertBusyTimeout: number;
    asyncInsertMaxDataSize: number;
    asyncInsertStaleTimeout: number;
    asyncInsertThreads: number;
    cancelHttpReadonlyQueriesOnClientClose: boolean;
    compile: boolean;
    compileExpressions: boolean;
    connectTimeout: number;
    connectTimeoutWithFailover: number;
    countDistinctImplementation: string;
    distinctOverflowMode: string;
    distributedAggregationMemoryEfficient: boolean;
    distributedDdlTaskTimeout: number;
    distributedProductMode: string;
    emptyResultForAggregationByEmptySet: boolean;
    enableHttpCompression: boolean;
    fallbackToStaleReplicasForDistributedQueries: boolean;
    flattenNested: boolean;
    forceIndexByDate: boolean;
    forcePrimaryKey: boolean;
    groupByOverflowMode: string;
    groupByTwoLevelThreshold: number;
    groupByTwoLevelThresholdBytes: number;
    httpConnectionTimeout: number;
    httpHeadersProgressInterval: number;
    httpReceiveTimeout: number;
    httpSendTimeout: number;
    inputFormatDefaultsForOmittedFields: boolean;
    inputFormatImportNestedJson: boolean;
    inputFormatParallelParsing: boolean;
    inputFormatValuesInterpretExpressions: boolean;
    insertKeeperMaxRetries: number;
    insertNullAsDefault: boolean;
    insertQuorum: number;
    insertQuorumTimeout: number;
    joinOverflowMode: string;
    joinUseNulls: boolean;
    joinedSubqueryRequiresAlias: boolean;
    localFilesystemReadMethod: string;
    lowCardinalityAllowInNativeFormat: boolean;
    maxAstDepth: number;
    maxAstElements: number;
    maxBlockSize: number;
    maxBytesBeforeExternalGroupBy: number;
    maxBytesBeforeExternalSort: number;
    maxBytesInDistinct: number;
    maxBytesInJoin: number;
    maxBytesInSet: number;
    maxBytesToRead: number;
    maxBytesToSort: number;
    maxBytesToTransfer: number;
    maxColumnsToRead: number;
    maxConcurrentQueriesForUser: number;
    maxExecutionTime: number;
    maxExpandedAstElements: number;
    maxFinalThreads: number;
    maxHttpGetRedirects: number;
    maxInsertBlockSize: number;
    maxMemoryUsage: number;
    maxMemoryUsageForUser: number;
    maxNetworkBandwidth: number;
    maxNetworkBandwidthForUser: number;
    maxParserDepth: number;
    maxQuerySize: number;
    maxReadBufferSize: number;
    maxReplicaDelayForDistributedQueries: number;
    maxResultBytes: number;
    maxResultRows: number;
    maxRowsInDistinct: number;
    maxRowsInJoin: number;
    maxRowsInSet: number;
    maxRowsToGroupBy: number;
    maxRowsToRead: number;
    maxRowsToSort: number;
    maxRowsToTransfer: number;
    maxTemporaryColumns: number;
    maxTemporaryDataOnDiskSizeForQuery: number;
    maxTemporaryDataOnDiskSizeForUser: number;
    maxTemporaryNonConstColumns: number;
    maxThreads: number;
    memoryOvercommitRatioDenominator: number;
    memoryOvercommitRatioDenominatorForUser: number;
    memoryProfilerSampleProbability: number;
    memoryProfilerStep: number;
    memoryUsageOvercommitMaxWaitMicroseconds: number;
    mergeTreeMaxBytesToUseCache: number;
    mergeTreeMaxRowsToUseCache: number;
    mergeTreeMinBytesForConcurrentRead: number;
    mergeTreeMinRowsForConcurrentRead: number;
    minBytesToUseDirectIo: number;
    minCountToCompile: number;
    minCountToCompileExpression: number;
    minExecutionSpeed: number;
    minExecutionSpeedBytes: number;
    minInsertBlockSizeBytes: number;
    minInsertBlockSizeRows: number;
    outputFormatJsonQuote64bitIntegers: boolean;
    outputFormatJsonQuoteDenormals: boolean;
    priority: number;
    quotaMode: string;
    readOverflowMode: string;
    readonly: number;
    receiveTimeout: number;
    remoteFilesystemReadMethod: string;
    replicationAlterPartitionsSync: number;
    resultOverflowMode: string;
    selectSequentialConsistency: boolean;
    sendProgressInHttpHeaders: boolean;
    sendTimeout: number;
    setOverflowMode: string;
    skipUnavailableShards: boolean;
    sortOverflowMode: string;
    timeoutBeforeCheckingExecutionSpeed: number;
    timeoutOverflowMode: string;
    transferOverflowMode: string;
    transformNullIn: boolean;
    useUncompressedCache: boolean;
    waitForAsyncInsert: boolean;
    waitForAsyncInsertTimeout: number;
}

export interface GetMdbClickhouseClusterZookeeper {
    resources?: outputs.GetMdbClickhouseClusterZookeeperResources;
}

export interface GetMdbClickhouseClusterZookeeperResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbElasticsearchClusterConfig {
    adminPassword: string;
    dataNodes: outputs.GetMdbElasticsearchClusterConfigDataNode[];
    edition: string;
    masterNodes: outputs.GetMdbElasticsearchClusterConfigMasterNode[];
    plugins: string[];
    version: string;
}

export interface GetMdbElasticsearchClusterConfigDataNode {
    resources: outputs.GetMdbElasticsearchClusterConfigDataNodeResource[];
}

export interface GetMdbElasticsearchClusterConfigDataNodeResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbElasticsearchClusterConfigMasterNode {
    resources: outputs.GetMdbElasticsearchClusterConfigMasterNodeResource[];
}

export interface GetMdbElasticsearchClusterConfigMasterNodeResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbElasticsearchClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    name: string;
    subnetId: string;
    type: string;
    zone: string;
}

export interface GetMdbElasticsearchClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbGreenplumClusterAccess {
    dataLens: boolean;
    dataTransfer: boolean;
    webSql: boolean;
}

export interface GetMdbGreenplumClusterBackupWindowStart {
    hours: number;
    minutes: number;
}

export interface GetMdbGreenplumClusterCloudStorage {
    enable: boolean;
}

export interface GetMdbGreenplumClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbGreenplumClusterMasterHost {
    assignPublicIp: boolean;
    fqdn: string;
}

export interface GetMdbGreenplumClusterMasterSubcluster {
    resources: outputs.GetMdbGreenplumClusterMasterSubclusterResource[];
}

export interface GetMdbGreenplumClusterMasterSubclusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbGreenplumClusterPoolerConfig {
    poolClientIdleTimeout?: number;
    poolSize?: number;
    poolingMode?: string;
}

export interface GetMdbGreenplumClusterPxfConfig {
    connectionTimeout?: number;
    maxThreads?: number;
    poolAllowCoreThreadTimeout?: boolean;
    poolCoreSize?: number;
    poolMaxSize?: number;
    poolQueueCapacity?: number;
    uploadTimeout?: number;
    xms?: number;
    xmx?: number;
}

export interface GetMdbGreenplumClusterSegmentHost {
    fqdn: string;
}

export interface GetMdbGreenplumClusterSegmentSubcluster {
    resources: outputs.GetMdbGreenplumClusterSegmentSubclusterResource[];
}

export interface GetMdbGreenplumClusterSegmentSubclusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbKafkaClusterAccess {
    dataTransfer: boolean;
}

export interface GetMdbKafkaClusterConfig {
    access?: outputs.GetMdbKafkaClusterConfigAccess;
    assignPublicIp?: boolean;
    brokersCount?: number;
    diskSizeAutoscaling?: outputs.GetMdbKafkaClusterConfigDiskSizeAutoscaling;
    kafka: outputs.GetMdbKafkaClusterConfigKafka;
    schemaRegistry?: boolean;
    /**
     * @deprecated Deprecated
     */
    unmanagedTopics?: boolean;
    version: string;
    zones: string[];
    zookeeper?: outputs.GetMdbKafkaClusterConfigZookeeper;
}

export interface GetMdbKafkaClusterConfigAccess {
    dataTransfer?: boolean;
}

export interface GetMdbKafkaClusterConfigDiskSizeAutoscaling {
    diskSizeLimit: number;
    emergencyUsageThreshold?: number;
    plannedUsageThreshold?: number;
}

export interface GetMdbKafkaClusterConfigKafka {
    kafkaConfig?: outputs.GetMdbKafkaClusterConfigKafkaKafkaConfig;
    resources: outputs.GetMdbKafkaClusterConfigKafkaResources;
}

export interface GetMdbKafkaClusterConfigKafkaKafkaConfig {
    autoCreateTopicsEnable?: boolean;
    compressionType?: string;
    defaultReplicationFactor?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logFlushSchedulerIntervalMs?: string;
    logPreallocate?: boolean;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMinutes?: string;
    logRetentionMs?: string;
    logSegmentBytes?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    replicaFetchMaxBytes?: string;
    saslEnabledMechanisms?: string[];
    socketReceiveBufferBytes?: string;
    socketSendBufferBytes?: string;
    sslCipherSuites?: string[];
}

export interface GetMdbKafkaClusterConfigKafkaResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbKafkaClusterConfigZookeeper {
    resources?: outputs.GetMdbKafkaClusterConfigZookeeperResources;
}

export interface GetMdbKafkaClusterConfigZookeeperResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbKafkaClusterDiskSizeAutoscaling {
    diskSizeLimit: number;
    emergencyUsageThreshold: number;
    plannedUsageThreshold: number;
}

export interface GetMdbKafkaClusterHost {
    assignPublicIp: boolean;
    health: string;
    name: string;
    role: string;
    subnetId: string;
    zoneId: string;
}

export interface GetMdbKafkaClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbKafkaClusterTopic {
    name: string;
    partitions: number;
    replicationFactor: number;
    topicConfig?: outputs.GetMdbKafkaClusterTopicTopicConfig;
}

export interface GetMdbKafkaClusterTopicTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    maxMessageBytes?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: boolean;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
}

export interface GetMdbKafkaClusterUser {
    name: string;
    password: string;
    permissions?: outputs.GetMdbKafkaClusterUserPermission[];
}

export interface GetMdbKafkaClusterUserPermission {
    allowHosts?: string[];
    role: string;
    topicName: string;
}

export interface GetMdbKafkaConnectorConnectorConfigMirrormaker {
    replicationFactor: number;
    sourceClusters: outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceCluster[];
    targetClusters: outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetCluster[];
    topics: string;
}

export interface GetMdbKafkaConnectorConnectorConfigMirrormakerSourceCluster {
    alias: string;
    externalClusters: outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster[];
    thisClusters: outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisCluster[];
}

export interface GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster {
    bootstrapServers: string;
    saslMechanism: string;
    saslPassword: string;
    saslUsername: string;
    securityProtocol: string;
}

export interface GetMdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisCluster {
}

export interface GetMdbKafkaConnectorConnectorConfigMirrormakerTargetCluster {
    alias: string;
    externalClusters: outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster[];
    thisClusters: outputs.GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisCluster[];
}

export interface GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster {
    bootstrapServers: string;
    saslMechanism: string;
    saslPassword: string;
    saslUsername: string;
    securityProtocol: string;
}

export interface GetMdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisCluster {
}

export interface GetMdbKafkaConnectorConnectorConfigS3Sink {
    fileCompressionType: string;
    fileMaxRecords: number;
    s3Connections: outputs.GetMdbKafkaConnectorConnectorConfigS3SinkS3Connection[];
    topics: string;
}

export interface GetMdbKafkaConnectorConnectorConfigS3SinkS3Connection {
    bucketName: string;
    externalS3s: outputs.GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3[];
}

export interface GetMdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3 {
    accessKeyId: string;
    endpoint: string;
    region: string;
    secretAccessKey: string;
}

export interface GetMdbKafkaTopicTopicConfig {
    cleanupPolicy: string;
    compressionType: string;
    deleteRetentionMs: string;
    fileDeleteDelayMs: string;
    flushMessages: string;
    flushMs: string;
    maxMessageBytes: string;
    minCompactionLagMs: string;
    minInsyncReplicas: string;
    preallocate: boolean;
    retentionBytes: string;
    retentionMs: string;
    segmentBytes: string;
}

export interface GetMdbKafkaUserPermission {
    allowHosts: string[];
    role: string;
    topicName: string;
}

export interface GetMdbMongodbClusterClusterConfig {
    access?: outputs.GetMdbMongodbClusterClusterConfigAccess;
    backupRetainPeriodDays: number;
    backupWindowStart?: outputs.GetMdbMongodbClusterClusterConfigBackupWindowStart;
    featureCompatibilityVersion: string;
    mongocfg?: outputs.GetMdbMongodbClusterClusterConfigMongocfg;
    mongod?: outputs.GetMdbMongodbClusterClusterConfigMongod;
    mongos?: outputs.GetMdbMongodbClusterClusterConfigMongos;
    performanceDiagnostics?: outputs.GetMdbMongodbClusterClusterConfigPerformanceDiagnostics;
    version?: string;
}

export interface GetMdbMongodbClusterClusterConfigAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
}

export interface GetMdbMongodbClusterClusterConfigBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongocfg {
    net?: outputs.GetMdbMongodbClusterClusterConfigMongocfgNet;
    operationProfiling?: outputs.GetMdbMongodbClusterClusterConfigMongocfgOperationProfiling;
    storage?: outputs.GetMdbMongodbClusterClusterConfigMongocfgStorage;
}

export interface GetMdbMongodbClusterClusterConfigMongocfgNet {
    maxIncomingConnections?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongocfgOperationProfiling {
    mode?: string;
    slowOpThreshold?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongocfgStorage {
    wiredTiger?: outputs.GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTiger;
}

export interface GetMdbMongodbClusterClusterConfigMongocfgStorageWiredTiger {
    cacheSizeGb?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongod {
    auditLog?: outputs.GetMdbMongodbClusterClusterConfigMongodAuditLog;
    net?: outputs.GetMdbMongodbClusterClusterConfigMongodNet;
    operationProfiling?: outputs.GetMdbMongodbClusterClusterConfigMongodOperationProfiling;
    security?: outputs.GetMdbMongodbClusterClusterConfigMongodSecurity;
    setParameter?: outputs.GetMdbMongodbClusterClusterConfigMongodSetParameter;
    storage?: outputs.GetMdbMongodbClusterClusterConfigMongodStorage;
}

export interface GetMdbMongodbClusterClusterConfigMongodAuditLog {
    filter?: string;
    runtimeConfiguration?: boolean;
}

export interface GetMdbMongodbClusterClusterConfigMongodNet {
    compressors?: string[];
    maxIncomingConnections?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongodOperationProfiling {
    mode?: string;
    slowOpSampleRate?: number;
    slowOpThreshold?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongodSecurity {
    enableEncryption?: boolean;
    kmip?: outputs.GetMdbMongodbClusterClusterConfigMongodSecurityKmip;
}

export interface GetMdbMongodbClusterClusterConfigMongodSecurityKmip {
    clientCertificate?: string;
    keyIdentifier?: string;
    port?: number;
    serverCa?: string;
    serverName?: string;
}

export interface GetMdbMongodbClusterClusterConfigMongodSetParameter {
    auditAuthorizationSuccess?: boolean;
    enableFlowControl?: boolean;
    minSnapshotHistoryWindowInSeconds?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongodStorage {
    journal?: outputs.GetMdbMongodbClusterClusterConfigMongodStorageJournal;
    wiredTiger?: outputs.GetMdbMongodbClusterClusterConfigMongodStorageWiredTiger;
}

export interface GetMdbMongodbClusterClusterConfigMongodStorageJournal {
    commitInterval?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongodStorageWiredTiger {
    blockCompressor?: string;
    cacheSizeGb?: number;
    prefixCompression?: boolean;
}

export interface GetMdbMongodbClusterClusterConfigMongos {
    net?: outputs.GetMdbMongodbClusterClusterConfigMongosNet;
}

export interface GetMdbMongodbClusterClusterConfigMongosNet {
    compressors?: string[];
    maxIncomingConnections?: number;
}

export interface GetMdbMongodbClusterClusterConfigPerformanceDiagnostics {
    enabled?: boolean;
}

export interface GetMdbMongodbClusterDatabase {
    name?: string;
}

export interface GetMdbMongodbClusterHost {
    assignPublicIp?: boolean;
    health: string;
    hostParameters?: outputs.GetMdbMongodbClusterHostHostParameters;
    name: string;
    role: string;
    shardName: string;
    subnetId?: string;
    type?: string;
    zoneId?: string;
}

export interface GetMdbMongodbClusterHostHostParameters {
    hidden?: boolean;
    priority?: number;
    secondaryDelaySecs?: number;
    tags?: {[key: string]: string};
}

export interface GetMdbMongodbClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type?: string;
}

export interface GetMdbMongodbClusterResources {
    diskSize?: number;
    diskTypeId?: string;
    resourcePresetId?: string;
}

export interface GetMdbMongodbClusterResourcesMongocfg {
    diskSize?: number;
    diskTypeId?: string;
    resourcePresetId?: string;
}

export interface GetMdbMongodbClusterResourcesMongod {
    diskSize?: number;
    diskTypeId?: string;
    resourcePresetId?: string;
}

export interface GetMdbMongodbClusterResourcesMongoinfra {
    diskSize?: number;
    diskTypeId?: string;
    resourcePresetId?: string;
}

export interface GetMdbMongodbClusterResourcesMongos {
    diskSize?: number;
    diskTypeId?: string;
    resourcePresetId?: string;
}

export interface GetMdbMongodbClusterRestore {
    backupId?: string;
    time?: string;
}

export interface GetMdbMongodbClusterUser {
    name?: string;
    password?: string;
    permissions?: outputs.GetMdbMongodbClusterUserPermission[];
}

export interface GetMdbMongodbClusterUserPermission {
    databaseName?: string;
    roles?: string[];
}

export interface GetMdbMongodbUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface GetMdbMysqlClusterAccess {
    dataLens: boolean;
    dataTransfer: boolean;
    webSql: boolean;
}

export interface GetMdbMysqlClusterBackupWindowStart {
    hours: number;
    minutes: number;
}

export interface GetMdbMysqlClusterDatabase {
    name: string;
}

export interface GetMdbMysqlClusterHost {
    assignPublicIp: boolean;
    backupPriority: number;
    fqdn: string;
    priority: number;
    replicationSource: string;
    subnetId: string;
    zone: string;
}

export interface GetMdbMysqlClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbMysqlClusterPerformanceDiagnostic {
    enabled: boolean;
    sessionsSamplingInterval: number;
    statementsSamplingInterval: number;
}

export interface GetMdbMysqlClusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbMysqlClusterUser {
    authenticationPlugin: string;
    connectionLimits: outputs.GetMdbMysqlClusterUserConnectionLimit[];
    globalPermissions: string[];
    name: string;
    password: string;
    permissions: outputs.GetMdbMysqlClusterUserPermission[];
}

export interface GetMdbMysqlClusterUserConnectionLimit {
    maxConnectionsPerHour: number;
    maxQuestionsPerHour: number;
    maxUpdatesPerHour: number;
    maxUserConnections: number;
}

export interface GetMdbMysqlClusterUserPermission {
    databaseName: string;
    roles: string[];
}

export interface GetMdbMysqlUserConnectionLimit {
    maxConnectionsPerHour: number;
    maxQuestionsPerHour: number;
    maxUpdatesPerHour: number;
    maxUserConnections: number;
}

export interface GetMdbMysqlUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface GetMdbOpensearchClusterAuthSettings {
    saml: outputs.GetMdbOpensearchClusterAuthSettingsSaml;
}

export interface GetMdbOpensearchClusterAuthSettingsSaml {
    dashboardsUrl: string;
    enabled: boolean;
    idpEntityId: string;
    idpMetadataFileContent: string;
    rolesKey: string;
    spEntityId: string;
    subjectKey: string;
}

export interface GetMdbOpensearchClusterConfig {
    access?: outputs.GetMdbOpensearchClusterConfigAccess;
    adminPassword: string;
    dashboards?: outputs.GetMdbOpensearchClusterConfigDashboards;
    opensearch?: outputs.GetMdbOpensearchClusterConfigOpensearch;
    version: string;
}

export interface GetMdbOpensearchClusterConfigAccess {
    dataTransfer: boolean;
    serverless: boolean;
}

export interface GetMdbOpensearchClusterConfigDashboards {
    nodeGroups?: outputs.GetMdbOpensearchClusterConfigDashboardsNodeGroup[];
}

export interface GetMdbOpensearchClusterConfigDashboardsNodeGroup {
    assignPublicIp: boolean;
    hostsCount: number;
    name: string;
    resources?: outputs.GetMdbOpensearchClusterConfigDashboardsNodeGroupResources;
    subnetIds: string[];
    zoneIds: string[];
}

export interface GetMdbOpensearchClusterConfigDashboardsNodeGroupResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbOpensearchClusterConfigOpensearch {
    nodeGroups?: outputs.GetMdbOpensearchClusterConfigOpensearchNodeGroup[];
    plugins: string[];
}

export interface GetMdbOpensearchClusterConfigOpensearchNodeGroup {
    assignPublicIp: boolean;
    hostsCount: number;
    name: string;
    resources?: outputs.GetMdbOpensearchClusterConfigOpensearchNodeGroupResources;
    roles: string[];
    subnetIds: string[];
    zoneIds: string[];
}

export interface GetMdbOpensearchClusterConfigOpensearchNodeGroupResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbOpensearchClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    nodeGroup: string;
    roles: string[];
    subnetId: string;
    type: string;
    zone: string;
}

export interface GetMdbOpensearchClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbOpensearchClusterTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface GetMdbPostgresqlClusterConfig {
    accesses: outputs.GetMdbPostgresqlClusterConfigAccess[];
    autofailover: boolean;
    backupRetainPeriodDays: number;
    backupWindowStarts: outputs.GetMdbPostgresqlClusterConfigBackupWindowStart[];
    diskSizeAutoscalings: outputs.GetMdbPostgresqlClusterConfigDiskSizeAutoscaling[];
    performanceDiagnostics: outputs.GetMdbPostgresqlClusterConfigPerformanceDiagnostic[];
    poolerConfigs: outputs.GetMdbPostgresqlClusterConfigPoolerConfig[];
    postgresqlConfig: {[key: string]: string};
    resources: outputs.GetMdbPostgresqlClusterConfigResource[];
    version: string;
}

export interface GetMdbPostgresqlClusterConfigAccess {
    dataLens: boolean;
    dataTransfer: boolean;
    serverless: boolean;
    webSql: boolean;
}

export interface GetMdbPostgresqlClusterConfigBackupWindowStart {
    hours: number;
    minutes: number;
}

export interface GetMdbPostgresqlClusterConfigDiskSizeAutoscaling {
    diskSizeLimit: number;
    emergencyUsageThreshold: number;
    plannedUsageThreshold: number;
}

export interface GetMdbPostgresqlClusterConfigPerformanceDiagnostic {
    enabled: boolean;
    sessionsSamplingInterval: number;
    statementsSamplingInterval: number;
}

export interface GetMdbPostgresqlClusterConfigPoolerConfig {
    poolDiscard: boolean;
    poolingMode: string;
}

export interface GetMdbPostgresqlClusterConfigResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbPostgresqlClusterDatabase {
    extensions: outputs.GetMdbPostgresqlClusterDatabaseExtension[];
    lcCollate: string;
    lcType: string;
    name: string;
    owner: string;
    templateDb: string;
}

export interface GetMdbPostgresqlClusterDatabaseExtension {
    name: string;
    version: string;
}

export interface GetMdbPostgresqlClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    priority: number;
    replicationSource: string;
    role: string;
    subnetId: string;
    zone: string;
}

export interface GetMdbPostgresqlClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbPostgresqlClusterUser {
    connLimit: number;
    grants: string[];
    login: boolean;
    name: string;
    permissions: outputs.GetMdbPostgresqlClusterUserPermission[];
    settings: {[key: string]: string};
}

export interface GetMdbPostgresqlClusterUserPermission {
    databaseName: string;
}

export interface GetMdbPostgresqlDatabaseExtension {
    name: string;
    version?: string;
}

export interface GetMdbPostgresqlUserPermission {
    databaseName: string;
}

export interface GetMdbRedisClusterConfig {
    clientOutputBufferLimitNormal: string;
    clientOutputBufferLimitPubsub: string;
    databases: number;
    maxmemoryPercent: number;
    maxmemoryPolicy: string;
    notifyKeyspaceEvents: string;
    slowlogLogSlowerThan: number;
    slowlogMaxLen: number;
    timeout: number;
    version: string;
}

export interface GetMdbRedisClusterDiskSizeAutoscaling {
    diskSizeLimit: number;
    emergencyUsageThreshold: number;
    plannedUsageThreshold: number;
}

export interface GetMdbRedisClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    replicaPriority: number;
    shardName: string;
    subnetId: string;
    zone: string;
}

export interface GetMdbRedisClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbRedisClusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbSqlserverClusterBackupWindowStart {
    hours: number;
    minutes: number;
}

export interface GetMdbSqlserverClusterDatabase {
    name: string;
}

export interface GetMdbSqlserverClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    subnetId: string;
    zone: string;
}

export interface GetMdbSqlserverClusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbSqlserverClusterUser {
    name: string;
    password: string;
    permissions: outputs.GetMdbSqlserverClusterUserPermission[];
}

export interface GetMdbSqlserverClusterUserPermission {
    databaseName: string;
    roles: string[];
}

export interface GetMonitoringDashboardParametrization {
    parameters: outputs.GetMonitoringDashboardParametrizationParameter[];
    selectors: string;
}

export interface GetMonitoringDashboardParametrizationParameter {
    customs: outputs.GetMonitoringDashboardParametrizationParameterCustom[];
    description: string;
    hidden: boolean;
    id: string;
    labelValues: outputs.GetMonitoringDashboardParametrizationParameterLabelValue[];
    texts: outputs.GetMonitoringDashboardParametrizationParameterText[];
    title: string;
}

export interface GetMonitoringDashboardParametrizationParameterCustom {
    defaultValues: string[];
    multiselectable: boolean;
    values: string[];
}

export interface GetMonitoringDashboardParametrizationParameterLabelValue {
    defaultValues: string[];
    folderId: string;
    labelKey: string;
    multiselectable: boolean;
    selectors: string;
}

export interface GetMonitoringDashboardParametrizationParameterText {
    defaultValue: string;
}

export interface GetMonitoringDashboardWidget {
    charts: outputs.GetMonitoringDashboardWidgetChart[];
    positions: outputs.GetMonitoringDashboardWidgetPosition[];
    texts: outputs.GetMonitoringDashboardWidgetText[];
    titles: outputs.GetMonitoringDashboardWidgetTitle[];
}

export interface GetMonitoringDashboardWidgetChart {
    chartId: string;
    description: string;
    displayLegend: boolean;
    freeze: string;
    nameHidingSettings: outputs.GetMonitoringDashboardWidgetChartNameHidingSetting[];
    queries: outputs.GetMonitoringDashboardWidgetChartQuery[];
    seriesOverrides: outputs.GetMonitoringDashboardWidgetChartSeriesOverride[];
    title: string;
    visualizationSettings: outputs.GetMonitoringDashboardWidgetChartVisualizationSetting[];
}

export interface GetMonitoringDashboardWidgetChartNameHidingSetting {
    names: string[];
    positive: boolean;
}

export interface GetMonitoringDashboardWidgetChartQuery {
    downsamplings: outputs.GetMonitoringDashboardWidgetChartQueryDownsampling[];
    targets: outputs.GetMonitoringDashboardWidgetChartQueryTarget[];
}

export interface GetMonitoringDashboardWidgetChartQueryDownsampling {
    disabled: boolean;
    gapFilling: string;
    gridAggregation: string;
    gridInterval: number;
    maxPoints: number;
}

export interface GetMonitoringDashboardWidgetChartQueryTarget {
    hidden: boolean;
    query: string;
    textMode: boolean;
}

export interface GetMonitoringDashboardWidgetChartSeriesOverride {
    name: string;
    settings: outputs.GetMonitoringDashboardWidgetChartSeriesOverrideSetting[];
    targetIndex: string;
}

export interface GetMonitoringDashboardWidgetChartSeriesOverrideSetting {
    color: string;
    growDown: boolean;
    name: string;
    stackName: string;
    type: string;
    yaxisPosition: string;
}

export interface GetMonitoringDashboardWidgetChartVisualizationSetting {
    aggregation: string;
    colorSchemeSettings: outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSetting[];
    heatmapSettings: outputs.GetMonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting[];
    interpolate: string;
    normalize: boolean;
    showLabels: boolean;
    title: string;
    type: string;
    yaxisSettings: outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSetting[];
}

export interface GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSetting {
    automatics: outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomatic[];
    gradients: outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient[];
    standards: outputs.GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandard[];
}

export interface GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomatic {
}

export interface GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient {
    greenValue: string;
    redValue: string;
    violetValue: string;
    yellowValue: string;
}

export interface GetMonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandard {
}

export interface GetMonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting {
    greenValue: string;
    redValue: string;
    violetValue: string;
    yellowValue: string;
}

export interface GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSetting {
    lefts: outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft[];
    rights: outputs.GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight[];
}

export interface GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft {
    max: string;
    min: string;
    precision: number;
    title: string;
    type: string;
    unitFormat: string;
}

export interface GetMonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight {
    max: string;
    min: string;
    precision: number;
    title: string;
    type: string;
    unitFormat: string;
}

export interface GetMonitoringDashboardWidgetPosition {
    h: number;
    w: number;
    x: number;
    y: number;
}

export interface GetMonitoringDashboardWidgetText {
    text: string;
}

export interface GetMonitoringDashboardWidgetTitle {
    size: string;
    text: string;
}

export interface GetOrganizationmanagerGroupMember {
    id: string;
    type: string;
}

export interface GetOrganizationmanagerOsLoginSettingsSshCertificateSettings {
    enabled?: boolean;
}

export interface GetOrganizationmanagerOsLoginSettingsUserSshKeySettings {
    allowManageOwnKeys?: boolean;
    enabled?: boolean;
}

export interface GetOrganizationmanagerSamlFederationSecuritySetting {
    encryptedAssertions: boolean;
}

export interface GetServerlessContainerConnectivity {
    networkId: string;
}

export interface GetServerlessContainerImage {
    args: string[];
    commands: string[];
    digest: string;
    environment: {[key: string]: string};
    url: string;
    workDir: string;
}

export interface GetServerlessContainerLogOption {
    disabled: boolean;
    folderId: string;
    logGroupId: string;
    minLevel: string;
}

export interface GetServerlessContainerSecret {
    environmentVariable: string;
    id: string;
    key: string;
    versionId: string;
}

export interface GetServerlessContainerStorageMount {
    bucket: string;
    mountPointPath: string;
    prefix?: string;
    readOnly?: boolean;
}

export interface GetSmartcaptchaCaptchaOverrideVariant {
    challengeType: string;
    complexity: string;
    description: string;
    preCheckType: string;
    uuid: string;
}

export interface GetSmartcaptchaCaptchaSecurityRule {
    conditions: outputs.GetSmartcaptchaCaptchaSecurityRuleCondition[];
    description: string;
    name: string;
    overrideVariantUuid: string;
    priority: number;
}

export interface GetSmartcaptchaCaptchaSecurityRuleCondition {
    headers: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHeader[];
    hosts: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHost[];
    sourceIps: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIp[];
    uris: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUri[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionHeader {
    name: string;
    values: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHeaderValue[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionHeaderValue {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionHost {
    hosts: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionHostHost[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionHostHost {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionSourceIp {
    geoIpMatches: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatch[];
    geoIpNotMatches: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatch[];
    ipRangesMatches: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch[];
    ipRangesNotMatches: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatch {
    locations: string[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatch {
    locations: string[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch {
    ipRanges: string[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch {
    ipRanges: string[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionUri {
    paths: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriPath[];
    queries: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriQuery[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionUriPath {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionUriQuery {
    key: string;
    values: outputs.GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryValue[];
}

export interface GetSmartcaptchaCaptchaSecurityRuleConditionUriQueryValue {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRule {
    description: string;
    dryRun: boolean;
    name: string;
    priority: number;
    ruleConditions: outputs.GetSwsSecurityProfileSecurityRuleRuleCondition[];
    smartProtections: outputs.GetSwsSecurityProfileSecurityRuleSmartProtection[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleCondition {
    action: string;
    conditions: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionCondition[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionCondition {
    authorities: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthority[];
    headers: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeader[];
    httpMethods: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod[];
    requestUris: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUri[];
    sourceIps: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthority {
    authorities: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeader {
    name: string;
    values: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod {
    httpMethods: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUri {
    paths: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath[];
    queries: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQuery[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQuery {
    key: string;
    values: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp {
    geoIpMatches: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatch[];
    geoIpNotMatches: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatch[];
    ipRangesMatches: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch[];
    ipRangesNotMatches: outputs.GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatch {
    locations: string[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatch {
    locations: string[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch {
    ipRanges: string[];
}

export interface GetSwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch {
    ipRanges: string[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtection {
    conditions: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionCondition[];
    mode: string;
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionCondition {
    authorities: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthority[];
    headers: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeader[];
    httpMethods: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod[];
    requestUris: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUri[];
    sourceIps: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthority {
    authorities: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeader {
    name: string;
    values: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod {
    httpMethods: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUri {
    paths: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath[];
    queries: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQuery[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQuery {
    key: string;
    values: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue {
    exactMatch: string;
    exactNotMatch: string;
    pireRegexMatch: string;
    pireRegexNotMatch: string;
    prefixMatch: string;
    prefixNotMatch: string;
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp {
    geoIpMatches: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatch[];
    geoIpNotMatches: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatch[];
    ipRangesMatches: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch[];
    ipRangesNotMatches: outputs.GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatch {
    locations: string[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatch {
    locations: string[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch {
    ipRanges: string[];
}

export interface GetSwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch {
    ipRanges: string[];
}

export interface GetVpcAddressDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetVpcAddressExternalIpv4Address {
    address: string;
    ddosProtectionProvider: string;
    outgoingSmtpCapability: string;
    zoneId: string;
}

export interface GetVpcGatewaySharedEgressGateway {
}

export interface GetVpcRouteTableStaticRoute {
    destinationPrefix: string;
    gatewayId: string;
    nextHopAddress: string;
}

export interface GetVpcSecurityGroupEgress {
    description: string;
    fromPort: number;
    id: string;
    labels: {[key: string]: string};
    port: number;
    predefinedTarget: string;
    protocol: string;
    securityGroupId: string;
    toPort: number;
    v4CidrBlocks: string[];
    v6CidrBlocks: string[];
}

export interface GetVpcSecurityGroupIngress {
    description: string;
    fromPort: number;
    id: string;
    labels: {[key: string]: string};
    port: number;
    predefinedTarget: string;
    protocol: string;
    securityGroupId: string;
    toPort: number;
    v4CidrBlocks: string[];
    v6CidrBlocks: string[];
}

export interface GetVpcSubnetDhcpOption {
    domainName: string;
    domainNameServers: string[];
    ntpServers: string[];
}

export interface GetYdbDatabaseDedicatedLocation {
    regions: outputs.GetYdbDatabaseDedicatedLocationRegion[];
    zones: outputs.GetYdbDatabaseDedicatedLocationZone[];
}

export interface GetYdbDatabaseDedicatedLocationRegion {
    id: string;
}

export interface GetYdbDatabaseDedicatedLocationZone {
    id: string;
}

export interface GetYdbDatabaseDedicatedScalePolicy {
    fixedScales: outputs.GetYdbDatabaseDedicatedScalePolicyFixedScale[];
}

export interface GetYdbDatabaseDedicatedScalePolicyFixedScale {
    size: number;
}

export interface GetYdbDatabaseDedicatedStorageConfig {
    groupCount: number;
    storageTypeId: string;
}

export interface GetYdbDatabaseServerlessServerlessDatabase {
    enableThrottlingRcuLimit: boolean;
    provisionedRcuLimit: number;
    storageSizeLimit: number;
    throttlingRcuLimit: number;
}

export interface IamServiceAccountApiKeyOutputToLockbox {
    /**
     * entry that will store the value of secret_key
     */
    entryForSecretKey: string;
    /**
     * secret where to add the version with the sensitive values
     */
    secretId: string;
}

export interface IamServiceAccountIamBindingTimeouts {
    default?: string;
}

export interface IamServiceAccountIamMemberTimeouts {
    default?: string;
}

export interface IamServiceAccountIamPolicyTimeouts {
    default?: string;
}

export interface IamServiceAccountKeyOutputToLockbox {
    /**
     * entry that will store the value of private_key
     */
    entryForPrivateKey: string;
    /**
     * secret where to add the version with the sensitive values
     */
    secretId: string;
}

export interface IamServiceAccountStaticAccessKeyOutputToLockbox {
    /**
     * entry that will store the value of secret_key
     */
    entryForSecretKey: string;
    /**
     * secret where to add the version with the sensitive values
     */
    secretId: string;
}

export interface IamServiceAccountTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface IotCoreBrokerLogOptions {
    disabled?: boolean;
    folderId?: string;
    logGroupId?: string;
    minLevel?: string;
}

export interface IotCoreBrokerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface IotCoreDeviceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface IotCoreRegistryLogOptions {
    disabled?: boolean;
    folderId?: string;
    logGroupId?: string;
    minLevel?: string;
}

export interface IotCoreRegistryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KmsAsymmetricEncryptionKeyIamBindingTimeouts {
    default?: string;
}

export interface KmsAsymmetricEncryptionKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KmsAsymmetricSignatureKeyIamBindingTimeouts {
    default?: string;
}

export interface KmsAsymmetricSignatureKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KmsSecretCiphertextTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface KmsSymmetricKeyIamBindingTimeouts {
    default?: string;
}

export interface KmsSymmetricKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesClusterKmsProvider {
    keyId?: string;
}

export interface KubernetesClusterMaster {
    clusterCaCertificate: string;
    etcdClusterSize: number;
    externalV4Address: string;
    externalV4Endpoint: string;
    externalV6Address?: string;
    externalV6Endpoint: string;
    internalV4Address: string;
    internalV4Endpoint: string;
    maintenancePolicy?: outputs.KubernetesClusterMasterMaintenancePolicy;
    masterLocations?: outputs.KubernetesClusterMasterMasterLocation[];
    masterLogging?: outputs.KubernetesClusterMasterMasterLogging;
    publicIp: boolean;
    regional?: outputs.KubernetesClusterMasterRegional;
    securityGroupIds?: string[];
    version: string;
    versionInfos: outputs.KubernetesClusterMasterVersionInfo[];
    zonal?: outputs.KubernetesClusterMasterZonal;
}

export interface KubernetesClusterMasterMaintenancePolicy {
    autoUpgrade: boolean;
    maintenanceWindows?: outputs.KubernetesClusterMasterMaintenancePolicyMaintenanceWindow[];
}

export interface KubernetesClusterMasterMaintenancePolicyMaintenanceWindow {
    day: string;
    duration: string;
    startTime: string;
}

export interface KubernetesClusterMasterMasterLocation {
    subnetId: string;
    zone: string;
}

export interface KubernetesClusterMasterMasterLogging {
    auditEnabled?: boolean;
    clusterAutoscalerEnabled?: boolean;
    enabled?: boolean;
    eventsEnabled?: boolean;
    folderId?: string;
    kubeApiserverEnabled?: boolean;
    logGroupId?: string;
}

export interface KubernetesClusterMasterRegional {
    locations?: outputs.KubernetesClusterMasterRegionalLocation[];
    region: string;
}

export interface KubernetesClusterMasterRegionalLocation {
    subnetId?: string;
    zone?: string;
}

export interface KubernetesClusterMasterVersionInfo {
    currentVersion: string;
    newRevisionAvailable: boolean;
    newRevisionSummary: string;
    versionDeprecated: boolean;
}

export interface KubernetesClusterMasterZonal {
    subnetId?: string;
    zone: string;
}

export interface KubernetesClusterNetworkImplementation {
    cilium?: outputs.KubernetesClusterNetworkImplementationCilium;
}

export interface KubernetesClusterNetworkImplementationCilium {
}

export interface KubernetesClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesNodeGroupAllocationPolicy {
    locations?: outputs.KubernetesNodeGroupAllocationPolicyLocation[];
}

export interface KubernetesNodeGroupAllocationPolicyLocation {
    /**
     * @deprecated Deprecated
     */
    subnetId: string;
    zone: string;
}

export interface KubernetesNodeGroupDeployPolicy {
    maxExpansion: number;
    maxUnavailable: number;
}

export interface KubernetesNodeGroupInstanceTemplate {
    bootDisk?: outputs.KubernetesNodeGroupInstanceTemplateBootDisk;
    containerNetwork?: outputs.KubernetesNodeGroupInstanceTemplateContainerNetwork;
    containerRuntime?: outputs.KubernetesNodeGroupInstanceTemplateContainerRuntime;
    gpuSettings?: outputs.KubernetesNodeGroupInstanceTemplateGpuSettings;
    labels?: {[key: string]: string};
    metadata: {[key: string]: string};
    name?: string;
    /**
     * @deprecated Deprecated
     */
    nat: boolean;
    networkAccelerationType: string;
    networkInterfaces?: outputs.KubernetesNodeGroupInstanceTemplateNetworkInterface[];
    placementPolicy?: outputs.KubernetesNodeGroupInstanceTemplatePlacementPolicy;
    platformId: string;
    resources?: outputs.KubernetesNodeGroupInstanceTemplateResources;
    schedulingPolicy?: outputs.KubernetesNodeGroupInstanceTemplateSchedulingPolicy;
}

export interface KubernetesNodeGroupInstanceTemplateBootDisk {
    size: number;
    type: string;
}

export interface KubernetesNodeGroupInstanceTemplateContainerNetwork {
    podMtu: number;
}

export interface KubernetesNodeGroupInstanceTemplateContainerRuntime {
    type: string;
}

export interface KubernetesNodeGroupInstanceTemplateGpuSettings {
    gpuClusterId?: string;
    gpuEnvironment: string;
}

export interface KubernetesNodeGroupInstanceTemplateNetworkInterface {
    ipv4?: boolean;
    ipv4DnsRecords?: outputs.KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord[];
    ipv6: boolean;
    ipv6DnsRecords?: outputs.KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord[];
    nat: boolean;
    securityGroupIds?: string[];
    subnetIds: string[];
}

export interface KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface KubernetesNodeGroupInstanceTemplatePlacementPolicy {
    placementGroupId: string;
}

export interface KubernetesNodeGroupInstanceTemplateResources {
    coreFraction: number;
    cores: number;
    gpus?: number;
    memory: number;
}

export interface KubernetesNodeGroupInstanceTemplateSchedulingPolicy {
    preemptible: boolean;
}

export interface KubernetesNodeGroupMaintenancePolicy {
    autoRepair: boolean;
    autoUpgrade: boolean;
    maintenanceWindows?: outputs.KubernetesNodeGroupMaintenancePolicyMaintenanceWindow[];
}

export interface KubernetesNodeGroupMaintenancePolicyMaintenanceWindow {
    day: string;
    duration: string;
    startTime: string;
}

export interface KubernetesNodeGroupScalePolicy {
    autoScale?: outputs.KubernetesNodeGroupScalePolicyAutoScale;
    fixedScale?: outputs.KubernetesNodeGroupScalePolicyFixedScale;
}

export interface KubernetesNodeGroupScalePolicyAutoScale {
    initial: number;
    max: number;
    min: number;
}

export interface KubernetesNodeGroupScalePolicyFixedScale {
    size: number;
}

export interface KubernetesNodeGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesNodeGroupVersionInfo {
    currentVersion: string;
    newRevisionAvailable: boolean;
    newRevisionSummary: string;
    versionDeprecated: boolean;
}

export interface LbNetworkLoadBalancerAttachedTargetGroup {
    healthchecks: outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheck[];
    targetGroupId: string;
}

export interface LbNetworkLoadBalancerAttachedTargetGroupHealthcheck {
    healthyThreshold?: number;
    httpOptions?: outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions;
    interval?: number;
    name: string;
    tcpOptions?: outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions;
    timeout?: number;
    unhealthyThreshold?: number;
}

export interface LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions {
    path?: string;
    port: number;
}

export interface LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions {
    port: number;
}

export interface LbNetworkLoadBalancerListener {
    externalAddressSpec?: outputs.LbNetworkLoadBalancerListenerExternalAddressSpec;
    internalAddressSpec?: outputs.LbNetworkLoadBalancerListenerInternalAddressSpec;
    name: string;
    port: number;
    protocol: string;
    targetPort: number;
}

export interface LbNetworkLoadBalancerListenerExternalAddressSpec {
    address: string;
    ipVersion?: string;
}

export interface LbNetworkLoadBalancerListenerInternalAddressSpec {
    address: string;
    ipVersion?: string;
    subnetId: string;
}

export interface LbNetworkLoadBalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LbTargetGroupTarget {
    address: string;
    subnetId: string;
}

export interface LbTargetGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LoadtestingAgentComputeInstance {
    bootDisk: outputs.LoadtestingAgentComputeInstanceBootDisk;
    computedMetadata: {[key: string]: string};
    labels?: {[key: string]: string};
    metadata?: {[key: string]: string};
    networkInterfaces: outputs.LoadtestingAgentComputeInstanceNetworkInterface[];
    platformId: string;
    resources: outputs.LoadtestingAgentComputeInstanceResources;
    serviceAccountId: string;
    zoneId: string;
}

export interface LoadtestingAgentComputeInstanceBootDisk {
    autoDelete?: boolean;
    deviceName: string;
    diskId: string;
    initializeParams: outputs.LoadtestingAgentComputeInstanceBootDiskInitializeParams;
}

export interface LoadtestingAgentComputeInstanceBootDiskInitializeParams {
    blockSize: number;
    description: string;
    name: string;
    size?: number;
    type?: string;
}

export interface LoadtestingAgentComputeInstanceNetworkInterface {
    index: number;
    ipAddress: string;
    ipv4?: boolean;
    ipv6: boolean;
    ipv6Address: string;
    macAddress: string;
    nat?: boolean;
    natIpAddress: string;
    natIpVersion: string;
    securityGroupIds: string[];
    subnetId: string;
}

export interface LoadtestingAgentComputeInstanceResources {
    coreFraction?: number;
    cores?: number;
    memory?: number;
}

export interface LoadtestingAgentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LockboxSecretIamBindingTimeouts {
    default?: string;
}

export interface LockboxSecretTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LockboxSecretVersionEntry {
    command?: outputs.LockboxSecretVersionEntryCommand;
    key: string;
    textValue?: string;
}

export interface LockboxSecretVersionEntryCommand {
    args?: string[];
    env?: {[key: string]: string};
    path: string;
}

export interface LockboxSecretVersionHashedTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface LockboxSecretVersionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface LoggingGroupTimeouts {
    default?: string;
}

export interface MdbClickhouseClusterAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
    metrika?: boolean;
    serverless?: boolean;
    webSql?: boolean;
    yandexQuery?: boolean;
}

export interface MdbClickhouseClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbClickhouseClusterClickhouse {
    config?: outputs.MdbClickhouseClusterClickhouseConfig;
    resources?: outputs.MdbClickhouseClusterClickhouseResources;
}

export interface MdbClickhouseClusterClickhouseConfig {
    backgroundFetchesPoolSize: number;
    backgroundMergesMutationsConcurrencyRatio: number;
    backgroundMessageBrokerSchedulePoolSize: number;
    backgroundPoolSize: number;
    backgroundSchedulePoolSize: number;
    compressions?: outputs.MdbClickhouseClusterClickhouseConfigCompression[];
    defaultDatabase: string;
    geobaseEnabled: boolean;
    geobaseUri: string;
    graphiteRollups?: outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollup[];
    kafka?: outputs.MdbClickhouseClusterClickhouseConfigKafka;
    kafkaTopics?: outputs.MdbClickhouseClusterClickhouseConfigKafkaTopic[];
    keepAliveTimeout: number;
    logLevel: string;
    markCacheSize: number;
    maxConcurrentQueries: number;
    maxConnections: number;
    maxPartitionSizeToDrop: number;
    maxTableSizeToDrop: number;
    mergeTree?: outputs.MdbClickhouseClusterClickhouseConfigMergeTree;
    metricLogEnabled: boolean;
    metricLogRetentionSize: number;
    metricLogRetentionTime: number;
    partLogRetentionSize: number;
    partLogRetentionTime: number;
    queryLogRetentionSize: number;
    queryLogRetentionTime: number;
    queryThreadLogEnabled: boolean;
    queryThreadLogRetentionSize: number;
    queryThreadLogRetentionTime: number;
    rabbitmq?: outputs.MdbClickhouseClusterClickhouseConfigRabbitmq;
    textLogEnabled: boolean;
    textLogLevel: string;
    textLogRetentionSize: number;
    textLogRetentionTime: number;
    timezone: string;
    totalMemoryProfilerStep: number;
    traceLogEnabled: boolean;
    traceLogRetentionSize: number;
    traceLogRetentionTime: number;
    uncompressedCacheSize: number;
}

export interface MdbClickhouseClusterClickhouseConfigCompression {
    level?: number;
    method: string;
    minPartSize: number;
    minPartSizeRatio: number;
}

export interface MdbClickhouseClusterClickhouseConfigGraphiteRollup {
    name: string;
    patterns?: outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern[];
}

export interface MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern {
    function: string;
    regexp: string;
    retentions?: outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention[];
}

export interface MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention {
    age: number;
    precision: number;
}

export interface MdbClickhouseClusterClickhouseConfigKafka {
    enableSslCertificateVerification: boolean;
    maxPollIntervalMs: number;
    saslMechanism: string;
    saslPassword: string;
    saslUsername: string;
    securityProtocol: string;
    sessionTimeoutMs: number;
}

export interface MdbClickhouseClusterClickhouseConfigKafkaTopic {
    name: string;
    settings?: outputs.MdbClickhouseClusterClickhouseConfigKafkaTopicSettings;
}

export interface MdbClickhouseClusterClickhouseConfigKafkaTopicSettings {
    enableSslCertificateVerification: boolean;
    maxPollIntervalMs: number;
    saslMechanism?: string;
    saslPassword?: string;
    saslUsername?: string;
    securityProtocol?: string;
    sessionTimeoutMs: number;
}

export interface MdbClickhouseClusterClickhouseConfigMergeTree {
    cleanupDelayPeriod: number;
    maxAvgPartSizeForTooManyParts: number;
    maxBytesToMergeAtMinSpaceInPool: number;
    maxNumberOfMergesWithTtlInPool: number;
    maxPartsInTotal: number;
    maxReplicatedMergesInQueue: number;
    mergeSelectingSleepMs: number;
    mergeWithRecompressionTtlTimeout: number;
    mergeWithTtlTimeout: number;
    minAgeToForceMergeOnPartitionOnly: boolean;
    minAgeToForceMergeSeconds: number;
    minBytesForWidePart: number;
    minRowsForWidePart: number;
    numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge: number;
    partsToDelayInsert: number;
    partsToThrowInsert: number;
    replicatedDeduplicationWindow: number;
    replicatedDeduplicationWindowSeconds: number;
    ttlOnlyDropParts: boolean;
}

export interface MdbClickhouseClusterClickhouseConfigRabbitmq {
    password: string;
    username: string;
    vhost: string;
}

export interface MdbClickhouseClusterClickhouseResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbClickhouseClusterCloudStorage {
    dataCacheEnabled: boolean;
    dataCacheMaxSize: number;
    enabled: boolean;
    moveFactor: number;
    preferNotToMerge: boolean;
}

export interface MdbClickhouseClusterDatabase {
    name: string;
}

export interface MdbClickhouseClusterFormatSchema {
    name: string;
    type: string;
    uri: string;
}

export interface MdbClickhouseClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    shardName: string;
    subnetId: string;
    type: string;
    zone: string;
}

export interface MdbClickhouseClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbClickhouseClusterMlModel {
    name: string;
    type: string;
    uri: string;
}

export interface MdbClickhouseClusterShard {
    name: string;
    resources?: outputs.MdbClickhouseClusterShardResources;
    weight: number;
}

export interface MdbClickhouseClusterShardGroup {
    description?: string;
    name: string;
    shardNames: string[];
}

export interface MdbClickhouseClusterShardResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbClickhouseClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MdbClickhouseClusterUser {
    name: string;
    password: string;
    permissions?: outputs.MdbClickhouseClusterUserPermission[];
    quotas?: outputs.MdbClickhouseClusterUserQuota[];
    settings?: outputs.MdbClickhouseClusterUserSettings;
}

export interface MdbClickhouseClusterUserPermission {
    databaseName: string;
}

export interface MdbClickhouseClusterUserQuota {
    errors: number;
    executionTime: number;
    intervalDuration: number;
    queries: number;
    readRows: number;
    resultRows: number;
}

export interface MdbClickhouseClusterUserSettings {
    addHttpCorsHeader: boolean;
    allowDdl: boolean;
    allowIntrospectionFunctions: boolean;
    allowSuspiciousLowCardinalityTypes: boolean;
    asyncInsert: boolean;
    asyncInsertBusyTimeout: number;
    asyncInsertMaxDataSize: number;
    asyncInsertStaleTimeout: number;
    asyncInsertThreads: number;
    cancelHttpReadonlyQueriesOnClientClose: boolean;
    compile: boolean;
    compileExpressions: boolean;
    connectTimeout: number;
    connectTimeoutWithFailover: number;
    countDistinctImplementation: string;
    distinctOverflowMode: string;
    distributedAggregationMemoryEfficient: boolean;
    distributedDdlTaskTimeout: number;
    distributedProductMode: string;
    emptyResultForAggregationByEmptySet: boolean;
    enableHttpCompression: boolean;
    fallbackToStaleReplicasForDistributedQueries: boolean;
    flattenNested: boolean;
    forceIndexByDate: boolean;
    forcePrimaryKey: boolean;
    groupByOverflowMode: string;
    groupByTwoLevelThreshold: number;
    groupByTwoLevelThresholdBytes: number;
    httpConnectionTimeout: number;
    httpHeadersProgressInterval: number;
    httpReceiveTimeout: number;
    httpSendTimeout: number;
    inputFormatDefaultsForOmittedFields: boolean;
    inputFormatImportNestedJson: boolean;
    inputFormatParallelParsing: boolean;
    inputFormatValuesInterpretExpressions: boolean;
    insertKeeperMaxRetries: number;
    insertNullAsDefault: boolean;
    insertQuorum: number;
    insertQuorumTimeout: number;
    joinOverflowMode: string;
    joinUseNulls: boolean;
    joinedSubqueryRequiresAlias: boolean;
    localFilesystemReadMethod: string;
    lowCardinalityAllowInNativeFormat: boolean;
    maxAstDepth: number;
    maxAstElements: number;
    maxBlockSize: number;
    maxBytesBeforeExternalGroupBy: number;
    maxBytesBeforeExternalSort: number;
    maxBytesInDistinct: number;
    maxBytesInJoin: number;
    maxBytesInSet: number;
    maxBytesToRead: number;
    maxBytesToSort: number;
    maxBytesToTransfer: number;
    maxColumnsToRead: number;
    maxConcurrentQueriesForUser: number;
    maxExecutionTime: number;
    maxExpandedAstElements: number;
    maxFinalThreads: number;
    maxHttpGetRedirects: number;
    maxInsertBlockSize: number;
    maxMemoryUsage: number;
    maxMemoryUsageForUser: number;
    maxNetworkBandwidth: number;
    maxNetworkBandwidthForUser: number;
    maxParserDepth: number;
    maxQuerySize: number;
    maxReadBufferSize: number;
    maxReplicaDelayForDistributedQueries: number;
    maxResultBytes: number;
    maxResultRows: number;
    maxRowsInDistinct: number;
    maxRowsInJoin: number;
    maxRowsInSet: number;
    maxRowsToGroupBy: number;
    maxRowsToRead: number;
    maxRowsToSort: number;
    maxRowsToTransfer: number;
    maxTemporaryColumns: number;
    maxTemporaryDataOnDiskSizeForQuery: number;
    maxTemporaryDataOnDiskSizeForUser: number;
    maxTemporaryNonConstColumns: number;
    maxThreads: number;
    memoryOvercommitRatioDenominator: number;
    memoryOvercommitRatioDenominatorForUser: number;
    memoryProfilerSampleProbability: number;
    memoryProfilerStep: number;
    memoryUsageOvercommitMaxWaitMicroseconds: number;
    mergeTreeMaxBytesToUseCache: number;
    mergeTreeMaxRowsToUseCache: number;
    mergeTreeMinBytesForConcurrentRead: number;
    mergeTreeMinRowsForConcurrentRead: number;
    minBytesToUseDirectIo: number;
    minCountToCompile: number;
    minCountToCompileExpression: number;
    minExecutionSpeed: number;
    minExecutionSpeedBytes: number;
    minInsertBlockSizeBytes: number;
    minInsertBlockSizeRows: number;
    outputFormatJsonQuote64bitIntegers: boolean;
    outputFormatJsonQuoteDenormals: boolean;
    priority: number;
    quotaMode: string;
    readOverflowMode: string;
    readonly: number;
    receiveTimeout: number;
    remoteFilesystemReadMethod: string;
    replicationAlterPartitionsSync: number;
    resultOverflowMode: string;
    selectSequentialConsistency: boolean;
    sendProgressInHttpHeaders: boolean;
    sendTimeout: number;
    setOverflowMode: string;
    skipUnavailableShards: boolean;
    sortOverflowMode: string;
    timeoutBeforeCheckingExecutionSpeed: number;
    timeoutOverflowMode: string;
    transferOverflowMode: string;
    transformNullIn: boolean;
    useUncompressedCache: boolean;
    waitForAsyncInsert: boolean;
    waitForAsyncInsertTimeout: number;
}

export interface MdbClickhouseClusterZookeeper {
    resources?: outputs.MdbClickhouseClusterZookeeperResources;
}

export interface MdbClickhouseClusterZookeeperResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbElasticsearchClusterConfig {
    adminPassword: string;
    dataNode: outputs.MdbElasticsearchClusterConfigDataNode;
    edition: string;
    masterNode?: outputs.MdbElasticsearchClusterConfigMasterNode;
    plugins?: string[];
    version: string;
}

export interface MdbElasticsearchClusterConfigDataNode {
    resources: outputs.MdbElasticsearchClusterConfigDataNodeResources;
}

export interface MdbElasticsearchClusterConfigDataNodeResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbElasticsearchClusterConfigMasterNode {
    resources: outputs.MdbElasticsearchClusterConfigMasterNodeResources;
}

export interface MdbElasticsearchClusterConfigMasterNodeResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbElasticsearchClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    name: string;
    subnetId: string;
    type: string;
    zone: string;
}

export interface MdbElasticsearchClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbElasticsearchClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MdbGreenplumClusterAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
    webSql?: boolean;
}

export interface MdbGreenplumClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbGreenplumClusterCloudStorage {
    enable?: boolean;
}

export interface MdbGreenplumClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbGreenplumClusterMasterHost {
    assignPublicIp: boolean;
    fqdn: string;
}

export interface MdbGreenplumClusterMasterSubcluster {
    resources: outputs.MdbGreenplumClusterMasterSubclusterResources;
}

export interface MdbGreenplumClusterMasterSubclusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbGreenplumClusterPoolerConfig {
    poolClientIdleTimeout?: number;
    poolSize?: number;
    poolingMode?: string;
}

export interface MdbGreenplumClusterPxfConfig {
    connectionTimeout?: number;
    maxThreads?: number;
    poolAllowCoreThreadTimeout?: boolean;
    poolCoreSize?: number;
    poolMaxSize?: number;
    poolQueueCapacity?: number;
    uploadTimeout?: number;
    xms?: number;
    xmx?: number;
}

export interface MdbGreenplumClusterSegmentHost {
    fqdn: string;
}

export interface MdbGreenplumClusterSegmentSubcluster {
    resources: outputs.MdbGreenplumClusterSegmentSubclusterResources;
}

export interface MdbGreenplumClusterSegmentSubclusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbGreenplumClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MdbKafkaClusterConfig {
    access?: outputs.MdbKafkaClusterConfigAccess;
    assignPublicIp?: boolean;
    brokersCount?: number;
    diskSizeAutoscaling?: outputs.MdbKafkaClusterConfigDiskSizeAutoscaling;
    kafka: outputs.MdbKafkaClusterConfigKafka;
    schemaRegistry?: boolean;
    /**
     * @deprecated Deprecated
     */
    unmanagedTopics?: boolean;
    version: string;
    zones: string[];
    zookeeper?: outputs.MdbKafkaClusterConfigZookeeper;
}

export interface MdbKafkaClusterConfigAccess {
    dataTransfer?: boolean;
}

export interface MdbKafkaClusterConfigDiskSizeAutoscaling {
    diskSizeLimit: number;
    emergencyUsageThreshold?: number;
    plannedUsageThreshold?: number;
}

export interface MdbKafkaClusterConfigKafka {
    kafkaConfig?: outputs.MdbKafkaClusterConfigKafkaKafkaConfig;
    resources: outputs.MdbKafkaClusterConfigKafkaResources;
}

export interface MdbKafkaClusterConfigKafkaKafkaConfig {
    autoCreateTopicsEnable?: boolean;
    compressionType?: string;
    defaultReplicationFactor?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logFlushSchedulerIntervalMs?: string;
    logPreallocate?: boolean;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMinutes?: string;
    logRetentionMs?: string;
    logSegmentBytes?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    replicaFetchMaxBytes?: string;
    saslEnabledMechanisms?: string[];
    socketReceiveBufferBytes?: string;
    socketSendBufferBytes?: string;
    sslCipherSuites?: string[];
}

export interface MdbKafkaClusterConfigKafkaResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbKafkaClusterConfigZookeeper {
    resources?: outputs.MdbKafkaClusterConfigZookeeperResources;
}

export interface MdbKafkaClusterConfigZookeeperResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbKafkaClusterHost {
    assignPublicIp: boolean;
    health: string;
    name: string;
    role: string;
    subnetId: string;
    zoneId: string;
}

export interface MdbKafkaClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbKafkaClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MdbKafkaClusterTopic {
    name: string;
    partitions: number;
    replicationFactor: number;
    topicConfig?: outputs.MdbKafkaClusterTopicTopicConfig;
}

export interface MdbKafkaClusterTopicTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    maxMessageBytes?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: boolean;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
}

export interface MdbKafkaClusterUser {
    name: string;
    password: string;
    permissions?: outputs.MdbKafkaClusterUserPermission[];
}

export interface MdbKafkaClusterUserPermission {
    allowHosts?: string[];
    role: string;
    topicName: string;
}

export interface MdbKafkaConnectorConnectorConfigMirrormaker {
    replicationFactor: number;
    sourceCluster: outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster;
    targetCluster: outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster;
    topics: string;
}

export interface MdbKafkaConnectorConnectorConfigMirrormakerSourceCluster {
    alias?: string;
    externalClusters?: outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster[];
    thisClusters?: outputs.MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisCluster[];
}

export interface MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterExternalCluster {
    bootstrapServers: string;
    saslMechanism?: string;
    saslPassword?: string;
    saslUsername?: string;
    securityProtocol?: string;
}

export interface MdbKafkaConnectorConnectorConfigMirrormakerSourceClusterThisCluster {
}

export interface MdbKafkaConnectorConnectorConfigMirrormakerTargetCluster {
    alias?: string;
    externalClusters?: outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster[];
    thisClusters?: outputs.MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisCluster[];
}

export interface MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterExternalCluster {
    bootstrapServers: string;
    saslMechanism?: string;
    saslPassword?: string;
    saslUsername?: string;
    securityProtocol?: string;
}

export interface MdbKafkaConnectorConnectorConfigMirrormakerTargetClusterThisCluster {
}

export interface MdbKafkaConnectorConnectorConfigS3Sink {
    fileCompressionType: string;
    fileMaxRecords?: number;
    s3Connection: outputs.MdbKafkaConnectorConnectorConfigS3SinkS3Connection;
    topics: string;
}

export interface MdbKafkaConnectorConnectorConfigS3SinkS3Connection {
    bucketName: string;
    externalS3s: outputs.MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3[];
}

export interface MdbKafkaConnectorConnectorConfigS3SinkS3ConnectionExternalS3 {
    accessKeyId?: string;
    endpoint: string;
    region?: string;
    secretAccessKey?: string;
}

export interface MdbKafkaTopicTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MdbKafkaTopicTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    maxMessageBytes?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: boolean;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
}

export interface MdbKafkaUserPermission {
    allowHosts?: string[];
    role: string;
    topicName: string;
}

export interface MdbKafkaUserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MdbMongodbClusterClusterConfig {
    access?: outputs.MdbMongodbClusterClusterConfigAccess;
    backupRetainPeriodDays: number;
    backupWindowStart?: outputs.MdbMongodbClusterClusterConfigBackupWindowStart;
    featureCompatibilityVersion: string;
    mongocfg?: outputs.MdbMongodbClusterClusterConfigMongocfg;
    mongod?: outputs.MdbMongodbClusterClusterConfigMongod;
    mongos?: outputs.MdbMongodbClusterClusterConfigMongos;
    performanceDiagnostics?: outputs.MdbMongodbClusterClusterConfigPerformanceDiagnostics;
    version: string;
}

export interface MdbMongodbClusterClusterConfigAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
}

export interface MdbMongodbClusterClusterConfigBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbMongodbClusterClusterConfigMongocfg {
    net?: outputs.MdbMongodbClusterClusterConfigMongocfgNet;
    operationProfiling?: outputs.MdbMongodbClusterClusterConfigMongocfgOperationProfiling;
    storage?: outputs.MdbMongodbClusterClusterConfigMongocfgStorage;
}

export interface MdbMongodbClusterClusterConfigMongocfgNet {
    maxIncomingConnections?: number;
}

export interface MdbMongodbClusterClusterConfigMongocfgOperationProfiling {
    mode?: string;
    slowOpThreshold?: number;
}

export interface MdbMongodbClusterClusterConfigMongocfgStorage {
    wiredTiger?: outputs.MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger;
}

export interface MdbMongodbClusterClusterConfigMongocfgStorageWiredTiger {
    cacheSizeGb?: number;
}

export interface MdbMongodbClusterClusterConfigMongod {
    auditLog?: outputs.MdbMongodbClusterClusterConfigMongodAuditLog;
    net?: outputs.MdbMongodbClusterClusterConfigMongodNet;
    operationProfiling?: outputs.MdbMongodbClusterClusterConfigMongodOperationProfiling;
    security?: outputs.MdbMongodbClusterClusterConfigMongodSecurity;
    setParameter?: outputs.MdbMongodbClusterClusterConfigMongodSetParameter;
    storage?: outputs.MdbMongodbClusterClusterConfigMongodStorage;
}

export interface MdbMongodbClusterClusterConfigMongodAuditLog {
    filter?: string;
    runtimeConfiguration?: boolean;
}

export interface MdbMongodbClusterClusterConfigMongodNet {
    compressors?: string[];
    maxIncomingConnections?: number;
}

export interface MdbMongodbClusterClusterConfigMongodOperationProfiling {
    mode?: string;
    slowOpSampleRate?: number;
    slowOpThreshold?: number;
}

export interface MdbMongodbClusterClusterConfigMongodSecurity {
    enableEncryption?: boolean;
    kmip?: outputs.MdbMongodbClusterClusterConfigMongodSecurityKmip;
}

export interface MdbMongodbClusterClusterConfigMongodSecurityKmip {
    clientCertificate?: string;
    keyIdentifier?: string;
    port?: number;
    serverCa?: string;
    serverName?: string;
}

export interface MdbMongodbClusterClusterConfigMongodSetParameter {
    auditAuthorizationSuccess?: boolean;
    enableFlowControl?: boolean;
    minSnapshotHistoryWindowInSeconds?: number;
}

export interface MdbMongodbClusterClusterConfigMongodStorage {
    journal?: outputs.MdbMongodbClusterClusterConfigMongodStorageJournal;
    wiredTiger?: outputs.MdbMongodbClusterClusterConfigMongodStorageWiredTiger;
}

export interface MdbMongodbClusterClusterConfigMongodStorageJournal {
    commitInterval?: number;
}

export interface MdbMongodbClusterClusterConfigMongodStorageWiredTiger {
    blockCompressor?: string;
    cacheSizeGb?: number;
    prefixCompression?: boolean;
}

export interface MdbMongodbClusterClusterConfigMongos {
    net?: outputs.MdbMongodbClusterClusterConfigMongosNet;
}

export interface MdbMongodbClusterClusterConfigMongosNet {
    compressors?: string[];
    maxIncomingConnections?: number;
}

export interface MdbMongodbClusterClusterConfigPerformanceDiagnostics {
    enabled?: boolean;
}

export interface MdbMongodbClusterDatabase {
    name: string;
}

export interface MdbMongodbClusterHost {
    assignPublicIp?: boolean;
    health: string;
    hostParameters?: outputs.MdbMongodbClusterHostHostParameters;
    name: string;
    role: string;
    shardName: string;
    subnetId: string;
    type?: string;
    zoneId: string;
}

export interface MdbMongodbClusterHostHostParameters {
    hidden?: boolean;
    priority?: number;
    secondaryDelaySecs?: number;
    tags?: {[key: string]: string};
}

export interface MdbMongodbClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbMongodbClusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbMongodbClusterResourcesMongocfg {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbMongodbClusterResourcesMongod {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbMongodbClusterResourcesMongoinfra {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbMongodbClusterResourcesMongos {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbMongodbClusterRestore {
    backupId: string;
    time?: string;
}

export interface MdbMongodbClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MdbMongodbClusterUser {
    name: string;
    password: string;
    permissions?: outputs.MdbMongodbClusterUserPermission[];
}

export interface MdbMongodbClusterUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface MdbMongodbUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface MdbMysqlClusterAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
    webSql?: boolean;
}

export interface MdbMysqlClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbMysqlClusterDatabase {
    name: string;
}

export interface MdbMysqlClusterHost {
    assignPublicIp?: boolean;
    backupPriority?: number;
    fqdn: string;
    name?: string;
    priority?: number;
    replicationSource: string;
    replicationSourceName?: string;
    subnetId: string;
    zone: string;
}

export interface MdbMysqlClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbMysqlClusterPerformanceDiagnostics {
    enabled: boolean;
    sessionsSamplingInterval: number;
    statementsSamplingInterval: number;
}

export interface MdbMysqlClusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbMysqlClusterRestore {
    backupId: string;
    time?: string;
}

export interface MdbMysqlClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MdbMysqlClusterUser {
    authenticationPlugin: string;
    connectionLimits?: outputs.MdbMysqlClusterUserConnectionLimits;
    globalPermissions: string[];
    name: string;
    password: string;
    permissions?: outputs.MdbMysqlClusterUserPermission[];
}

export interface MdbMysqlClusterUserConnectionLimits {
    maxConnectionsPerHour?: number;
    maxQuestionsPerHour?: number;
    maxUpdatesPerHour?: number;
    maxUserConnections?: number;
}

export interface MdbMysqlClusterUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface MdbMysqlDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MdbMysqlUserConnectionLimits {
    maxConnectionsPerHour?: number;
    maxQuestionsPerHour?: number;
    maxUpdatesPerHour?: number;
    maxUserConnections?: number;
}

export interface MdbMysqlUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface MdbMysqlUserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MdbOpensearchClusterAuthSettings {
    saml?: outputs.MdbOpensearchClusterAuthSettingsSaml;
}

export interface MdbOpensearchClusterAuthSettingsSaml {
    dashboardsUrl: string;
    enabled: boolean;
    idpEntityId: string;
    idpMetadataFileContent: string;
    rolesKey?: string;
    spEntityId: string;
    subjectKey?: string;
}

export interface MdbOpensearchClusterConfig {
    access?: outputs.MdbOpensearchClusterConfigAccess;
    adminPassword: string;
    dashboards?: outputs.MdbOpensearchClusterConfigDashboards;
    opensearch?: outputs.MdbOpensearchClusterConfigOpensearch;
    version: string;
}

export interface MdbOpensearchClusterConfigAccess {
    dataTransfer?: boolean;
    serverless?: boolean;
}

export interface MdbOpensearchClusterConfigDashboards {
    nodeGroups?: outputs.MdbOpensearchClusterConfigDashboardsNodeGroup[];
}

export interface MdbOpensearchClusterConfigDashboardsNodeGroup {
    assignPublicIp: boolean;
    hostsCount: number;
    name: string;
    resources?: outputs.MdbOpensearchClusterConfigDashboardsNodeGroupResources;
    subnetIds: string[];
    zoneIds: string[];
}

export interface MdbOpensearchClusterConfigDashboardsNodeGroupResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbOpensearchClusterConfigOpensearch {
    nodeGroups?: outputs.MdbOpensearchClusterConfigOpensearchNodeGroup[];
    plugins: string[];
}

export interface MdbOpensearchClusterConfigOpensearchNodeGroup {
    assignPublicIp: boolean;
    hostsCount: number;
    name: string;
    resources?: outputs.MdbOpensearchClusterConfigOpensearchNodeGroupResources;
    roles: string[];
    subnetIds: string[];
    zoneIds: string[];
}

export interface MdbOpensearchClusterConfigOpensearchNodeGroupResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbOpensearchClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    nodeGroup: string;
    roles: string[];
    subnetId: string;
    type: string;
    zone: string;
}

export interface MdbOpensearchClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbOpensearchClusterTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface MdbPostgresqlClusterConfig {
    access?: outputs.MdbPostgresqlClusterConfigAccess;
    autofailover: boolean;
    backupRetainPeriodDays: number;
    backupWindowStart?: outputs.MdbPostgresqlClusterConfigBackupWindowStart;
    diskSizeAutoscaling?: outputs.MdbPostgresqlClusterConfigDiskSizeAutoscaling;
    performanceDiagnostics?: outputs.MdbPostgresqlClusterConfigPerformanceDiagnostics;
    poolerConfig?: outputs.MdbPostgresqlClusterConfigPoolerConfig;
    postgresqlConfig: {[key: string]: string};
    resources: outputs.MdbPostgresqlClusterConfigResources;
    version: string;
}

export interface MdbPostgresqlClusterConfigAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
    serverless?: boolean;
    webSql: boolean;
}

export interface MdbPostgresqlClusterConfigBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbPostgresqlClusterConfigDiskSizeAutoscaling {
    diskSizeLimit: number;
    emergencyUsageThreshold?: number;
    plannedUsageThreshold?: number;
}

export interface MdbPostgresqlClusterConfigPerformanceDiagnostics {
    enabled: boolean;
    sessionsSamplingInterval: number;
    statementsSamplingInterval: number;
}

export interface MdbPostgresqlClusterConfigPoolerConfig {
    poolDiscard?: boolean;
    poolingMode?: string;
}

export interface MdbPostgresqlClusterConfigResources {
    diskSize: number;
    diskTypeId?: string;
    resourcePresetId: string;
}

export interface MdbPostgresqlClusterDatabase {
    extensions?: outputs.MdbPostgresqlClusterDatabaseExtension[];
    lcCollate?: string;
    lcType?: string;
    name: string;
    owner: string;
    templateDb?: string;
}

export interface MdbPostgresqlClusterDatabaseExtension {
    name: string;
    version?: string;
}

export interface MdbPostgresqlClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    name?: string;
    priority?: number;
    replicationSource: string;
    replicationSourceName?: string;
    role: string;
    subnetId?: string;
    zone: string;
}

export interface MdbPostgresqlClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbPostgresqlClusterRestore {
    backupId: string;
    time?: string;
    timeInclusive?: boolean;
}

export interface MdbPostgresqlClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MdbPostgresqlClusterUser {
    connLimit: number;
    grants: string[];
    login?: boolean;
    name: string;
    password: string;
    permissions?: outputs.MdbPostgresqlClusterUserPermission[];
    settings: {[key: string]: string};
}

export interface MdbPostgresqlClusterUserPermission {
    databaseName: string;
}

export interface MdbPostgresqlDatabaseExtension {
    name: string;
    version?: string;
}

export interface MdbPostgresqlDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MdbPostgresqlUserPermission {
    databaseName: string;
}

export interface MdbPostgresqlUserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MdbRedisClusterConfig {
    clientOutputBufferLimitNormal: string;
    clientOutputBufferLimitPubsub: string;
    databases: number;
    maxmemoryPercent?: number;
    maxmemoryPolicy: string;
    notifyKeyspaceEvents: string;
    password: string;
    slowlogLogSlowerThan: number;
    slowlogMaxLen: number;
    timeout: number;
    version: string;
}

export interface MdbRedisClusterDiskSizeAutoscaling {
    diskSizeLimit: number;
    emergencyUsageThreshold?: number;
    plannedUsageThreshold?: number;
}

export interface MdbRedisClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    replicaPriority?: number;
    shardName: string;
    subnetId: string;
    zone: string;
}

export interface MdbRedisClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbRedisClusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbRedisClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MdbSqlserverClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbSqlserverClusterDatabase {
    name: string;
}

export interface MdbSqlserverClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    subnetId: string;
    zone: string;
}

export interface MdbSqlserverClusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbSqlserverClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MdbSqlserverClusterUser {
    name: string;
    password: string;
    permissions?: outputs.MdbSqlserverClusterUserPermission[];
}

export interface MdbSqlserverClusterUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface MonitoringDashboardParametrization {
    /**
     * Dashboard parameter
     */
    parameters?: outputs.MonitoringDashboardParametrizationParameter[];
    /**
     * Predefined selectors
     */
    selectors?: string;
}

export interface MonitoringDashboardParametrizationParameter {
    /**
     * Custom parameter
     */
    customs?: outputs.MonitoringDashboardParametrizationParameterCustom[];
    /**
     * Parameter description
     */
    description?: string;
    /**
     * UI-visibility
     */
    hidden?: boolean;
    /**
     * Parameter identifier
     */
    id: string;
    /**
     * Label values parameter
     */
    labelValues?: outputs.MonitoringDashboardParametrizationParameterLabelValue[];
    /**
     * Text parameter
     */
    texts?: outputs.MonitoringDashboardParametrizationParameterText[];
    /**
     * UI-visible title of the parameter
     */
    title?: string;
}

export interface MonitoringDashboardParametrizationParameterCustom {
    /**
     * Default value
     */
    defaultValues?: string[];
    /**
     * Specifies the multiselectable values of parameter
     */
    multiselectable?: boolean;
    /**
     * Parameter values
     */
    values?: string[];
}

export interface MonitoringDashboardParametrizationParameterLabelValue {
    /**
     * Default value
     */
    defaultValues?: string[];
    /**
     * Folder ID
     */
    folderId?: string;
    /**
     * Required. Label key to list label values
     */
    labelKey: string;
    /**
     * Specifies the multiselectable values of parameter
     */
    multiselectable?: boolean;
    /**
     * Required. Selectors to select metric label values
     */
    selectors?: string;
}

export interface MonitoringDashboardParametrizationParameterText {
    /**
     * Default value
     */
    defaultValue?: string;
}

export interface MonitoringDashboardTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitoringDashboardWidget {
    /**
     * Chart widget
     */
    charts?: outputs.MonitoringDashboardWidgetChart[];
    /**
     * Required. Widget layout position
     */
    positions?: outputs.MonitoringDashboardWidgetPosition[];
    /**
     * Text widget
     */
    texts?: outputs.MonitoringDashboardWidgetText[];
    /**
     * Title widget
     */
    titles?: outputs.MonitoringDashboardWidgetTitle[];
}

export interface MonitoringDashboardWidgetChart {
    /**
     * Chart ID
     */
    chartId?: string;
    /**
     * Chart description in dashboard (not enabled in UI)
     */
    description?: string;
    /**
     * Enable legend under chart
     */
    displayLegend?: boolean;
    /**
     * Fixed time interval for chart
     */
    freeze: string;
    /**
     * Name hiding settings
     */
    nameHidingSettings?: outputs.MonitoringDashboardWidgetChartNameHidingSetting[];
    /**
     * Queries
     */
    queries?: outputs.MonitoringDashboardWidgetChartQuery[];
    seriesOverrides?: outputs.MonitoringDashboardWidgetChartSeriesOverride[];
    /**
     * Chart widget title
     */
    title?: string;
    /**
     * Visualization settings
     */
    visualizationSettings?: outputs.MonitoringDashboardWidgetChartVisualizationSetting[];
}

export interface MonitoringDashboardWidgetChartNameHidingSetting {
    names?: string[];
    /**
     * True if we want to show concrete series names only, false if we want to hide concrete series names
     */
    positive?: boolean;
}

export interface MonitoringDashboardWidgetChartQuery {
    /**
     * Downsampling settings
     */
    downsamplings?: outputs.MonitoringDashboardWidgetChartQueryDownsampling[];
    /**
     * Downsampling settings
     */
    targets?: outputs.MonitoringDashboardWidgetChartQueryTarget[];
}

export interface MonitoringDashboardWidgetChartQueryDownsampling {
    /**
     * Disable downsampling
     */
    disabled?: boolean;
    /**
     * Parameters for filling gaps in data
     */
    gapFilling?: string;
    /**
     * Function that is used for downsampling
     */
    gridAggregation?: string;
    /**
     * Time interval (grid) for downsampling in milliseconds. Points in the specified range are aggregated into one time point
     */
    gridInterval?: number;
    /**
     * Maximum number of points to be returned
     */
    maxPoints?: number;
}

export interface MonitoringDashboardWidgetChartQueryTarget {
    /**
     * Checks that target is visible or invisible
     */
    hidden?: boolean;
    /**
     * Required. Query
     */
    query?: string;
    /**
     * Text mode
     */
    textMode?: boolean;
}

export interface MonitoringDashboardWidgetChartSeriesOverride {
    /**
     * Series name
     */
    name?: string;
    /**
     * Override settings
     */
    settings?: outputs.MonitoringDashboardWidgetChartSeriesOverrideSetting[];
    /**
     * Target index
     */
    targetIndex?: string;
}

export interface MonitoringDashboardWidgetChartSeriesOverrideSetting {
    /**
     * Series color or empty
     */
    color?: string;
    /**
     * Stack grow down
     */
    growDown?: boolean;
    /**
     * Series name or empty
     */
    name?: string;
    /**
     * Stack name or empty
     */
    stackName?: string;
    /**
     * Type
     */
    type: string;
    /**
     * Yaxis position
     */
    yaxisPosition: string;
}

export interface MonitoringDashboardWidgetChartVisualizationSetting {
    /**
     * Aggregation
     */
    aggregation: string;
    /**
     * Color scheme settings
     */
    colorSchemeSettings?: outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSetting[];
    /**
     * Heatmap settings
     */
    heatmapSettings?: outputs.MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting[];
    /**
     * Interpolate
     */
    interpolate: string;
    /**
     * Normalize
     */
    normalize?: boolean;
    /**
     * Show chart labels
     */
    showLabels?: boolean;
    /**
     * Inside chart title
     */
    title?: string;
    /**
     * Visualization type
     */
    type: string;
    /**
     * Y axis settings
     */
    yaxisSettings?: outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSetting[];
}

export interface MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSetting {
    /**
     * Automatic color scheme
     */
    automatics?: outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomatic[];
    /**
     * Gradient color scheme
     */
    gradients?: outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient[];
    /**
     * Standard color scheme
     */
    standards?: outputs.MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandard[];
}

export interface MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingAutomatic {
}

export interface MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingGradient {
    /**
     * Gradient green value
     */
    greenValue?: string;
    /**
     * Gradient red value
     */
    redValue?: string;
    /**
     * Gradient violet_value
     */
    violetValue?: string;
    /**
     * Gradient yellow value
     */
    yellowValue?: string;
}

export interface MonitoringDashboardWidgetChartVisualizationSettingColorSchemeSettingStandard {
}

export interface MonitoringDashboardWidgetChartVisualizationSettingHeatmapSetting {
    /**
     * Heatmap green value
     */
    greenValue?: string;
    /**
     * Heatmap red value
     */
    redValue?: string;
    /**
     * Heatmap violet_value
     */
    violetValue?: string;
    /**
     * Heatmap yellow value
     */
    yellowValue?: string;
}

export interface MonitoringDashboardWidgetChartVisualizationSettingYaxisSetting {
    /**
     * Left Y axis settings
     */
    lefts?: outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft[];
    /**
     * Right Y axis settings
     */
    rights?: outputs.MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight[];
}

export interface MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingLeft {
    /**
     * Max value in extended number format or empty
     */
    max?: string;
    /**
     * Min value in extended number format or empty
     */
    min?: string;
    /**
     * Tick value precision (null as default, 0-7 in other cases)
     */
    precision?: number;
    /**
     * Title or empty
     */
    title?: string;
    /**
     * Type
     */
    type: string;
    /**
     * Unit format
     */
    unitFormat: string;
}

export interface MonitoringDashboardWidgetChartVisualizationSettingYaxisSettingRight {
    /**
     * Max value in extended number format or empty
     */
    max?: string;
    /**
     * Min value in extended number format or empty
     */
    min?: string;
    /**
     * Tick value precision (null as default, 0-7 in other cases)
     */
    precision?: number;
    /**
     * Title or empty
     */
    title?: string;
    /**
     * Type
     */
    type?: string;
    /**
     * Unit format
     */
    unitFormat?: string;
}

export interface MonitoringDashboardWidgetPosition {
    /**
     * Required. Height
     */
    h?: number;
    /**
     * Required. Weight
     */
    w?: number;
    /**
     * Required. X-axis top-left corner coordinate
     */
    x?: number;
    /**
     * Required. Y-axis top-left corner coordinate
     */
    y?: number;
}

export interface MonitoringDashboardWidgetText {
    /**
     * Text
     */
    text?: string;
}

export interface MonitoringDashboardWidgetTitle {
    /**
     * Title size
     */
    size: string;
    /**
     * Title text
     */
    text: string;
}

export interface OrganizationmanagerGroupIamMemberTimeouts {
    default?: string;
}

export interface OrganizationmanagerGroupMembershipTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface OrganizationmanagerGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface OrganizationmanagerOrganizationIamBindingTimeouts {
    default?: string;
}

export interface OrganizationmanagerOrganizationIamMemberTimeouts {
    default?: string;
}

export interface OrganizationmanagerOsLoginSettingsSshCertificateSettings {
    enabled?: boolean;
}

export interface OrganizationmanagerOsLoginSettingsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface OrganizationmanagerOsLoginSettingsUserSshKeySettings {
    allowManageOwnKeys?: boolean;
    enabled?: boolean;
}

export interface OrganizationmanagerSamlFederationSecuritySettings {
    encryptedAssertions: boolean;
}

export interface OrganizationmanagerSamlFederationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface OrganizationmanagerSamlFederationUserAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface OrganizationmanagerUserSshKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourcemanagerCloudIamBindingTimeouts {
    default?: string;
}

export interface ResourcemanagerCloudIamMemberTimeouts {
    default?: string;
}

export interface ResourcemanagerCloudTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourcemanagerFolderIamBindingTimeouts {
    default?: string;
}

export interface ResourcemanagerFolderIamMemberTimeouts {
    default?: string;
}

export interface ResourcemanagerFolderIamPolicyTimeouts {
    default?: string;
}

export interface ResourcemanagerFolderTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServerlessContainerConnectivity {
    networkId: string;
}

export interface ServerlessContainerIamBindingTimeouts {
    default?: string;
}

export interface ServerlessContainerImage {
    args?: string[];
    commands?: string[];
    digest: string;
    environment?: {[key: string]: string};
    url: string;
    workDir?: string;
}

export interface ServerlessContainerLogOptions {
    disabled?: boolean;
    folderId?: string;
    logGroupId?: string;
    minLevel?: string;
}

export interface ServerlessContainerProvisionPolicy {
    minInstances: number;
}

export interface ServerlessContainerSecret {
    environmentVariable: string;
    id: string;
    key: string;
    versionId: string;
}

export interface ServerlessContainerStorageMount {
    bucket: string;
    mountPointPath: string;
    prefix?: string;
    readOnly?: boolean;
}

export interface ServerlessContainerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SmartcaptchaCaptchaOverrideVariant {
    challengeType?: string;
    complexity?: string;
    description?: string;
    preCheckType?: string;
    uuid?: string;
}

export interface SmartcaptchaCaptchaSecurityRule {
    condition?: outputs.SmartcaptchaCaptchaSecurityRuleCondition;
    description?: string;
    name?: string;
    overrideVariantUuid?: string;
    priority?: number;
}

export interface SmartcaptchaCaptchaSecurityRuleCondition {
    headers?: outputs.SmartcaptchaCaptchaSecurityRuleConditionHeader[];
    host?: outputs.SmartcaptchaCaptchaSecurityRuleConditionHost;
    sourceIp?: outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIp;
    uri?: outputs.SmartcaptchaCaptchaSecurityRuleConditionUri;
}

export interface SmartcaptchaCaptchaSecurityRuleConditionHeader {
    name?: string;
    value: outputs.SmartcaptchaCaptchaSecurityRuleConditionHeaderValue;
}

export interface SmartcaptchaCaptchaSecurityRuleConditionHeaderValue {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SmartcaptchaCaptchaSecurityRuleConditionHost {
    hosts?: outputs.SmartcaptchaCaptchaSecurityRuleConditionHostHost[];
}

export interface SmartcaptchaCaptchaSecurityRuleConditionHostHost {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SmartcaptchaCaptchaSecurityRuleConditionSourceIp {
    geoIpMatch?: outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatch;
    geoIpNotMatch?: outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatch;
    ipRangesMatch?: outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch;
    ipRangesNotMatch?: outputs.SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch;
}

export interface SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpMatch {
    locations?: string[];
}

export interface SmartcaptchaCaptchaSecurityRuleConditionSourceIpGeoIpNotMatch {
    locations?: string[];
}

export interface SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesMatch {
    ipRanges?: string[];
}

export interface SmartcaptchaCaptchaSecurityRuleConditionSourceIpIpRangesNotMatch {
    ipRanges?: string[];
}

export interface SmartcaptchaCaptchaSecurityRuleConditionUri {
    path?: outputs.SmartcaptchaCaptchaSecurityRuleConditionUriPath;
    queries?: outputs.SmartcaptchaCaptchaSecurityRuleConditionUriQuery[];
}

export interface SmartcaptchaCaptchaSecurityRuleConditionUriPath {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SmartcaptchaCaptchaSecurityRuleConditionUriQuery {
    key: string;
    value: outputs.SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue;
}

export interface SmartcaptchaCaptchaSecurityRuleConditionUriQueryValue {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SmartcaptchaCaptchaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageBucketAnonymousAccessFlags {
    configRead?: boolean;
    list?: boolean;
    read?: boolean;
}

export interface StorageBucketCorsRule {
    allowedHeaders?: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders?: string[];
    maxAgeSeconds?: number;
}

export interface StorageBucketGrant {
    id?: string;
    permissions: string[];
    type: string;
    uri?: string;
}

export interface StorageBucketHttps {
    certificateId: string;
}

export interface StorageBucketLifecycleRule {
    abortIncompleteMultipartUploadDays?: number;
    enabled: boolean;
    expiration?: outputs.StorageBucketLifecycleRuleExpiration;
    filter?: outputs.StorageBucketLifecycleRuleFilter;
    id: string;
    noncurrentVersionExpiration?: outputs.StorageBucketLifecycleRuleNoncurrentVersionExpiration;
    noncurrentVersionTransitions?: outputs.StorageBucketLifecycleRuleNoncurrentVersionTransition[];
    /**
     * @deprecated Deprecated
     */
    prefix?: string;
    transitions?: outputs.StorageBucketLifecycleRuleTransition[];
}

export interface StorageBucketLifecycleRuleExpiration {
    date?: string;
    days?: number;
    expiredObjectDeleteMarker?: boolean;
}

export interface StorageBucketLifecycleRuleFilter {
    and?: outputs.StorageBucketLifecycleRuleFilterAnd;
    objectSizeGreaterThan?: number;
    objectSizeLessThan?: number;
    prefix?: string;
    tag?: outputs.StorageBucketLifecycleRuleFilterTag;
}

export interface StorageBucketLifecycleRuleFilterAnd {
    objectSizeGreaterThan?: number;
    objectSizeLessThan?: number;
    prefix?: string;
    tags?: {[key: string]: string};
}

export interface StorageBucketLifecycleRuleFilterTag {
    key: string;
    value: string;
}

export interface StorageBucketLifecycleRuleNoncurrentVersionExpiration {
    days?: number;
}

export interface StorageBucketLifecycleRuleNoncurrentVersionTransition {
    days?: number;
    storageClass: string;
}

export interface StorageBucketLifecycleRuleTransition {
    date?: string;
    days?: number;
    storageClass: string;
}

export interface StorageBucketLogging {
    targetBucket: string;
    targetPrefix?: string;
}

export interface StorageBucketObjectLockConfiguration {
    objectLockEnabled?: string;
    rule?: outputs.StorageBucketObjectLockConfigurationRule;
}

export interface StorageBucketObjectLockConfigurationRule {
    defaultRetention: outputs.StorageBucketObjectLockConfigurationRuleDefaultRetention;
}

export interface StorageBucketObjectLockConfigurationRuleDefaultRetention {
    days?: number;
    mode: string;
    years?: number;
}

export interface StorageBucketServerSideEncryptionConfiguration {
    rule: outputs.StorageBucketServerSideEncryptionConfigurationRule;
}

export interface StorageBucketServerSideEncryptionConfigurationRule {
    applyServerSideEncryptionByDefault: outputs.StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault;
}

export interface StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault {
    kmsMasterKeyId: string;
    sseAlgorithm: string;
}

export interface StorageBucketVersioning {
    enabled?: boolean;
}

export interface StorageBucketWebsite {
    errorDocument?: string;
    indexDocument?: string;
    redirectAllRequestsTo?: string;
    routingRules?: string;
}

export interface SwsSecurityProfileSecurityRule {
    description?: string;
    dryRun?: boolean;
    name?: string;
    priority?: number;
    ruleCondition?: outputs.SwsSecurityProfileSecurityRuleRuleCondition;
    smartProtection?: outputs.SwsSecurityProfileSecurityRuleSmartProtection;
}

export interface SwsSecurityProfileSecurityRuleRuleCondition {
    action?: string;
    condition?: outputs.SwsSecurityProfileSecurityRuleRuleConditionCondition;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionCondition {
    authority?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionAuthority;
    headers?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHeader[];
    httpMethod?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod;
    requestUri?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUri;
    sourceIp?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionAuthority {
    authorities?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority[];
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionAuthorityAuthority {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionHeader {
    name?: string;
    value: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionHeaderValue {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethod {
    httpMethods?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod[];
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionHttpMethodHttpMethod {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUri {
    path?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath;
    queries?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQuery[];
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriPath {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQuery {
    key: string;
    value: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionRequestUriQueryValue {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIp {
    geoIpMatch?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatch;
    geoIpNotMatch?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatch;
    ipRangesMatch?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch;
    ipRangesNotMatch?: outputs.SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch;
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpMatch {
    locations?: string[];
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpGeoIpNotMatch {
    locations?: string[];
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesMatch {
    ipRanges?: string[];
}

export interface SwsSecurityProfileSecurityRuleRuleConditionConditionSourceIpIpRangesNotMatch {
    ipRanges?: string[];
}

export interface SwsSecurityProfileSecurityRuleSmartProtection {
    condition?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionCondition;
    mode?: string;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionCondition {
    authority?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthority;
    headers?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHeader[];
    httpMethod?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod;
    requestUri?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUri;
    sourceIp?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthority {
    authorities?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority[];
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionAuthorityAuthority {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionHeader {
    name?: string;
    value: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionHeaderValue {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethod {
    httpMethods?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod[];
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionHttpMethodHttpMethod {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUri {
    path?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath;
    queries?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQuery[];
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriPath {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQuery {
    key: string;
    value: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionRequestUriQueryValue {
    exactMatch?: string;
    exactNotMatch?: string;
    pireRegexMatch?: string;
    pireRegexNotMatch?: string;
    prefixMatch?: string;
    prefixNotMatch?: string;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIp {
    geoIpMatch?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatch;
    geoIpNotMatch?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatch;
    ipRangesMatch?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch;
    ipRangesNotMatch?: outputs.SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch;
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpMatch {
    locations?: string[];
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpGeoIpNotMatch {
    locations?: string[];
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesMatch {
    ipRanges?: string[];
}

export interface SwsSecurityProfileSecurityRuleSmartProtectionConditionSourceIpIpRangesNotMatch {
    ipRanges?: string[];
}

export interface SwsSecurityProfileTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpcAddressDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface VpcAddressExternalIpv4Address {
    address: string;
    ddosProtectionProvider: string;
    outgoingSmtpCapability: string;
    zoneId: string;
}

export interface VpcAddressTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcDefaultSecurityGroupEgress {
    description?: string;
    fromPort?: number;
    id: string;
    labels: {[key: string]: string};
    port?: number;
    predefinedTarget?: string;
    protocol: string;
    securityGroupId?: string;
    toPort?: number;
    v4CidrBlocks?: string[];
    v6CidrBlocks?: string[];
}

export interface VpcDefaultSecurityGroupIngress {
    description?: string;
    fromPort?: number;
    id: string;
    labels: {[key: string]: string};
    port?: number;
    predefinedTarget?: string;
    protocol: string;
    securityGroupId?: string;
    toPort?: number;
    v4CidrBlocks?: string[];
    v6CidrBlocks?: string[];
}

export interface VpcDefaultSecurityGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpcGatewaySharedEgressGateway {
}

export interface VpcGatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcNetworkTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcRouteTableStaticRoute {
    destinationPrefix?: string;
    gatewayId?: string;
    nextHopAddress?: string;
}

export interface VpcRouteTableTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcSecurityGroupEgress {
    description?: string;
    fromPort?: number;
    id: string;
    labels: {[key: string]: string};
    port?: number;
    predefinedTarget?: string;
    protocol: string;
    securityGroupId?: string;
    toPort?: number;
    v4CidrBlocks?: string[];
    v6CidrBlocks?: string[];
}

export interface VpcSecurityGroupIngress {
    description?: string;
    fromPort?: number;
    id: string;
    labels: {[key: string]: string};
    port?: number;
    predefinedTarget?: string;
    protocol: string;
    securityGroupId?: string;
    toPort?: number;
    v4CidrBlocks?: string[];
    v6CidrBlocks?: string[];
}

export interface VpcSecurityGroupRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpcSecurityGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcSubnetDhcpOptions {
    domainName?: string;
    domainNameServers?: string[];
    ntpServers?: string[];
}

export interface VpcSubnetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface YdbDatabaseDedicatedLocation {
    region?: outputs.YdbDatabaseDedicatedLocationRegion;
}

export interface YdbDatabaseDedicatedLocationRegion {
    id: string;
}

export interface YdbDatabaseDedicatedScalePolicy {
    fixedScale: outputs.YdbDatabaseDedicatedScalePolicyFixedScale;
}

export interface YdbDatabaseDedicatedScalePolicyFixedScale {
    size: number;
}

export interface YdbDatabaseDedicatedStorageConfig {
    groupCount: number;
    storageTypeId: string;
}

export interface YdbDatabaseDedicatedTimeouts {
    default?: string;
}

export interface YdbDatabaseIamBindingTimeouts {
    default?: string;
}

export interface YdbDatabaseServerlessServerlessDatabase {
    enableThrottlingRcuLimit: boolean;
    provisionedRcuLimit: number;
    storageSizeLimit: number;
    throttlingRcuLimit: number;
}

export interface YdbDatabaseServerlessTimeouts {
    default?: string;
}

export interface YdbTableChangefeedConsumer {
    name: string;
    startingMessageTimestampMs: number;
    supportedCodecs: string[];
}

export interface YdbTableChangefeedTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface YdbTableColumn {
    family: string;
    name: string;
    notNull: boolean;
    type: string;
}

export interface YdbTableFamily {
    compression: string;
    data: string;
    name: string;
}

export interface YdbTableIndexTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface YdbTablePartitioningSettings {
    autoPartitioningByLoad?: boolean;
    autoPartitioningBySizeEnabled?: boolean;
    autoPartitioningMaxPartitionsCount: number;
    autoPartitioningMinPartitionsCount: number;
    autoPartitioningPartitionSizeMb: number;
    partitionAtKeys?: outputs.YdbTablePartitioningSettingsPartitionAtKey[];
    uniformPartitions: number;
}

export interface YdbTablePartitioningSettingsPartitionAtKey {
    keys: string[];
}

export interface YdbTableTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface YdbTableTtl {
    columnName: string;
    expireInterval: string;
    unit: string;
}

export interface YdbTopicConsumer {
    important: boolean;
    name: string;
    startingMessageTimestampMs: number;
    supportedCodecs: string[];
}

export interface YdbTopicTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

